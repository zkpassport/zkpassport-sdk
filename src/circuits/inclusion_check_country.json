{"noir_version":"1.0.0-beta.1+03b58fa2dfcc8acc8cf5198b1b23b55676fbdb02","hash":3645087508679061240,"abi":{"parameters":[{"name":"comm_in","type":{"kind":"field"},"visibility":"public"},{"name":"salt","type":{"kind":"field"},"visibility":"private"},{"name":"private_nullifier","type":{"kind":"field"},"visibility":"private"},{"name":"dg1","type":{"kind":"array","length":95,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"country_list","type":{"kind":"array","length":200,"type":{"kind":"string","length":3}},"visibility":"public"},{"name":"service_scope","type":{"kind":"field"},"visibility":"public"},{"name":"service_subscope","type":{"kind":"field"},"visibility":"public"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6203402510825418558":{"error_kind":"string","string":"Country not found in the list"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"9853659065775974044":{"error_kind":"string","string":"Nationality does not match the country code"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"7Z3vThtJEMTfxZ/5sDM9f7p5ldMpIoRESAgiICedorz72YQ1VryYY0t1urmrL5FsptvDb7e2t5KK9/vm09XHb18+XN9+vnvYnP/2fXNzd3nxeH13u331fdOiPb358PXidvf64fHi/nFzXno921zdftqc19R/nG0+X99cbc5b/nF2tLSV6Xlpa/GytC0sjWL5eW2UctC3LizuLdvz4t6sHi7+/Wy77z7ovn3Qfce/dt/7xr3V/Mu++zQNuu806L7zP7hvq3PbsN5O79urtefFXks72rcNuu8y6L7roPtug+67D7pvH3TfMea+0zTovtOg+x50XqZB52UadF6mQedlGnRepkHnZRp0XqZB52UedF7mQedlHnRe5kHnZR50XuZB52UedF7mQedlHnRe5kHnpQ06L23QeWmDzksbdF7aoPPSBp2XNui8NHRedi9z+9wO9/3U3and0dnjvv/3pin92r1M1O6J2j1Tuxu1O3rlSpP789qUUj3qX8n9G7l/J/d3cv/g9q8TuX8i98/k/kbuT9ZvJeu3kvVbyfqtZP1Wsn4bWb+NrN9G1m8j67eR9dvI+m1k/TayfhtZv42s307Wbyfrt5P128n67WT9drJ+O1m/nazfTtZvJ+vXyfp1sn6drF8n69fJ+nWyfp2sXyfr18n6dbJ+g6zfIOs3yPoNsn6DrN8g6zfI+g2yfoOs3+Dq16eJ3D+R+2dyfyP3L+T+ldy/kft3cn8n9yfrN5H1m8j6TWT9JrJ+E1m/iazfRNZvIus3kfWbyPrNZP1msn4zWb+ZrN9M1m8m6zeT9ZvJ+s1k/Wayfo2sXyPr18j6NbJ+jaxfI+vXyPo1sn6NrF8j67eQ9VvI+i1k/Rayfsn5Kyfnr5ycv3Jy/srJ+Ssn56+cnL9ycv7KyfkrJ+evnJy/cnL+ysn5Kyfnr5ycv3Jy/srJ+Ssn56+cnL9ycv7KyfkrJ+evnJy/cnL+ysn5Kyfnr5ycv3Jy/srJ+Ssn56+cnL9ycv7KyfkrJ+evnJy/cnL+ysn5Kyfnr5ycv3Jy/srJ+Ssn56+cnL9ycv7KyfkrJ+evnJy/cnL+ysn5Kyfnr5ycv3Jy/srJ+Ssn56+cnL9ycv4qyPmrIOevgpy/CnL+KqZC7l/J/Ru5fyf3d3J/sn7J+asg56+CnL8Kcv4qyPmrIOevgpy/CnL+Ksj5qyDnr4Kcvwpy/irI+asg56+CnL8Kcv4qyPmrIOevgpy/CnL+Ksj5qyDnr4Kcvwpy/irI+asg56+CnL8Kcv4qyPmrIOevgpy/CnL+Ksj5qyDnr4Kcvwpy/irI+asg56+CnL8Kcv4qyPmrIOevAs9fpZL3/Xsc9Yf1m8v8hLKUfTrqD+vXyvylh8k8HfVf1K/V+VseS37ZUl76+sicI57XZkv59OJkKfabMX9j8ZTnXaSp19OLq82NW7e3jqhPe+LlgIgt/Xqpz5vIeTr40sjyE18TPgRfFz4Enwsfgi+ED8C3HO0Uvr+LLwkfgi8LH4LPhA/BV4QPwSfXAeGT64DwyXVA+OQ6IHxyHQi+LtcB4ZPrgPDJdUD45DogfEX4EHxyHRA+uQ4In1wHhE+uA8In14Hgc7kOCJ9cB4RPrgPCJ9cB4SvCh+CT64DwyXVA+OQ6IHxyHRA+uQ4EX8h1QPjkOiB8ch0QPrkOCF8RPgSfXAeET64DwifXAeGT64DwyXUA+NI0yXZg/OQ7MH4yHhg/OQ+MXxE/iJ+8B8ZP5gPjJ/eB8ZP9wPjJf0D8kvwHxk/+A+Mn/4Hxk//A+BXxg/jJf2D85D8wfvIfGD/5D4yf/AfEL8t/YPzkPzB+8h8YP/kPjF8RP4if/AfGT/4D4yf/gfGT/8D4yX9A/Ez+A+Mn/4Hxk//A+Ml/YPyK+EH85D8wfvIfGD/5D4yf/AfGT/4D4lfkPzB+8h8YP/kPjJ/8B8aviB/ET/4D4yf/gfGT/8D4yX9g/OQ/IH5V/gPjJ/+B8ZP/wPjJf2D8ivhB/OQ/MH7yHxg/+Q+Mn/wHxk/+A+KnB5uD/OQ/MH7yHxg/+Q+MXxE/iJ/8B8ZP/gPjJ/+B8ZP/wPjJf0D89IhzkJ/8B8ZP/gPjJ/+B8SviB/GT/8D4yX9g/OQ/MH7yHxg/+Q+Inx52DvKD/Uff/5a5lzcWp+42b92n/F/gl8UP4rfoP961mxav7ObnB5T/3wGy5PurVLTTB8hyel5rYceHp4reOnrbFx/vr29urr98uLm7vHi8vrt92BVOuz+sLf+/iVT2v1J5mS6t7Q7GtqavqPEVNfH+muUcdC55Pvh1Oq5JK2ryihpbUbN42cg97U/mOK6pK2raipq+omb5Pn2ar+Q2LRzTeH/NK3mU0zVpRc0i69T252jrxzXLDGw+D6wcnwfLf7+dosysp3Rck1bU5BU1tqKmrKipK2raiprl8/plgNjxebDsP9+oiffXLPuMg5qFa8jyvXWuda5ZOEeX7yffqLEVNeWNmoVryPLNQM77Gl9gsHx98/15cDhh55q+osZX1MTpmqXrTkynGdh0zO2Vp2ufvO688kjp0zVtRU1fUbPiOvrKc05frfmxffXHxf31xcebq9190+6H324v59uo7cvHP7/OP5lvtL7e311effp2f7W75Tq429p+tDUrZ9tbm/J0W7t7o0/5bPtH372Rnt5IaftGsu1nbz//Lw==","file_map":{"26":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"62":{"source":"use commitment::nullify;\nuse inclusion_check_country::check_country_inclusion;\n\nfn main(\n    comm_in: pub Field,\n    salt: Field,\n    private_nullifier: Field,\n    dg1: [u8; 95],\n    // There are roughly 200 countries in the world\n    // so we can safely pad it to 200\n    country_list: pub [str<3>; 200],\n    service_scope: pub Field,\n    service_subscope: pub Field,\n) -> pub Field {\n    // Check that nationality of the passport holder is not in the list of countries\n    check_country_inclusion(dg1, country_list);\n    let nullifier = nullify(\n        comm_in,\n        salt,\n        dg1,\n        private_nullifier,\n        service_scope,\n        service_subscope,\n    );\n    nullifier\n}\n","path":"/Users/madztheo/Documents/Wagmi/Studio/RnD/Docaproof/Circuits/zk_id_check_circuits/src/noir/bin/inclusion-check/country/src/main.nr"},"63":{"source":"use common::{calculate_scoped_nullifier, hash_salt_dg1_private_nullifier};\n\n/*\n############################################################\n# Circuit D\n############################################################\n# Generates a scoped nullifier that is scoped by service\n# Allows selective disclosure of dg1 via a reveal bitmask\n############################################################\n\n# Inputs/Outputs\n############################################################\ncomm_in             `assert comm_in == H(salt, dg1, private_nullifier)`\nsalt\ndg1\nprivate_nullifier\nservice_scope       `H(<domain_name>)`\nservice_subscope    `H(<purpose>)` (Service-specific subscope)\nscoped_nullifier    `H(private_nullifier, service_scope, service_subscope)`\n\n# Checks\n############################################################\n- Checks that dg1_reveal is the correct reveal of dg1 for the given dg1_mask\n- Constrains scoped_nullifier to be `H(private_nullifier, service_scope, service_subscope)`\n*/\npub fn nullify(\n    comm_in: Field,\n    salt: Field,\n    dg1: [u8; 95],\n    private_nullifier: Field,\n    service_scope: Field,\n    service_subscope: Field,\n) -> Field {\n    assert(comm_in == hash_salt_dg1_private_nullifier(salt, dg1, private_nullifier));\n    // println(f\"comm_in: {comm_in}\");\n    let scoped_nullifier =\n        calculate_scoped_nullifier(private_nullifier, service_scope, service_subscope);\n    // println(f\"scoped_nullifier: {scoped_nullifier}\");\n    scoped_nullifier\n}\n\n","path":"/Users/madztheo/Documents/Wagmi/Studio/RnD/Docaproof/Circuits/zk_id_check_circuits/src/noir/lib/commitment/scoped-nullifier/src/lib.nr"},"64":{"source":"//use std::hash::pedersen_hash;\nuse std::hash::poseidon2::Poseidon2;\nuse utils::PASSPORT_MRZ_COUNTRY_INDEX;\n\npub global CSC_CERT_TYPE: Field = 1;\npub global DSC_CERT_TYPE: Field = 2;\n\npub fn calculate_scoped_nullifier(\n    private_nullifier: Field,\n    service_scope: Field,\n    service_subscope: Field,\n) -> Field {\n    Poseidon2::hash([private_nullifier, service_scope, service_subscope], 3)\n}\n\npub fn calculate_certificate_registry_leaf<let N: u32>(\n    registry_id: Field,\n    cert_type: Field,\n    country: str<3>,\n    csc_pubkey: [u8; N],\n) -> Field {\n    let country_bytes: [u8; 3] = country.as_bytes();\n    let mut result: [Field; N + 5] = [0; N + 5];\n    result[0] = registry_id as Field;\n    result[1] = cert_type as Field;\n    result[2] = country_bytes[0] as Field;\n    result[3] = country_bytes[1] as Field;\n    result[4] = country_bytes[2] as Field;\n    for i in 0..N {\n        result[i + 5] = csc_pubkey[i] as Field;\n    }\n    Poseidon2::hash(result, N + 5)\n}\n\npub fn get_country_from_dg1(dg1: [u8; 95]) -> str<3> {\n    // There 5 padding bytes in the dg1 before the actual MRZ\n    let country_offset = 5 + PASSPORT_MRZ_COUNTRY_INDEX;\n    let mut country_bytes: [u8; 3] = [0; 3];\n    for i in 0..3 {\n        country_bytes[i] = dg1[country_offset + i];\n    }\n    country_bytes.as_str_unchecked()\n}\n\npub fn hash_salt_country_tbs<let TBS_MAX_SIZE: u32>(\n    salt: Field,\n    country: str<3>,\n    tbs: [u8; TBS_MAX_SIZE],\n) -> Field {\n    let country_bytes: [u8; 3] = country.as_bytes();\n    let mut result: [Field; TBS_MAX_SIZE + 4] = [0; TBS_MAX_SIZE + 4];\n    result[0] = salt as Field;\n    result[1] = country_bytes[0] as Field;\n    result[2] = country_bytes[1] as Field;\n    result[3] = country_bytes[2] as Field;\n    for i in 0..TBS_MAX_SIZE {\n        result[4 + i] = tbs[i] as Field;\n    }\n    Poseidon2::hash(result, TBS_MAX_SIZE + 4)\n}\n\npub fn hash_salt_dg1_private_nullifier<let N: u32>(\n    salt: Field,\n    dg1: [u8; N],\n    private_nullifier: Field,\n) -> Field {\n    let mut result: [Field; N + 2] = [0; N + 2];\n    result[0] = salt as Field;\n    for i in 0..N {\n        result[1 + i] = dg1[i] as Field;\n    }\n    result[1 + N] = private_nullifier;\n    Poseidon2::hash(result, N + 2)\n}\n\npub fn calculate_private_nullifier<let DG1: u32, let SIG: u32>(\n    dg1: [u8; DG1],\n    sod_sig: [u8; SIG],\n) -> Field {\n    let mut result: [Field; DG1 + SIG] = [0; DG1 + SIG];\n    for i in 0..DG1 {\n        result[i] = dg1[i] as Field;\n    }\n    for i in 0..SIG {\n        result[DG1 + i] = sod_sig[i] as Field;\n    }\n    Poseidon2::hash(result, DG1 + SIG)\n}\n\npub fn hash_salt_country_signed_attr_dg1_private_nullifier<let SA: u32>(\n    salt: Field,\n    country: str<3>,\n    signed_attr: [u8; SA],\n    signed_attr_size: Field,\n    dg1: [u8; 95],\n    private_nullifier: Field,\n) -> Field {\n    let country_bytes: [u8; 3] = country.as_bytes();\n    let mut result: [Field; SA + 101] = [0; SA + 101];\n    result[0] = salt as Field;\n    result[1] = country_bytes[0] as Field;\n    result[2] = country_bytes[1] as Field;\n    result[3] = country_bytes[2] as Field;\n    for i in 0..SA {\n        result[4 + i] = signed_attr[i] as Field;\n    }\n    result[4 + SA] = signed_attr_size;\n    for i in 0..95 {\n        result[4 + SA + 1 + i] = dg1[i] as Field;\n    }\n    result[4 + SA + 1 + 95] = private_nullifier;\n    Poseidon2::hash(result, SA + 101)\n}\n","path":"/Users/madztheo/Documents/Wagmi/Studio/RnD/Docaproof/Circuits/zk_id_check_circuits/src/noir/lib/commitment/common/src/lib.nr"},"65":{"source":"/**\n* The standards for passports and any other travel documents, electronic or not,\n* are defined in the ICAO (International Civil Aviation Organization) 9303 document available here:\n* https://www.icao.int/publications/pages/publication.aspx?docnum=9303\n*/\n\n/**\n* The structure of the MRZ is well defined and standardized by the ICAO\n* so the index will always be the same for every passport\n* c.f. ICAO 9303-4, Appendix B\n*/\n\n// The following constants define the indices of the information\n// we need to generate various proofs of identity from the MRZ\n// The structure of the MRZ is slightly different between passports\n// and ID cards so we need to define indices for both types\n\n// Index for the country of issuance of the passport\npub global PASSPORT_MRZ_COUNTRY_INDEX: u32 = 2;\n// Index for the three letter code of the country of citizenship\n// Note that the first three letter code (index 2) in the MRZ is the country of issuance\n// not citizenship. It is important to keep in mind for residence permits\n// where the issuing country differs from the citizenship country\npub global PASSPORT_MRZ_NATIONALITY_INDEX: u32 = 54;\n// Index for the gender of the passport holder (M, F or < if unspecified)\npub global PASSPORT_MRZ_GENDER_INDEX: u32 = 64;\n// Index for the date of expiry (YYMMDD)\npub global PASSPORT_MRZ_EXPIRY_DATE_INDEX: u32 = 65;\n// Index for the date of birth (YYMMDD) in TD1 (i.e. passport) MRZ\npub global PASSPORT_MRZ_BIRTHDATE_INDEX: u32 = 57;\n// Index for the document number in the MRZ\npub global PASSPORT_MRZ_DOCUMENT_NUMBER_INDEX: u32 = 44;\n// Index for the document type in the MRZ\npub global PASSPORT_MRZ_DOCUMENT_TYPE_INDEX: u32 = 0;\n// Index for the name of the passport holder\npub global PASSPORT_MRZ_NAME_INDEX: u32 = 5;\n// Length of the MRZ on a passport\npub global PASSPORT_MRZ_LENGTH: u32 = 88;\n\n// Index for the country of issuance of the ID card\npub global ID_CARD_MRZ_COUNTRY_INDEX: u32 = 2;\n// Note that the first three letter code (index 2) in the MRZ is the country of issuance\n// not citizenship. It is important to keep in mind for residence permits\n// where the issuing country differs from the citizenship country\npub global ID_CARD_MRZ_NATIONALITY_INDEX: u32 = 45;\n// Index for the gender of the passport holder (M, F or < if unspecified)\npub global ID_CARD_MRZ_GENDER_INDEX: u32 = 37;\n// Index for the date of expiry (YYMMDD)\npub global ID_CARD_MRZ_EXPIRY_DATE_INDEX: u32 = 38;\n// Index for the date of birth (YYMMDD) in TD3 (i.e. ID cards) MRZ\npub global ID_CARD_MRZ_BIRTHDATE_INDEX: u32 = 30;\n// Index for the document number in the MRZ\npub global ID_CARD_MRZ_DOCUMENT_NUMBER_INDEX: u32 = 5;\n// Index for the document type in the MRZ\npub global ID_CARD_MRZ_DOCUMENT_TYPE_INDEX: u32 = 0;\n// Index for the name of the passport holder\npub global ID_CARD_MRZ_NAME_INDEX: u32 = 60;\n// Length of the MRZ on an ID card\npub global ID_CARD_MRZ_LENGTH: u32 = 90;\n\n// ECDSA curves mapping\npub global ECDSA_CURVE_P256: u32 = 0;\npub global ECDSA_CURVE_P384: u32 = 1;\npub global ECDSA_CURVE_P521: u32 = 2;\npub global ECDSA_CURVE_BRAINPOOL_B256R1: u32 = 3;\npub global ECDSA_CURVE_BRAINPOOL_B256T1: u32 = 4;\npub global ECDSA_CURVE_BRAINPOOL_B384R1: u32 = 5;\npub global ECDSA_CURVE_BRAINPOOL_B384T1: u32 = 6;\npub global ECDSA_CURVE_BRAINPOOL_B512R1: u32 = 7;\npub global ECDSA_CURVE_BRAINPOOL_B512T1: u32 = 8;\n\npub struct IDData {\n    // Regroups the hashes of all the data groups plus some padding\n    // at the start and in between each data group hashes\n    pub e_content: [u8; 700],\n    pub e_content_size: u32,\n    // Where we can find e_content in the signed_attributes\n    // It varies from document to document according to the length\n    // of the padding at the start\n    pub dg1_offset_in_e_content: u32,\n    // Last 32 bytes: result of the hash of all the hashes of the data groups\n    // Rest of the bytes: information about the signature algorithm, date, etc.\n    pub signed_attributes: [u8; 200],\n    pub signed_attributes_size: u32,\n    // The DG1 contains the Machine Readable Zone (MRZ) of the document\n    // The two lines at the bottom of the passport data page\n    // or the three bottom lines on the rear of an ID card\n    // 95 bytes for passports, 93 bytes for ID cards\n    // Including 88 bytes of MRZ and 5 bytes of padding for passports\n    // and 90 bytes of MRZ and 5 bytes of padding for ID cards\n    pub dg1: [u8; 95],\n    // The signature over the data groups\n    pub sod_signature: [u8; 512],\n    pub sod_signature_size: u32,\n}\n\npub struct DSCData {\n    // The TBS certificate of the DSC\n    // TBS stands for To Be Signed\n    pub tbs_certificate: [u8; 1500],\n    pub tbs_certificate_size: u32,\n    // The public key of the DSC (up to 512 bytes to account for RSA-4096)\n    pub pubkey: [u8; 512],\n    // The actual size of the public key\n    pub pubkey_size: u32,\n    // The index of the public key in the TBS certificate\n    pub pubkey_index: u32,\n    // Data used to verify the signature\n    // Generated by the pre-compute function in Rust\n    // c.f. main.rs\n    pub pubkey_redc_param: [u8; 513],\n    // The signature over the TBS certificate\n    pub signature: [u8; 512],\n    pub signature_size: u32,\n    // The exponent of the public key\n    // Only useful for RSA, can be ignored for ECDSA\n    pub exponent: u32,\n}\n\npub struct CSCData {\n    // The public key of the CSC (up to 512 bytes to account for RSA-4096)\n    pub pubkey: [u8; 512],\n    // The actual size of the public key\n    pub pubkey_size: u32,\n    // Data used to verify the signature\n    // Generated by the pre-compute function in Rust\n    // c.f. main.rs\n    pub pubkey_redc_param: [u8; 513],\n    // Only useful for RSA, can be ignored for ECDSA\n    pub exponent: u32,\n}\n\npub struct DiscloseFlags {\n    pub issuing_country: bool,\n    pub nationality: bool,\n    pub document_type: bool,\n    pub document_number: bool,\n    pub date_of_expiry: bool,\n    pub date_of_birth: bool,\n    pub gender: bool,\n    pub name: bool,\n}\n\npub struct DisclosedData {\n    pub issuing_country: [u8; 3],\n    pub nationality: [u8; 3],\n    pub document_type: [u8; 2],\n    pub document_number: [u8; 9],\n    pub date_of_expiry: [u8; 6],\n    pub date_of_birth: [u8; 6],\n    pub name: [u8; 39],\n    pub gender: [u8; 1],\n}\n\npub fn get_array_slice<let N: u32, let M: u32>(arr: [u8; N], start: u32, end: u32) -> [u8; M] {\n    let mut slice = [0 as u8; M];\n    for i in start..end {\n        slice[i - start] = arr[i];\n    }\n    slice\n}\n\npub fn get_array_slice_constant<let N: u32, let M: u32>(arr: [u8; N]) -> [u8; M] {\n    let mut slice = [0 as u8; M];\n    for i in 0..M {\n        slice[i] = arr[i];\n    }\n    slice\n}\n\n// Reverse the bytes of an array so you can switch from\n// big endian to little endian order and vice versa\npub fn reverse_bytes_array<let N: u32>(arr: [u8; N]) -> [u8; N] {\n    let mut reversed_arr = [0 as u8; N];\n    for i in 0..N {\n        // Reverse\n        reversed_arr[i] = arr[N - 1 - i];\n    }\n    reversed_arr\n}\n\npub fn insert_into_array<let N: u32, let M: u32>(\n    mut arr: [u8; N],\n    sub_arr: [u8; M],\n    index: u32,\n) -> [u8; N] {\n    for i in index..index + M {\n        arr[i] = sub_arr[i - index];\n    }\n    arr\n}\n\npub fn dynamic_insert_into_array<let N: u32, let M: u32>(\n    mut arr: [u8; N],\n    sub_arr: [u8; M],\n    index: u32,\n    max_size: u32,\n) -> [u8; N] {\n    for i in index..index + max_size {\n        if i - index < M {\n            arr[i] = sub_arr[i - index];\n        }\n    }\n    arr\n}\n\npub fn is_id_card(dg1: [u8; 95]) -> bool {\n    // For passport, the last two bytes are 0\n    // since the real length is 93 for passports\n    // while it is 95 for ID cards\n    (dg1[93] != 0) & (dg1[94] != 0)\n}\n\npub fn from_byte_be_to_fields<let NBytes: u32, let N: u32>(x: [u8; NBytes]) -> [Field; N] {\n    let mut result = [0 as Field; N];\n\n    let mut limb: Field = 0;\n    let mut k = 0;\n    for _j in 0..(15 - (N * 15 - NBytes)) {\n        limb *= 256;\n        limb += x[k] as Field;\n        k += 1;\n    }\n    std::as_witness(limb);\n\n    result[N - 1] = limb;\n\n    for i in 1..N {\n        let mut limb: Field = 0;\n        for _j in 0..15 {\n            limb *= 256;\n            limb += x[k] as Field;\n            k += 1;\n        }\n        std::as_witness(limb);\n        result[N - i - 1] = limb;\n    }\n\n    result\n}\n\npub unconstrained fn __from_byte_be_to_fields<let NBytes: u32, let N: u32>(\n    x: [u8; NBytes],\n) -> [Field; N] {\n    from_byte_be_to_fields(x)\n}\n\npub fn get_mrz_from_dg1(dg1: [u8; 95]) -> [u8; 90] {\n    let mut mrz = [0 as u8; 90];\n    for i in 0..90 {\n        mrz[i] = dg1[i + 5];\n    }\n    mrz\n}\n\npub fn split_array<let N: u32>(array: [u8; N * 2]) -> ([u8; N], [u8; N]) {\n    let mut array_x = [0 as u8; N];\n    let mut array_y = [0 as u8; N];\n    for i in 0..N {\n        array_x[i] = array[i];\n        array_y[i] = array[i + N];\n    }\n    (array_x, array_y)\n}\n\npub fn concat_array<let N: u32>(array_x: [u8; N], array_y: [u8; N]) -> [u8; N * 2] {\n    let mut array = [0 as u8; N * 2];\n    for i in 0..N {\n        array[i] = array_x[i];\n        array[i + N] = array_y[i];\n    }\n    array\n}\n\npub fn check_zero_padding<let N: u32, T>(padded_array: [T; N], len: u32)\nwhere\n    T: Eq,\n    T: Default,\n{\n    for i in 0..N {\n        if i >= len {\n            assert_eq(padded_array[i], T::default());\n        }\n    }\n}\n\npub fn get_nationality_from_mrz(dg1: [u8; 95]) -> [u8; 3] {\n    let mrz = get_mrz_from_dg1(dg1);\n\n    let mut country_bytes: [u8; 3] = [0; 3];\n\n    if is_id_card(dg1) {\n        country_bytes = get_array_slice(\n            mrz,\n            ID_CARD_MRZ_NATIONALITY_INDEX,\n            ID_CARD_MRZ_NATIONALITY_INDEX + 3,\n        );\n    } else {\n        country_bytes = get_array_slice(\n            mrz,\n            PASSPORT_MRZ_NATIONALITY_INDEX,\n            PASSPORT_MRZ_NATIONALITY_INDEX + 3,\n        );\n    }\n\n    country_bytes\n}\n","path":"/Users/madztheo/Documents/Wagmi/Studio/RnD/Docaproof/Circuits/zk_id_check_circuits/src/noir/lib/utils/src/lib.nr"},"66":{"source":"use utils::get_nationality_from_mrz;\n\nunconstrained fn get_index<let N: u32>(list: [str<3>; N], value: [u8; 3]) -> i32 {\n    let mut index: i32 = -1;\n    for i in 0..N {\n        let list_item = list[i].as_bytes();\n        if (list_item[0] == value[0]) & (list_item[1] == value[1]) & (list_item[2] == value[2]) {\n            index = i as i32;\n        }\n    }\n    index\n}\n\n/// Check if the nationality from the MRZ is in the country list\n///\n/// # Arguments\n///\n/// * `dg1`: The MRZ\n/// * `country_list`: The list of countries\npub fn check_country_inclusion<let N: u32>(dg1: [u8; 95], country_list: [str<3>; N]) {\n    let nationality_bytes = get_nationality_from_mrz(dg1);\n\n    // Get the index of the country in the list from an unconstrained function\n    let country_index = unsafe { get_index(country_list, nationality_bytes) };\n    // Assert that the country was found\n    assert(country_index != -1, \"Country not found in the list\");\n\n    // Assert that the nationality is equal to the country in the list\n    // at the index found by the unconstrained function\n    let country_code = country_list[country_index].as_bytes();\n    assert_eq(nationality_bytes[0], country_code[0], \"Nationality does not match the country code\");\n    assert_eq(nationality_bytes[1], country_code[1], \"Nationality does not match the country code\");\n    assert_eq(nationality_bytes[2], country_code[2], \"Nationality does not match the country code\");\n}\n","path":"/Users/madztheo/Documents/Wagmi/Studio/RnD/Docaproof/Circuits/zk_id_check_circuits/src/noir/lib/inclusion-check/country/src/lib.nr"}},"names":["main"],"brillig_names":["get_index","directive_invert"]}