{"noir_version":"1.0.0-beta.1+03b58fa2dfcc8acc8cf5198b1b23b55676fbdb02","hash":9204322075884189533,"abi":{"parameters":[{"name":"comm_in","type":{"kind":"field"},"visibility":"public"},{"name":"salt","type":{"kind":"field"},"visibility":"private"},{"name":"private_nullifier","type":{"kind":"field"},"visibility":"private"},{"name":"dg1","type":{"kind":"array","length":95,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"disclose_mask","type":{"kind":"array","length":90,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"service_scope","type":{"kind":"field"},"visibility":"public"},{"name":"service_subscope","type":{"kind":"field"},"visibility":"public"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"array","length":90,"type":{"kind":"integer","sign":"unsigned","width":8}},{"kind":"field"}]},"visibility":"public"},"error_types":{"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"}}},"bytecode":"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","debug_symbols":"7Z3RThtXFEX/xc88zD3nzr0z/EpVRQZMZMmyEZhKFeLfO6E2VAqQtlvrJdlvAYYjs9CKssiWeFrdbK4ev37Z7m8PD6vL355Wu8P1+rg97Je3nlZlGl/e+XC33n97++G4vj+uLrOUi9Vmf7P8aRyeL1a3291mddni+eK7R8cynZ8dy9zfHm7Pv18s9xt8v8P3J/j+zN6fB/h+ge8HfD/h+xW+D/s7w/7OsL8z7O/M+hvDAN8v8P2A7yd8v8L3R/h+g+93+P4E34f9LbC/Bfa3wP4W2N8C+1tgfwvsb4H9LbC/BfY3YH8D9jdgfwP2N2B/A/Y3YH8D9jdgfwP2N2F/E/Y3YX8T9jdhfxP2N2F/E/Y3YX8T9rfC/lbY3wr7W2F/K+xvhf2tsL8V9rfC/lbY3xH2d4T9HWF/R9jfEfZ3hP0dYX9H2N8R9neE/W2wvw32t8H+NtjfBvvbYH8b7G+D/W2wvw32t8P+dtjfDvvbYX877G+H/e2wvx32t8P+dtjfCfZ3gv2dYH8n2N8J9hfeXwW8vwp4fxXw/irg/VXA+6uA91cB768C3l8FvL8KeH8V8P4q4P1VwPurgPdXCe+vEt5fJby/Snh/lUOF74/w/Qbf7/D9Cb4P+wvvrxLeXyW8v0p4f5Xw/irh/VXC+6uE91cJ768S3l8lvL9KeH+V8P4q4f1VwvurhPdXCe+vEt5fJby/Snh/lfD+KuH9VcL7q4T3VwnvrxLeXyW8v0p4f5Xw/irh/VXC+6uE91cJ768S3l8lvL9KeH+V8P4q4f1VwvurhPdXCe+vEt5fJby/Snh/lfD+KuH9VcL7q4T3VwnvrxLeXyW8v0p4f5Xw/irh/VXC+6v8YH81ttPn1Hi7H+2d+7H8F8jp2Vh+Wvj5w2X5ec3p4bL80/QHDw9xfhVl6OPnD2efX7/K/JxIKdNwvhu1vD2c7315pZ9fRMTQ3h6uf+Nrxqfg68an4JuMT8E3G5+A74Npp/H9S3zF+BR8YXwKvjQ+BV81PgWfq0PC5+qQ8Lk6JHyuDgmfq0PBN7k6JHyuDgmfq0PC5+qQ8FXjU/C5OiR8rg4Jn6tDwufqkPC5OhR8s6tDwufqkPC5OiR8rg4JXzU+BZ+rQ8Ln6pDwuTokfK4OCZ+rQ8BXB1eHhM/VIeFzdUj4XB0Svmp8Cj5Xh4TP1SHhc3VI+FwdEj5Xh4KvuDokfK4OCZ+rQ8Ln6pDwVeNT8Lk6JHyuDgmfq0PC5+qQ8Lk6FHzh6pDwuTokfK4OCZ+rQ8JXjU/B5+qQ8Lk6JHyuDgmfq0PC5+pQ8KWrQ8Ln6pDwuTokfK4OCV81PgWfq0PC5+qQ8Lk6JHyuDgmfq0PBV10dEj5Xh4TP1SHhc3VI+KrxKfhcHRI+V4eEz9Uh4XN1SPhcHQq+0dUh4XN1SPhcHRI+V4eErxqfgs/VIeFzdUj4XB0SPleHhM/VoeBrrg4Jn6tDwufqkPC5OiR81fgUfK4OCZ+rQ8Ln6pDwuTokfK4OBZ9/N7mGz9Uh4XN1SPhcHRK+anwKPleHhM/VIeFzdUj4XB0SPleHgs+/m1zD5+qQ8Lk6JHyuDglfNT4Fn6tDwufqkPC5OiR8rg4Jn6tDweffTa7hk6ujv36R0esPHi59yvMrn4b4CfCF8Sn43q+O//Ji2vzBi3m5X3+9b0+W6fVvqLl9/u3JKKdnc87vvjmj4f0/eMsbV/fb3W779cvucL0+bg/7h+UTl3f/sb7frq92m9Obt4/763989Pjn3fkj58+/uz9cb24e7zffLr18bDn/Fw==","file_map":{"26":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"62":{"source":"use disclose::get_disclosed_bytes;\nuse commitment::nullify;\n\nfn main(\n    comm_in: pub Field,\n    salt: Field,\n    private_nullifier: Field,\n    dg1: [u8; 95],\n    disclose_mask: pub [u8; 90],\n    service_scope: pub Field,\n    service_subscope: pub Field,\n) -> pub ([u8; 90], Field) {\n    let disclosed_bytes = get_disclosed_bytes(dg1, disclose_mask);\n    let scoped_nullifier = nullify(\n        comm_in,\n        salt,\n        dg1,\n        private_nullifier,\n        service_scope,\n        service_subscope,\n    );\n    (disclosed_bytes, scoped_nullifier)\n}\n","path":"/Users/madztheo/Documents/Wagmi/Studio/RnD/Docaproof/Circuits/zk_id_check_circuits/src/noir/bin/disclose/bytes/src/main.nr"},"63":{"source":"use common::{calculate_scoped_nullifier, hash_salt_dg1_private_nullifier};\n\n/*\n############################################################\n# Circuit D\n############################################################\n# Generates a scoped nullifier that is scoped by service\n# Allows selective disclosure of dg1 via a reveal bitmask\n############################################################\n\n# Inputs/Outputs\n############################################################\ncomm_in             `assert comm_in == H(salt, dg1, private_nullifier)`\nsalt\ndg1\nprivate_nullifier\nservice_scope       `H(<domain_name>)`\nservice_subscope    `H(<purpose>)` (Service-specific subscope)\nscoped_nullifier    `H(private_nullifier, service_scope, service_subscope)`\n\n# Checks\n############################################################\n- Checks that dg1_reveal is the correct reveal of dg1 for the given dg1_mask\n- Constrains scoped_nullifier to be `H(private_nullifier, service_scope, service_subscope)`\n*/\npub fn nullify(\n    comm_in: Field,\n    salt: Field,\n    dg1: [u8; 95],\n    private_nullifier: Field,\n    service_scope: Field,\n    service_subscope: Field,\n) -> Field {\n    assert(comm_in == hash_salt_dg1_private_nullifier(salt, dg1, private_nullifier));\n    // println(f\"comm_in: {comm_in}\");\n    let scoped_nullifier =\n        calculate_scoped_nullifier(private_nullifier, service_scope, service_subscope);\n    // println(f\"scoped_nullifier: {scoped_nullifier}\");\n    scoped_nullifier\n}\n\n","path":"/Users/madztheo/Documents/Wagmi/Studio/RnD/Docaproof/Circuits/zk_id_check_circuits/src/noir/lib/commitment/scoped-nullifier/src/lib.nr"},"64":{"source":"//use std::hash::pedersen_hash;\nuse std::hash::poseidon2::Poseidon2;\nuse utils::PASSPORT_MRZ_COUNTRY_INDEX;\n\npub global CSC_CERT_TYPE: Field = 1;\npub global DSC_CERT_TYPE: Field = 2;\n\npub fn calculate_scoped_nullifier(\n    private_nullifier: Field,\n    service_scope: Field,\n    service_subscope: Field,\n) -> Field {\n    Poseidon2::hash([private_nullifier, service_scope, service_subscope], 3)\n}\n\npub fn calculate_certificate_registry_leaf<let N: u32>(\n    registry_id: Field,\n    cert_type: Field,\n    country: str<3>,\n    csc_pubkey: [u8; N],\n) -> Field {\n    let country_bytes: [u8; 3] = country.as_bytes();\n    let mut result: [Field; N + 5] = [0; N + 5];\n    result[0] = registry_id as Field;\n    result[1] = cert_type as Field;\n    result[2] = country_bytes[0] as Field;\n    result[3] = country_bytes[1] as Field;\n    result[4] = country_bytes[2] as Field;\n    for i in 0..N {\n        result[i + 5] = csc_pubkey[i] as Field;\n    }\n    Poseidon2::hash(result, N + 5)\n}\n\npub fn get_country_from_dg1(dg1: [u8; 95]) -> str<3> {\n    // There 5 padding bytes in the dg1 before the actual MRZ\n    let country_offset = 5 + PASSPORT_MRZ_COUNTRY_INDEX;\n    let mut country_bytes: [u8; 3] = [0; 3];\n    for i in 0..3 {\n        country_bytes[i] = dg1[country_offset + i];\n    }\n    country_bytes.as_str_unchecked()\n}\n\npub fn hash_salt_country_tbs<let TBS_MAX_SIZE: u32>(\n    salt: Field,\n    country: str<3>,\n    tbs: [u8; TBS_MAX_SIZE],\n) -> Field {\n    let country_bytes: [u8; 3] = country.as_bytes();\n    let mut result: [Field; TBS_MAX_SIZE + 4] = [0; TBS_MAX_SIZE + 4];\n    result[0] = salt as Field;\n    result[1] = country_bytes[0] as Field;\n    result[2] = country_bytes[1] as Field;\n    result[3] = country_bytes[2] as Field;\n    for i in 0..TBS_MAX_SIZE {\n        result[4 + i] = tbs[i] as Field;\n    }\n    Poseidon2::hash(result, TBS_MAX_SIZE + 4)\n}\n\npub fn hash_salt_dg1_private_nullifier<let N: u32>(\n    salt: Field,\n    dg1: [u8; N],\n    private_nullifier: Field,\n) -> Field {\n    let mut result: [Field; N + 2] = [0; N + 2];\n    result[0] = salt as Field;\n    for i in 0..N {\n        result[1 + i] = dg1[i] as Field;\n    }\n    result[1 + N] = private_nullifier;\n    Poseidon2::hash(result, N + 2)\n}\n\npub fn calculate_private_nullifier<let DG1: u32, let SIG: u32>(\n    dg1: [u8; DG1],\n    sod_sig: [u8; SIG],\n) -> Field {\n    let mut result: [Field; DG1 + SIG] = [0; DG1 + SIG];\n    for i in 0..DG1 {\n        result[i] = dg1[i] as Field;\n    }\n    for i in 0..SIG {\n        result[DG1 + i] = sod_sig[i] as Field;\n    }\n    Poseidon2::hash(result, DG1 + SIG)\n}\n\npub fn hash_salt_country_signed_attr_dg1_private_nullifier<let SA: u32>(\n    salt: Field,\n    country: str<3>,\n    signed_attr: [u8; SA],\n    signed_attr_size: Field,\n    dg1: [u8; 95],\n    private_nullifier: Field,\n) -> Field {\n    let country_bytes: [u8; 3] = country.as_bytes();\n    let mut result: [Field; SA + 101] = [0; SA + 101];\n    result[0] = salt as Field;\n    result[1] = country_bytes[0] as Field;\n    result[2] = country_bytes[1] as Field;\n    result[3] = country_bytes[2] as Field;\n    for i in 0..SA {\n        result[4 + i] = signed_attr[i] as Field;\n    }\n    result[4 + SA] = signed_attr_size;\n    for i in 0..95 {\n        result[4 + SA + 1 + i] = dg1[i] as Field;\n    }\n    result[4 + SA + 1 + 95] = private_nullifier;\n    Poseidon2::hash(result, SA + 101)\n}\n","path":"/Users/madztheo/Documents/Wagmi/Studio/RnD/Docaproof/Circuits/zk_id_check_circuits/src/noir/lib/commitment/common/src/lib.nr"},"66":{"source":"use utils::{\n    IDData, is_id_card, DisclosedData, DiscloseFlags, PASSPORT_MRZ_COUNTRY_INDEX,\n    PASSPORT_MRZ_LENGTH, PASSPORT_MRZ_BIRTHDATE_INDEX, PASSPORT_MRZ_NATIONALITY_INDEX,\n    PASSPORT_MRZ_NAME_INDEX, PASSPORT_MRZ_DOCUMENT_NUMBER_INDEX, PASSPORT_MRZ_GENDER_INDEX,\n    PASSPORT_MRZ_EXPIRY_DATE_INDEX, PASSPORT_MRZ_DOCUMENT_TYPE_INDEX, ID_CARD_MRZ_COUNTRY_INDEX,\n    ID_CARD_MRZ_LENGTH, ID_CARD_MRZ_BIRTHDATE_INDEX, ID_CARD_MRZ_NATIONALITY_INDEX,\n    ID_CARD_MRZ_NAME_INDEX, ID_CARD_MRZ_DOCUMENT_NUMBER_INDEX, ID_CARD_MRZ_GENDER_INDEX,\n    ID_CARD_MRZ_EXPIRY_DATE_INDEX, ID_CARD_MRZ_DOCUMENT_TYPE_INDEX, get_mrz_from_dg1,\n};\n\nfn get_array_slice<let N: u32, let M: u32>(array: [u8; N], start: u32, end: u32) -> [u8; M] {\n    let mut slice = [0 as u8; M];\n    for i in 0..M {\n        slice[i] = array[start + i];\n    }\n    slice\n}\n\npub fn get_disclosed_data(dg1: [u8; 95], flags: DiscloseFlags) -> DisclosedData {\n    let mrz = get_mrz_from_dg1(dg1);\n    let mut disclosed_data = DisclosedData {\n        issuing_country: [0 as u8; 3],\n        date_of_birth: [0 as u8; 6],\n        nationality: [0 as u8; 3],\n        name: [0 as u8; 39],\n        document_number: [0 as u8; 9],\n        date_of_expiry: [0 as u8; 6],\n        document_type: [0 as u8; 2],\n        gender: [0 as u8; 1],\n    };\n\n    if is_id_card(dg1) {\n        if flags.issuing_country {\n            disclosed_data.issuing_country = get_array_slice(\n                mrz,\n                ID_CARD_MRZ_COUNTRY_INDEX,\n                ID_CARD_MRZ_COUNTRY_INDEX + 3,\n            );\n        }\n        if flags.date_of_birth {\n            disclosed_data.date_of_birth = get_array_slice(\n                mrz,\n                ID_CARD_MRZ_BIRTHDATE_INDEX,\n                ID_CARD_MRZ_BIRTHDATE_INDEX + 6,\n            );\n        }\n        if flags.nationality {\n            disclosed_data.nationality = get_array_slice(\n                mrz,\n                ID_CARD_MRZ_NATIONALITY_INDEX,\n                ID_CARD_MRZ_NATIONALITY_INDEX + 3,\n            );\n        }\n        if flags.name {\n            disclosed_data.name =\n                get_array_slice(mrz, ID_CARD_MRZ_NAME_INDEX, ID_CARD_MRZ_NAME_INDEX + 30);\n        }\n        if flags.document_number {\n            disclosed_data.document_number = get_array_slice(\n                mrz,\n                ID_CARD_MRZ_DOCUMENT_NUMBER_INDEX,\n                ID_CARD_MRZ_DOCUMENT_NUMBER_INDEX + 9,\n            );\n        }\n        if flags.date_of_expiry {\n            disclosed_data.date_of_expiry = get_array_slice(\n                mrz,\n                ID_CARD_MRZ_EXPIRY_DATE_INDEX,\n                ID_CARD_MRZ_EXPIRY_DATE_INDEX + 6,\n            );\n        }\n        if flags.document_type {\n            disclosed_data.document_type = get_array_slice(\n                mrz,\n                ID_CARD_MRZ_DOCUMENT_TYPE_INDEX,\n                ID_CARD_MRZ_DOCUMENT_TYPE_INDEX + 2,\n            );\n        }\n        if flags.gender {\n            disclosed_data.gender = get_array_slice(\n                mrz,\n                ID_CARD_MRZ_GENDER_INDEX,\n                ID_CARD_MRZ_GENDER_INDEX + 1,\n            );\n        }\n    } else {\n        if flags.issuing_country {\n            disclosed_data.issuing_country = get_array_slice(\n                mrz,\n                PASSPORT_MRZ_COUNTRY_INDEX,\n                PASSPORT_MRZ_COUNTRY_INDEX + 3,\n            );\n        }\n        if flags.date_of_birth {\n            disclosed_data.date_of_birth = get_array_slice(\n                mrz,\n                PASSPORT_MRZ_BIRTHDATE_INDEX,\n                PASSPORT_MRZ_BIRTHDATE_INDEX + 6,\n            );\n        }\n        if flags.nationality {\n            disclosed_data.nationality = get_array_slice(\n                mrz,\n                PASSPORT_MRZ_NATIONALITY_INDEX,\n                PASSPORT_MRZ_NATIONALITY_INDEX + 3,\n            );\n        }\n        if flags.name {\n            disclosed_data.name =\n                get_array_slice(mrz, PASSPORT_MRZ_NAME_INDEX, PASSPORT_MRZ_NAME_INDEX + 39);\n        }\n        if flags.document_number {\n            disclosed_data.document_number = get_array_slice(\n                mrz,\n                PASSPORT_MRZ_DOCUMENT_NUMBER_INDEX,\n                PASSPORT_MRZ_DOCUMENT_NUMBER_INDEX + 9,\n            );\n        }\n        if flags.date_of_expiry {\n            disclosed_data.date_of_expiry = get_array_slice(\n                mrz,\n                PASSPORT_MRZ_EXPIRY_DATE_INDEX,\n                PASSPORT_MRZ_EXPIRY_DATE_INDEX + 6,\n            );\n        }\n        if flags.document_type {\n            disclosed_data.document_type = get_array_slice(\n                mrz,\n                PASSPORT_MRZ_DOCUMENT_TYPE_INDEX,\n                PASSPORT_MRZ_DOCUMENT_TYPE_INDEX + 2,\n            );\n        }\n        if flags.gender {\n            disclosed_data.gender = get_array_slice(\n                mrz,\n                PASSPORT_MRZ_GENDER_INDEX,\n                PASSPORT_MRZ_GENDER_INDEX + 1,\n            );\n        }\n    }\n\n    disclosed_data\n}\n\npub fn get_disclosed_bytes(dg1: [u8; 95], mask: [u8; 90]) -> [u8; 90] {\n    let mut disclosed_bytes = [0 as u8; 90];\n    let mrz = get_mrz_from_dg1(dg1);\n    for i in 0..90 {\n        disclosed_bytes[i] = mask[i] * mrz[i];\n    }\n    disclosed_bytes\n}\n","path":"/Users/madztheo/Documents/Wagmi/Studio/RnD/Docaproof/Circuits/zk_id_check_circuits/src/noir/lib/disclose/src/lib.nr"}},"names":["main"],"brillig_names":[]}