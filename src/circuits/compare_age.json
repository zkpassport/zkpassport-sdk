{"noir_version":"1.0.0-beta.1+03b58fa2dfcc8acc8cf5198b1b23b55676fbdb02","hash":7577282437592721001,"abi":{"parameters":[{"name":"comm_in","type":{"kind":"field"},"visibility":"public"},{"name":"salt","type":{"kind":"field"},"visibility":"private"},{"name":"private_nullifier","type":{"kind":"field"},"visibility":"private"},{"name":"dg1","type":{"kind":"array","length":95,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"current_date","type":{"kind":"string","length":8},"visibility":"public"},{"name":"min_age_required","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"max_age_required","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"service_scope","type":{"kind":"field"},"visibility":"public"},{"name":"service_subscope","type":{"kind":"field"},"visibility":"public"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{"2916126463910380353":{"error_kind":"string","string":"Age must be less than 100"},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"7Z3fbu3IfWbfpa99wfpDsiqvMhgETuIEBgw7cJwBBoHffdjusyn5kMPPapaOqr7FmwCdMFu/VVtSreLWWfyfn/7td//y3//xz7//47//6b9++qf/9T8//eFP//rbv/z+T3/c/ut/fgrT/Lf/5X/952//+PN//9dffvvnv/z0T+s8/ean3/3x3376p7Isf/3NT//++z/87qd/WuJff3O4NMS1fLs2xBreLl7++r9/s73+8smvv37y65fbr1+X1+unqR5ev37u64fpk18/3F//dX/9MB1eP37y66e7r5+W+nr9PK3vX/94cVper5vW+frSdYnp27Xrkt5dPP8ydx507nnQuZdu587TPvccD3Ovg85dBp27/si54/p63e+2ruOlZU6v3+Nlzsv3c8dp0LnDoHPHQedOg86dB517HnTuZdC510HnLoPOPeh+mQbdL9Og+2UadL9Mg+6XadD9Mg26X6ZB98s06H6ZBt0v06D7ZR50v8yD7pd50P0yD7pf5kH3yzzofpkH3S/zoPtlHnS/zIPul/Og++U86H45D7pfzoPul/Og++U86H45D7pfzoPul/Og++U86H65DLpfLoPul8ug++Uy6H65DLpfLoPul8ug++Uy6H65DLpfLoPul+ug++U66H65DrpfroPul+ug++U66H65DrpfroPul+ug++U66H5ZBt0vy6D7ZRl0vyyD7pdl0P2yDLpflkH3y/JD98ua4uvaKcTra9cwf7t2ze/+mdp6NsP6+qc+28/r+0v/RljsCas7YZ0cCMv+Dy/rciAM9oTRnjB5/RyeEGZ7wtmAME4vwvj+Vb8RLvaE/TpNCa8ZwnxnP+zXaVoR9us0bQjj1K/TfIDwYj+MU79O04qwX6dpRdiv0/yqn8MTwmxP2K/T/OOEVzt+nPp1mlaE3TpNyfv9pboexu5WVK7H7tY+anrNUJd8wz5Ct/bRjLBb+2hG2K19fITwyj5Ct/bRjDDbE3ZrH7/u5/CEsFv7aEbYrX18gPDSr0K3otKMsF+nqXvRcUrhxoYY+5WaZoj9Wk0zxH615iOIV3ti7NdrmiFmf8R+zebX/SyeIParNs0Q+3WbDyBebv2xX7lphtit3YRpzvvFa/5+8NSts6jBuzWRvxu8HvwidesXavBurSGEuA8e5nJD/n5sp+6LGLv1hoaM3YrDxxiv/C91aw4NGbtVh4aM/brDr/x5PDLmfjWjHWO/RvIRxkvPzf3KSzvGjj2n7C+83cS5sT/+2L7gFzF27DnNGDv2nI8wXu2PuWPPacbYsec0Y+zYc37dz+ORce7Yc5oxduw5H2C8dIC5Y89pxtiv52x+sjMux8HzqIP3ayTvB1/rYfB+NUMM3q87pLA/KDT9/bfKBx1w7tcd2jH26w7NGJd+3eFDjFcOuPTrDu0Y+3WHdoz9usOv/Hk8YcwAxn6N5COMl5679Csv7Rj79Zw8hf2F851/sbr06zntGPv1nGaMa7+e8yHGq/1x7ddz2jH26zntGPv1nF/583jCmAGM/XrORxgvHWDt13PaMXbsOfWVjwnzMh0G71hergfv10hqfPuJz4dvldKvZojB+3UHMXi/QiAG73eXr/P6tqsdbm//2Mxqy8H73Y/F4P1usmLwfndOMXi/O6cYvOOd83LwfnOnavCOd87rwTveOa8HH3Xn7DclqgbvdueM07Rnwafj0a3f8KcavNudUw3e7c6pBu9257wePPUb1VSDd7tzqsG73TnV4N3unGrwbndONfigO2e6n5fMab/9kd//kdzpMOHt6R5xuhGIS/ejkV80dxl07trv3BcfsqX7McgvmjsMOncc4fv7ZO406Ny527mvPmxL99OJXzT3j90v4/6EqxjX6cbv77AOOncZdO7a79xXv7/jNOjcYdC54wjf3ydzp0Hnzt3OfbnvxHnQuX/sfpnj64+eY671MMza0zDlq4aZ83QYpnY0TJq+bJh1PQwTehrmx+4WS9itecl37h6kNOjcedC5537nvrKhtAw69zro3GWE7++TueuYc+ep27kvLS6HQef+wfvl+vrririGG534lNOgc+dB5577nfvq93deBp17HXTuMsL398ncdcy556nbuS/3nTkMOveP3S/XlPe553wYJvU0TP6yYdbDdjXPPQ3zY/egMu3DlHQj453mddC5y6Bz137nvtrzl2nQucOgc8cRvr9P5k6Dzp27nfvSVZZ50Ll/8H65/11prNONHHRa1kHnLoPOXfud++r39zoNOncYdO44wvf3ydxp0Llzt3Nf7jvrPOjcP3a/rPujPuKx5pDWtadhypcNMx/+nGWtHQ1zv8+S655+nqfl/TB/e/3wya8fP/n1b//uncNeXZrfl+K/vX7+5NefP/n17//Oqent9fPh9W//GlnDHlbabs9d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","file_map":{"18":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        /*@safety: borrow is enforced to be boolean due to its type.\n            if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n            if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n        */\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            /*@safety: decomposition is properly checked below*/\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            unsafe {\n                //@safety: already unconstrained\n                field_less_than(b, a)\n            },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            //@safety: unsafe in unconstrained\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        unsafe {\n            //@safety: Take a hint of the comparison and verify it\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"19":{"source":"pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            //@safety : unconstrained context\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"26":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"62":{"source":"use commitment::nullify;\nuse compare_age::compare_age;\n\nfn main(\n    comm_in: pub Field,\n    salt: Field,\n    private_nullifier: Field,\n    dg1: [u8; 95],\n    // The current date is public so verifiers can check the date\n    // provided to the proof is correct\n    current_date: pub str<8>,\n    // The minimum age required is public so verifiers can check\n    // the age provided to the proof is correct\n    min_age_required: pub u8,\n    // The maximum age required is public so verifiers can check\n    // the age provided to the proof is correct\n    // If the maximum age is 0, it is not checked\n    max_age_required: pub u8,\n    service_scope: pub Field,\n    service_subscope: pub Field,\n) -> pub Field {\n    // Verify the age of the ID holder\n    compare_age(\n        dg1,\n        min_age_required,\n        max_age_required,\n        current_date.as_bytes(),\n    );\n    let nullifier = nullify(\n        comm_in,\n        salt,\n        dg1,\n        private_nullifier,\n        service_scope,\n        service_subscope,\n    );\n    nullifier\n}\n","path":"/Users/madztheo/Documents/Wagmi/Studio/RnD/Docaproof/Circuits/zk_id_check_circuits/src/noir/bin/compare/age/src/main.nr"},"63":{"source":"use common::{calculate_scoped_nullifier, hash_salt_dg1_private_nullifier};\n\n/*\n############################################################\n# Circuit D\n############################################################\n# Generates a scoped nullifier that is scoped by service\n# Allows selective disclosure of dg1 via a reveal bitmask\n############################################################\n\n# Inputs/Outputs\n############################################################\ncomm_in             `assert comm_in == H(salt, dg1, private_nullifier)`\nsalt\ndg1\nprivate_nullifier\nservice_scope       `H(<domain_name>)`\nservice_subscope    `H(<purpose>)` (Service-specific subscope)\nscoped_nullifier    `H(private_nullifier, service_scope, service_subscope)`\n\n# Checks\n############################################################\n- Checks that dg1_reveal is the correct reveal of dg1 for the given dg1_mask\n- Constrains scoped_nullifier to be `H(private_nullifier, service_scope, service_subscope)`\n*/\npub fn nullify(\n    comm_in: Field,\n    salt: Field,\n    dg1: [u8; 95],\n    private_nullifier: Field,\n    service_scope: Field,\n    service_subscope: Field,\n) -> Field {\n    assert(comm_in == hash_salt_dg1_private_nullifier(salt, dg1, private_nullifier));\n    // println(f\"comm_in: {comm_in}\");\n    let scoped_nullifier =\n        calculate_scoped_nullifier(private_nullifier, service_scope, service_subscope);\n    // println(f\"scoped_nullifier: {scoped_nullifier}\");\n    scoped_nullifier\n}\n\n","path":"/Users/madztheo/Documents/Wagmi/Studio/RnD/Docaproof/Circuits/zk_id_check_circuits/src/noir/lib/commitment/scoped-nullifier/src/lib.nr"},"64":{"source":"//use std::hash::pedersen_hash;\nuse std::hash::poseidon2::Poseidon2;\nuse utils::PASSPORT_MRZ_COUNTRY_INDEX;\n\npub global CSC_CERT_TYPE: Field = 1;\npub global DSC_CERT_TYPE: Field = 2;\n\npub fn calculate_scoped_nullifier(\n    private_nullifier: Field,\n    service_scope: Field,\n    service_subscope: Field,\n) -> Field {\n    Poseidon2::hash([private_nullifier, service_scope, service_subscope], 3)\n}\n\npub fn calculate_certificate_registry_leaf<let N: u32>(\n    registry_id: Field,\n    cert_type: Field,\n    country: str<3>,\n    csc_pubkey: [u8; N],\n) -> Field {\n    let country_bytes: [u8; 3] = country.as_bytes();\n    let mut result: [Field; N + 5] = [0; N + 5];\n    result[0] = registry_id as Field;\n    result[1] = cert_type as Field;\n    result[2] = country_bytes[0] as Field;\n    result[3] = country_bytes[1] as Field;\n    result[4] = country_bytes[2] as Field;\n    for i in 0..N {\n        result[i + 5] = csc_pubkey[i] as Field;\n    }\n    Poseidon2::hash(result, N + 5)\n}\n\npub fn get_country_from_dg1(dg1: [u8; 95]) -> str<3> {\n    // There 5 padding bytes in the dg1 before the actual MRZ\n    let country_offset = 5 + PASSPORT_MRZ_COUNTRY_INDEX;\n    let mut country_bytes: [u8; 3] = [0; 3];\n    for i in 0..3 {\n        country_bytes[i] = dg1[country_offset + i];\n    }\n    country_bytes.as_str_unchecked()\n}\n\npub fn hash_salt_country_tbs<let TBS_MAX_SIZE: u32>(\n    salt: Field,\n    country: str<3>,\n    tbs: [u8; TBS_MAX_SIZE],\n) -> Field {\n    let country_bytes: [u8; 3] = country.as_bytes();\n    let mut result: [Field; TBS_MAX_SIZE + 4] = [0; TBS_MAX_SIZE + 4];\n    result[0] = salt as Field;\n    result[1] = country_bytes[0] as Field;\n    result[2] = country_bytes[1] as Field;\n    result[3] = country_bytes[2] as Field;\n    for i in 0..TBS_MAX_SIZE {\n        result[4 + i] = tbs[i] as Field;\n    }\n    Poseidon2::hash(result, TBS_MAX_SIZE + 4)\n}\n\npub fn hash_salt_dg1_private_nullifier<let N: u32>(\n    salt: Field,\n    dg1: [u8; N],\n    private_nullifier: Field,\n) -> Field {\n    let mut result: [Field; N + 2] = [0; N + 2];\n    result[0] = salt as Field;\n    for i in 0..N {\n        result[1 + i] = dg1[i] as Field;\n    }\n    result[1 + N] = private_nullifier;\n    Poseidon2::hash(result, N + 2)\n}\n\npub fn calculate_private_nullifier<let DG1: u32, let SIG: u32>(\n    dg1: [u8; DG1],\n    sod_sig: [u8; SIG],\n) -> Field {\n    let mut result: [Field; DG1 + SIG] = [0; DG1 + SIG];\n    for i in 0..DG1 {\n        result[i] = dg1[i] as Field;\n    }\n    for i in 0..SIG {\n        result[DG1 + i] = sod_sig[i] as Field;\n    }\n    Poseidon2::hash(result, DG1 + SIG)\n}\n\npub fn hash_salt_country_signed_attr_dg1_private_nullifier<let SA: u32>(\n    salt: Field,\n    country: str<3>,\n    signed_attr: [u8; SA],\n    signed_attr_size: Field,\n    dg1: [u8; 95],\n    private_nullifier: Field,\n) -> Field {\n    let country_bytes: [u8; 3] = country.as_bytes();\n    let mut result: [Field; SA + 101] = [0; SA + 101];\n    result[0] = salt as Field;\n    result[1] = country_bytes[0] as Field;\n    result[2] = country_bytes[1] as Field;\n    result[3] = country_bytes[2] as Field;\n    for i in 0..SA {\n        result[4 + i] = signed_attr[i] as Field;\n    }\n    result[4 + SA] = signed_attr_size;\n    for i in 0..95 {\n        result[4 + SA + 1 + i] = dg1[i] as Field;\n    }\n    result[4 + SA + 1 + 95] = private_nullifier;\n    Poseidon2::hash(result, SA + 101)\n}\n","path":"/Users/madztheo/Documents/Wagmi/Studio/RnD/Docaproof/Circuits/zk_id_check_circuits/src/noir/lib/commitment/common/src/lib.nr"},"65":{"source":"/**\n* The standards for passports and any other travel documents, electronic or not,\n* are defined in the ICAO (International Civil Aviation Organization) 9303 document available here:\n* https://www.icao.int/publications/pages/publication.aspx?docnum=9303\n*/\n\n/**\n* The structure of the MRZ is well defined and standardized by the ICAO\n* so the index will always be the same for every passport\n* c.f. ICAO 9303-4, Appendix B\n*/\n\n// The following constants define the indices of the information\n// we need to generate various proofs of identity from the MRZ\n// The structure of the MRZ is slightly different between passports\n// and ID cards so we need to define indices for both types\n\n// Index for the country of issuance of the passport\npub global PASSPORT_MRZ_COUNTRY_INDEX: u32 = 2;\n// Index for the three letter code of the country of citizenship\n// Note that the first three letter code (index 2) in the MRZ is the country of issuance\n// not citizenship. It is important to keep in mind for residence permits\n// where the issuing country differs from the citizenship country\npub global PASSPORT_MRZ_NATIONALITY_INDEX: u32 = 54;\n// Index for the gender of the passport holder (M, F or < if unspecified)\npub global PASSPORT_MRZ_GENDER_INDEX: u32 = 64;\n// Index for the date of expiry (YYMMDD)\npub global PASSPORT_MRZ_EXPIRY_DATE_INDEX: u32 = 65;\n// Index for the date of birth (YYMMDD) in TD1 (i.e. passport) MRZ\npub global PASSPORT_MRZ_BIRTHDATE_INDEX: u32 = 57;\n// Index for the document number in the MRZ\npub global PASSPORT_MRZ_DOCUMENT_NUMBER_INDEX: u32 = 44;\n// Index for the document type in the MRZ\npub global PASSPORT_MRZ_DOCUMENT_TYPE_INDEX: u32 = 0;\n// Index for the name of the passport holder\npub global PASSPORT_MRZ_NAME_INDEX: u32 = 5;\n// Length of the MRZ on a passport\npub global PASSPORT_MRZ_LENGTH: u32 = 88;\n\n// Index for the country of issuance of the ID card\npub global ID_CARD_MRZ_COUNTRY_INDEX: u32 = 2;\n// Note that the first three letter code (index 2) in the MRZ is the country of issuance\n// not citizenship. It is important to keep in mind for residence permits\n// where the issuing country differs from the citizenship country\npub global ID_CARD_MRZ_NATIONALITY_INDEX: u32 = 45;\n// Index for the gender of the passport holder (M, F or < if unspecified)\npub global ID_CARD_MRZ_GENDER_INDEX: u32 = 37;\n// Index for the date of expiry (YYMMDD)\npub global ID_CARD_MRZ_EXPIRY_DATE_INDEX: u32 = 38;\n// Index for the date of birth (YYMMDD) in TD3 (i.e. ID cards) MRZ\npub global ID_CARD_MRZ_BIRTHDATE_INDEX: u32 = 30;\n// Index for the document number in the MRZ\npub global ID_CARD_MRZ_DOCUMENT_NUMBER_INDEX: u32 = 5;\n// Index for the document type in the MRZ\npub global ID_CARD_MRZ_DOCUMENT_TYPE_INDEX: u32 = 0;\n// Index for the name of the passport holder\npub global ID_CARD_MRZ_NAME_INDEX: u32 = 60;\n// Length of the MRZ on an ID card\npub global ID_CARD_MRZ_LENGTH: u32 = 90;\n\n// ECDSA curves mapping\npub global ECDSA_CURVE_P256: u32 = 0;\npub global ECDSA_CURVE_P384: u32 = 1;\npub global ECDSA_CURVE_P521: u32 = 2;\npub global ECDSA_CURVE_BRAINPOOL_B256R1: u32 = 3;\npub global ECDSA_CURVE_BRAINPOOL_B256T1: u32 = 4;\npub global ECDSA_CURVE_BRAINPOOL_B384R1: u32 = 5;\npub global ECDSA_CURVE_BRAINPOOL_B384T1: u32 = 6;\npub global ECDSA_CURVE_BRAINPOOL_B512R1: u32 = 7;\npub global ECDSA_CURVE_BRAINPOOL_B512T1: u32 = 8;\n\npub struct IDData {\n    // Regroups the hashes of all the data groups plus some padding\n    // at the start and in between each data group hashes\n    pub e_content: [u8; 700],\n    pub e_content_size: u32,\n    // Where we can find e_content in the signed_attributes\n    // It varies from document to document according to the length\n    // of the padding at the start\n    pub dg1_offset_in_e_content: u32,\n    // Last 32 bytes: result of the hash of all the hashes of the data groups\n    // Rest of the bytes: information about the signature algorithm, date, etc.\n    pub signed_attributes: [u8; 200],\n    pub signed_attributes_size: u32,\n    // The DG1 contains the Machine Readable Zone (MRZ) of the document\n    // The two lines at the bottom of the passport data page\n    // or the three bottom lines on the rear of an ID card\n    // 95 bytes for passports, 93 bytes for ID cards\n    // Including 88 bytes of MRZ and 5 bytes of padding for passports\n    // and 90 bytes of MRZ and 5 bytes of padding for ID cards\n    pub dg1: [u8; 95],\n    // The signature over the data groups\n    pub sod_signature: [u8; 512],\n    pub sod_signature_size: u32,\n}\n\npub struct DSCData {\n    // The TBS certificate of the DSC\n    // TBS stands for To Be Signed\n    pub tbs_certificate: [u8; 1500],\n    pub tbs_certificate_size: u32,\n    // The public key of the DSC (up to 512 bytes to account for RSA-4096)\n    pub pubkey: [u8; 512],\n    // The actual size of the public key\n    pub pubkey_size: u32,\n    // The index of the public key in the TBS certificate\n    pub pubkey_index: u32,\n    // Data used to verify the signature\n    // Generated by the pre-compute function in Rust\n    // c.f. main.rs\n    pub pubkey_redc_param: [u8; 513],\n    // The signature over the TBS certificate\n    pub signature: [u8; 512],\n    pub signature_size: u32,\n    // The exponent of the public key\n    // Only useful for RSA, can be ignored for ECDSA\n    pub exponent: u32,\n}\n\npub struct CSCData {\n    // The public key of the CSC (up to 512 bytes to account for RSA-4096)\n    pub pubkey: [u8; 512],\n    // The actual size of the public key\n    pub pubkey_size: u32,\n    // Data used to verify the signature\n    // Generated by the pre-compute function in Rust\n    // c.f. main.rs\n    pub pubkey_redc_param: [u8; 513],\n    // Only useful for RSA, can be ignored for ECDSA\n    pub exponent: u32,\n}\n\npub struct DiscloseFlags {\n    pub issuing_country: bool,\n    pub nationality: bool,\n    pub document_type: bool,\n    pub document_number: bool,\n    pub date_of_expiry: bool,\n    pub date_of_birth: bool,\n    pub gender: bool,\n    pub name: bool,\n}\n\npub struct DisclosedData {\n    pub issuing_country: [u8; 3],\n    pub nationality: [u8; 3],\n    pub document_type: [u8; 2],\n    pub document_number: [u8; 9],\n    pub date_of_expiry: [u8; 6],\n    pub date_of_birth: [u8; 6],\n    pub name: [u8; 39],\n    pub gender: [u8; 1],\n}\n\npub fn get_array_slice<let N: u32, let M: u32>(arr: [u8; N], start: u32, end: u32) -> [u8; M] {\n    let mut slice = [0 as u8; M];\n    for i in start..end {\n        slice[i - start] = arr[i];\n    }\n    slice\n}\n\npub fn get_array_slice_constant<let N: u32, let M: u32>(arr: [u8; N]) -> [u8; M] {\n    let mut slice = [0 as u8; M];\n    for i in 0..M {\n        slice[i] = arr[i];\n    }\n    slice\n}\n\n// Reverse the bytes of an array so you can switch from\n// big endian to little endian order and vice versa\npub fn reverse_bytes_array<let N: u32>(arr: [u8; N]) -> [u8; N] {\n    let mut reversed_arr = [0 as u8; N];\n    for i in 0..N {\n        // Reverse\n        reversed_arr[i] = arr[N - 1 - i];\n    }\n    reversed_arr\n}\n\npub fn insert_into_array<let N: u32, let M: u32>(\n    mut arr: [u8; N],\n    sub_arr: [u8; M],\n    index: u32,\n) -> [u8; N] {\n    for i in index..index + M {\n        arr[i] = sub_arr[i - index];\n    }\n    arr\n}\n\npub fn dynamic_insert_into_array<let N: u32, let M: u32>(\n    mut arr: [u8; N],\n    sub_arr: [u8; M],\n    index: u32,\n    max_size: u32,\n) -> [u8; N] {\n    for i in index..index + max_size {\n        if i - index < M {\n            arr[i] = sub_arr[i - index];\n        }\n    }\n    arr\n}\n\npub fn is_id_card(dg1: [u8; 95]) -> bool {\n    // For passport, the last two bytes are 0\n    // since the real length is 93 for passports\n    // while it is 95 for ID cards\n    (dg1[93] != 0) & (dg1[94] != 0)\n}\n\npub fn from_byte_be_to_fields<let NBytes: u32, let N: u32>(x: [u8; NBytes]) -> [Field; N] {\n    let mut result = [0 as Field; N];\n\n    let mut limb: Field = 0;\n    let mut k = 0;\n    for _j in 0..(15 - (N * 15 - NBytes)) {\n        limb *= 256;\n        limb += x[k] as Field;\n        k += 1;\n    }\n    std::as_witness(limb);\n\n    result[N - 1] = limb;\n\n    for i in 1..N {\n        let mut limb: Field = 0;\n        for _j in 0..15 {\n            limb *= 256;\n            limb += x[k] as Field;\n            k += 1;\n        }\n        std::as_witness(limb);\n        result[N - i - 1] = limb;\n    }\n\n    result\n}\n\npub unconstrained fn __from_byte_be_to_fields<let NBytes: u32, let N: u32>(\n    x: [u8; NBytes],\n) -> [Field; N] {\n    from_byte_be_to_fields(x)\n}\n\npub fn get_mrz_from_dg1(dg1: [u8; 95]) -> [u8; 90] {\n    let mut mrz = [0 as u8; 90];\n    for i in 0..90 {\n        mrz[i] = dg1[i + 5];\n    }\n    mrz\n}\n\npub fn split_array<let N: u32>(array: [u8; N * 2]) -> ([u8; N], [u8; N]) {\n    let mut array_x = [0 as u8; N];\n    let mut array_y = [0 as u8; N];\n    for i in 0..N {\n        array_x[i] = array[i];\n        array_y[i] = array[i + N];\n    }\n    (array_x, array_y)\n}\n\npub fn concat_array<let N: u32>(array_x: [u8; N], array_y: [u8; N]) -> [u8; N * 2] {\n    let mut array = [0 as u8; N * 2];\n    for i in 0..N {\n        array[i] = array_x[i];\n        array[i + N] = array_y[i];\n    }\n    array\n}\n\npub fn check_zero_padding<let N: u32, T>(padded_array: [T; N], len: u32)\nwhere\n    T: Eq,\n    T: Default,\n{\n    for i in 0..N {\n        if i >= len {\n            assert_eq(padded_array[i], T::default());\n        }\n    }\n}\n\npub fn get_nationality_from_mrz(dg1: [u8; 95]) -> [u8; 3] {\n    let mrz = get_mrz_from_dg1(dg1);\n\n    let mut country_bytes: [u8; 3] = [0; 3];\n\n    if is_id_card(dg1) {\n        country_bytes = get_array_slice(\n            mrz,\n            ID_CARD_MRZ_NATIONALITY_INDEX,\n            ID_CARD_MRZ_NATIONALITY_INDEX + 3,\n        );\n    } else {\n        country_bytes = get_array_slice(\n            mrz,\n            PASSPORT_MRZ_NATIONALITY_INDEX,\n            PASSPORT_MRZ_NATIONALITY_INDEX + 3,\n        );\n    }\n\n    country_bytes\n}\n","path":"/Users/madztheo/Documents/Wagmi/Studio/RnD/Docaproof/Circuits/zk_id_check_circuits/src/noir/lib/utils/src/lib.nr"},"66":{"source":"use date::Date;\nuse utils::{\n    get_array_slice, get_mrz_from_dg1, ID_CARD_MRZ_BIRTHDATE_INDEX, is_id_card,\n    PASSPORT_MRZ_BIRTHDATE_INDEX,\n};\n\nfn get_birthdate(dg1: [u8; 95], current_date: [u8; 8]) -> Date {\n    let mut birthdate_bytes = [0 as u8; 6];\n    let mrz = get_mrz_from_dg1(dg1);\n\n    // Get the slice of the MRZ representing the birthdate\n    if is_id_card(dg1) {\n        birthdate_bytes = get_array_slice(\n            mrz,\n            ID_CARD_MRZ_BIRTHDATE_INDEX,\n            ID_CARD_MRZ_BIRTHDATE_INDEX + 6,\n        );\n    } else {\n        // Otherwise it's an ID card\n        birthdate_bytes = get_array_slice(\n            mrz,\n            PASSPORT_MRZ_BIRTHDATE_INDEX,\n            PASSPORT_MRZ_BIRTHDATE_INDEX + 6,\n        );\n    }\n\n    // Create a Date object from the birthdate using the current date as\n    // the pivot year to differentiate between 20th and 21st centuries\n    // as the format is \"YYMMDD\"\n    Date::from_bytes_short_year(birthdate_bytes, [current_date[2], current_date[3]])\n}\n\npub fn compare_age(dg1: [u8; 95], min_age: u8, max_age: u8, current_date_bytes: [u8; 8]) {\n    // Restrict the age to be less than 100 as the dg1 birthdate only encodes\n    // two digits for the year\n    // TODO: Add support for dg11 to support 100+\n    assert((max_age < 100) & (min_age < 100), \"Age must be less than 100\");\n\n    let birthdate: Date = get_birthdate(dg1, current_date_bytes);\n\n    let current_date = Date::from_bytes_long_year(current_date_bytes);\n\n    assert((min_age != 0) | (max_age != 0));\n\n    if (min_age != 0) & (max_age == 0) {\n        // Check if age is above min age\n        // The minimum age is more likely to be inclusive, so we use gte\n        assert(current_date.gte(birthdate.add_years(min_age as u32)));\n    } else if (max_age != 0) & (min_age == 0) {\n        // Check if age is below max age\n        // The maximum age is more likely to be exclusive, so we use lt\n        assert(current_date.lt(birthdate.add_years(max_age as u32)));\n    } else {\n        assert(min_age <= max_age);\n\n        assert(current_date.gte(birthdate.add_years(min_age as u32)));\n        // This way if max_age = min_age, the proof will be valid whenever the age\n        // is equal to min_age = max_age\n        assert(current_date.lt(birthdate.add_years((max_age + 1) as u32)));\n    }\n}\n","path":"/Users/madztheo/Documents/Wagmi/Studio/RnD/Docaproof/Circuits/zk_id_check_circuits/src/noir/lib/compare/age/src/lib.nr"},"67":{"source":"use dep::std::{field::bn254::assert_gt, println};\n\npub struct Date {\n    day: u8,\n    month: u8,\n    year: u32,\n}\n\nfn get_number_from_utf8_code(code: u8) -> u8 {\n    assert(code >= 48 & code <= 57);\n    code - 48\n}\n\nfn number_to_utf8_code(number: u8) -> u8 {\n    assert(number >= 0 & number <= 9);\n    number + 48\n}\n\nimpl Date {\n    pub fn new(year: u32, month: u8, day: u8) -> Self {\n        assert(month >= 1 & month <= 12);\n        assert(day >= 1 & day <= 31);\n        let date = Self { day: day, month: month, year: year };\n        assert(day <= date.get_days_in_month(month));\n        date\n    }\n\n    pub fn from_bytes_short_year(date: [u8; 6], threshold_year: [u8; 2]) -> Self {\n        let firstYearDigit = get_number_from_utf8_code(date[0]);\n        let secondYearDigit = get_number_from_utf8_code(date[1]);\n\n        let mut year: u32 = firstYearDigit as u32 * 10 + secondYearDigit as u32;\n\n        let firstMonthDigit = get_number_from_utf8_code(date[2]);\n        let secondMonthDigit = get_number_from_utf8_code(date[3]);\n\n        let month = firstMonthDigit * 10 + secondMonthDigit;\n\n        let firstDayDigit = get_number_from_utf8_code(date[4]);\n        let secondDayDigit = get_number_from_utf8_code(date[5]);\n\n        let day = firstDayDigit * 10 + secondDayDigit;\n\n        let currentYearFirstDigit = get_number_from_utf8_code(threshold_year[0]);\n        let currentYearSecondDigit = get_number_from_utf8_code(threshold_year[1]);\n\n        let mut currentYear: u32 =\n            currentYearFirstDigit as u32 * 10 + currentYearSecondDigit as u32;\n\n        // This way we have a smooth 100 years period according to a threshold year\n        // Taking the current year as threshold year (for birthdates for example)\n        // if the current year is 2023, then 24 will be interpreted as 1924\n        // while 22 will be interpreted as 2022\n        // A bit problematic for people over 100 years old\n        if year <= currentYear {\n            year += 2000;\n        } else {\n            year += 1900;\n        }\n\n        Self { day: day, month: month, year: year }\n    }\n\n    pub fn from_bytes_long_year(date: [u8; 8]) -> Self {\n        let firstYearDigit = get_number_from_utf8_code(date[0]);\n        let secondYearDigit = get_number_from_utf8_code(date[1]);\n        let thirdYearDigit = get_number_from_utf8_code(date[2]);\n        let fourthYearDigit = get_number_from_utf8_code(date[3]);\n\n        let year: u32 = firstYearDigit as u32 * 1000\n            + secondYearDigit as u32 * 100\n            + thirdYearDigit as u32 * 10\n            + fourthYearDigit as u32;\n\n        let firstMonthDigit = get_number_from_utf8_code(date[4]);\n        let secondMonthDigit = get_number_from_utf8_code(date[5]);\n\n        let month = firstMonthDigit * 10 + secondMonthDigit;\n\n        let firstDayDigit = get_number_from_utf8_code(date[6]);\n        let secondDayDigit = get_number_from_utf8_code(date[7]);\n\n        let day = firstDayDigit * 10 + secondDayDigit;\n\n        Self { day: day, month: month, year: year }\n    }\n\n    pub fn from_str_short_year(date: str<6>, threshold_year: str<2>) -> Self {\n        let date_bytes = date.as_bytes();\n        Date::from_bytes_short_year(date_bytes, threshold_year.as_bytes())\n    }\n\n    pub fn from_str_long_year(date: str<8>) -> Self {\n        let date_bytes = date.as_bytes();\n        Date::from_bytes_long_year(date_bytes)\n    }\n\n    pub fn get_duration_in_days(self: Self, other: Self, absolute: bool) -> i32 {\n        let totalDuration: i32 = self.get_duration_between_years(other) as i32\n            + self.get_duration_between_months(other) as i32\n            + (self.day as i32 - other.day as i32);\n\n        if (totalDuration < 0) & absolute {\n            -1 * totalDuration\n        }\n\n        totalDuration\n    }\n\n    pub fn gt(self: Self, other: Self) -> bool {\n        self.get_duration_in_days(other, false) > 0\n    }\n\n    pub fn lt(self: Self, other: Self) -> bool {\n        self.get_duration_in_days(other, false) < 0\n    }\n\n    pub fn eq(self: Self, other: Self) -> bool {\n        (self.day == other.day) & (self.month == other.month) & (self.year == other.year)\n    }\n\n    pub fn ne(self: Self, other: Self) -> bool {\n        !self.eq(other)\n    }\n\n    pub fn gte(self: Self, other: Self) -> bool {\n        self.get_duration_in_days(other, false) >= 0\n    }\n\n    pub fn lte(self: Self, other: Self) -> bool {\n        self.get_duration_in_days(other, false) <= 0\n    }\n\n    pub fn println(self: Self) {\n        let year = self.year;\n        let month = self.month;\n        let day = self.day;\n        // Let's write the date in the YYYY-MM-DD format\n        // since people don't agree on which format is best\n        // between MM/DD/YYYY and DD/MM/YYYY\n        if (month < 10) & (day < 10) {\n            println(f\"Date: {year}-0{month}-0{day}\");\n        } else if month < 10 {\n            println(f\"Date: {year}-0{month}-{day}\");\n        } else if day < 10 {\n            println(f\"Date: {year}-{month}-0{day}\");\n        } else {\n            println(f\"Date: {year}-{month}-{day}\");\n        }\n    }\n\n    pub fn to_bytes(self: Self) -> [u8; 8] {\n        let mut date: [u8; 8] = [0; 8];\n\n        let firstYearDigit = self.year / 1000;\n        let secondYearDigit = (self.year - firstYearDigit * 1000) / 100;\n        let thirdYearDigit = (self.year - firstYearDigit * 1000 - secondYearDigit * 100) / 10;\n        let fourthYearDigit =\n            self.year - firstYearDigit * 1000 - secondYearDigit * 100 - thirdYearDigit * 10;\n\n        date[0] = number_to_utf8_code(firstYearDigit as u8);\n        date[1] = number_to_utf8_code(secondYearDigit as u8);\n        date[2] = number_to_utf8_code(thirdYearDigit as u8);\n        date[3] = number_to_utf8_code(fourthYearDigit as u8);\n\n        let firstMonthDigit = self.month / 10;\n        let secondMonthDigit = self.month - firstMonthDigit * 10;\n\n        date[4] = number_to_utf8_code(firstMonthDigit as u8);\n        date[5] = number_to_utf8_code(secondMonthDigit as u8);\n\n        let firstDayDigit = self.day / 10;\n        let secondDayDigit = self.day - firstDayDigit * 10;\n\n        date[6] = number_to_utf8_code(firstDayDigit as u8);\n        date[7] = number_to_utf8_code(secondDayDigit as u8);\n\n        date\n    }\n\n    pub fn is_leap_year(self: Self) -> bool {\n        self.year % 4 == 0\n    }\n\n    pub fn get_days_in_month(self: Self, month: u8) -> u8 {\n        assert(month >= 1 & month <= 12);\n        if month == 2 {\n            if self.is_leap_year() {\n                29\n            } else {\n                28\n            }\n        } else {\n            if (month == 1)\n                | (month == 3)\n                | (month == 5)\n                | (month == 7)\n                | (month == 8)\n                | (month == 10)\n                | (month == 12) {\n                31\n            } else {\n                30\n            }\n        }\n    }\n\n    pub fn get_duration_between_months(self: Self, other: Self) -> i32 {\n        assert(self.month >= 1 & self.month <= 12);\n        assert(other.month >= 1 & other.month <= 12);\n        let mut duration: i32 = 0;\n        if (self.month < other.month) {\n            for month in 1..13 {\n                if month >= self.month & month < other.month {\n                    duration -= other.get_days_in_month(month) as i32;\n                }\n            }\n        } else {\n            for month in 1..13 {\n                if month >= other.month & month < self.month {\n                    duration += self.get_days_in_month(month) as i32;\n                }\n            }\n        }\n        duration\n    }\n\n    pub fn get_duration_between_years(self: Self, other: Self) -> i32 {\n        let mut duration: i32 = 0;\n        if (self.year < other.year) {\n            let previous_leap_year: u32 = other.year - (other.year % 4);\n            let mut leap_year_count: u32 = 0;\n            if self.year <= previous_leap_year {\n                leap_year_count = (previous_leap_year - self.year) / 4 + 1;\n            }\n            duration -= leap_year_count as i32 * 366;\n            duration -=\n                (other.year as i32 - self.year as i32 - leap_year_count as i32) as i32 * 365;\n        } else if (self.year > other.year) {\n            let next_leap_year: u32 = other.year + (4 - other.year % 4);\n            let mut leap_year_count: u32 = 0;\n            if self.year > next_leap_year {\n                // Fixes a weird bug where the line below triggers a fail constraint\n                // while self.year is greater than next_leap_year\n                assert_gt(self.year as Field, next_leap_year as Field);\n                leap_year_count = ((self.year - 1) - next_leap_year) / 4 + 1;\n            }\n            duration += leap_year_count as i32 * 366;\n            duration +=\n                (self.year as i32 - other.year as i32 - leap_year_count as i32) as i32 * 365;\n        }\n        duration\n    }\n\n    pub fn add_years(self: Self, years: u32) -> Self {\n        Self { day: self.day, month: self.month, year: self.year + years }\n    }\n\n    pub fn sub_years(self: Self, years: u32) -> Self {\n        Self { day: self.day, month: self.month, year: self.year - years }\n    }\n\n    pub fn add_months(self: Self, months: u32) -> Self {\n        let mut newMonth = self.month as u32 + months;\n        let mut newYear = self.year;\n        let yearToAdd = (newMonth - 1) / 12;\n        if newMonth > 12 {\n            newYear += yearToAdd as u32;\n            newMonth -= 12 * yearToAdd;\n        }\n        Self { day: self.day, month: newMonth as u8, year: newYear }\n    }\n\n    pub fn sub_months(self: Self, months: u32) -> Self {\n        let mut newMonth = self.month as i32 - months as i32;\n        let mut newYear = self.year;\n        if newMonth < 1 {\n            let yearToSub = ((newMonth as i32 - 12 as i32) * -1) / 12;\n            newYear -= yearToSub as u32;\n            newMonth += 12 * yearToSub;\n        }\n        Self { day: self.day, month: newMonth as u8, year: newYear }\n    }\n\n    pub fn add_days(self: Self, days: u32) -> Self {\n        let mut newDay = self.day as u32 + days;\n        let mut newMonth = self.month as u32;\n        let mut newYear = self.year;\n        let mut date = Self { day: newDay as u8, month: newMonth as u8, year: newYear };\n        if newDay > self.get_days_in_month(self.month) as u32 {\n            let max_months = (newDay / 30) + 1;\n            let bound = self.month + max_months as u8;\n            for _ in self.month..bound {\n                let days_in_month = date.get_days_in_month(newMonth as u8) as u32;\n                if newDay > days_in_month {\n                    newDay -= days_in_month;\n                    newMonth += 1;\n                    if newMonth > 12 {\n                        newYear += 1;\n                        newMonth = 1;\n                    }\n                    // We need to mutate the date object inside the loop\n                    // so we can use get_days_in_month properly\n                    date.day = newDay as u8;\n                    date.year = newYear;\n                    date.month = newMonth as u8;\n                }\n            }\n        }\n        date\n    }\n\n    // Performance could be improved\n    pub fn sub_days(self: Self, days: u32) -> Self {\n        let mut newDay = self.day as i32 - days as i32;\n        let mut newMonth = self.month as i32;\n        let mut newYear = self.year;\n        let mut date = Self { day: newDay as u8, month: newMonth as u8, year: newYear };\n        if newDay < 1 {\n            let max_months = (self.day as u32 + days) / 30 + 1;\n            let bound = self.month + max_months as u8;\n            for _ in self.month..bound {\n                let days_in_month = date.get_days_in_month(newMonth as u8) as i32;\n                if newDay < 1 {\n                    newDay += days_in_month;\n                    newMonth -= 1;\n                    if newMonth < 1 {\n                        newYear -= 1;\n                        newMonth = 12;\n                    }\n                    // We need to mutate the date object inside the loop\n                    // so we can use get_days_in_month properly\n                    date.day = newDay as u8;\n                    date.year = newYear;\n                    date.month = newMonth as u8;\n                }\n            }\n        }\n        date\n    }\n}\n\n#[test]\nfn test_date_init() {\n    let date = Date::new(2023, 12, 19);\n\n    assert(date.day == 19);\n    assert(date.month == 12);\n    assert(date.year == 2023);\n}\n\n#[test]\nfn test_date_from_bytes_short_year() {\n    let date = Date::from_bytes_short_year([50, 51, 49, 50, 49, 57], [50, 52]);\n\n    assert(date.day == 19);\n    assert(date.month == 12);\n    assert(date.year == 2023);\n}\n\n#[test]\nfn test_date_from_bytes_long_year() {\n    let date = Date::from_bytes_long_year([50, 48, 50, 51, 49, 50, 49, 57]);\n\n    assert(date.day == 19);\n    assert(date.month == 12);\n    assert(date.year == 2023);\n}\n\n#[test]\nfn test_date_from_str_short_year() {\n    let date = Date::from_str_short_year(\"231219\", \"24\");\n\n    assert(date.day == 19);\n    assert(date.month == 12);\n    assert(date.year == 2023);\n}\n\n#[test]\nfn test_date_from_str_long_year() {\n    let date = Date::from_str_long_year(\"20231219\");\n\n    assert(date.day == 19);\n    assert(date.month == 12);\n    assert(date.year == 2023);\n}\n\n#[test]\nfn test_date_to_bytes() {\n    let date = Date::new(2023, 12, 19);\n\n    let date_bytes = date.to_bytes();\n\n    assert(date_bytes[0] == 50);\n    assert(date_bytes[1] == 48);\n    assert(date_bytes[2] == 50);\n    assert(date_bytes[3] == 51);\n    assert(date_bytes[4] == 49);\n    assert(date_bytes[5] == 50);\n    assert(date_bytes[6] == 49);\n    assert(date_bytes[7] == 57);\n}\n\n#[test]\nfn test_date_is_leap_year() {\n    let date = Date::new(2023, 12, 19);\n\n    assert(date.is_leap_year() == false);\n\n    let date = Date::new(2024, 12, 19);\n\n    assert(date.is_leap_year() == true);\n}\n\n#[test]\nfn test_date_get_days_in_month() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(date.get_days_in_month(1) == 31);\n    assert(date.get_days_in_month(2) == 28);\n    assert(date.get_days_in_month(3) == 31);\n    assert(date.get_days_in_month(4) == 30);\n    assert(date.get_days_in_month(5) == 31);\n    assert(date.get_days_in_month(6) == 30);\n    assert(date.get_days_in_month(7) == 31);\n    assert(date.get_days_in_month(8) == 31);\n    assert(date.get_days_in_month(9) == 30);\n    assert(date.get_days_in_month(10) == 31);\n    assert(date.get_days_in_month(11) == 30);\n    assert(date.get_days_in_month(12) == 31);\n\n    let date = Date::new(2024, 1, 1);\n\n    assert(date.get_days_in_month(1) == 31);\n    assert(date.get_days_in_month(2) == 29);\n    assert(date.get_days_in_month(3) == 31);\n    assert(date.get_days_in_month(4) == 30);\n    assert(date.get_days_in_month(5) == 31);\n    assert(date.get_days_in_month(6) == 30);\n    assert(date.get_days_in_month(7) == 31);\n    assert(date.get_days_in_month(8) == 31);\n    assert(date.get_days_in_month(9) == 30);\n    assert(date.get_days_in_month(10) == 31);\n    assert(date.get_days_in_month(11) == 30);\n    assert(date.get_days_in_month(12) == 31);\n}\n\n#[test]\nfn test_date_get_duration_between_months() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(Date::new(2023, 1, 1).get_duration_between_months(date) == 0);\n    assert(Date::new(2023, 2, 1).get_duration_between_months(date) == 31);\n    assert(Date::new(2023, 3, 1).get_duration_between_months(date) == 59);\n    assert(Date::new(2023, 4, 1).get_duration_between_months(date) == 90);\n    assert(Date::new(2023, 5, 1).get_duration_between_months(date) == 120);\n    assert(Date::new(2023, 6, 1).get_duration_between_months(date) == 151);\n    assert(Date::new(2023, 7, 1).get_duration_between_months(date) == 181);\n    assert(Date::new(2023, 8, 1).get_duration_between_months(date) == 212);\n    assert(Date::new(2023, 9, 1).get_duration_between_months(date) == 243);\n    assert(Date::new(2023, 10, 1).get_duration_between_months(date) == 273);\n    assert(Date::new(2023, 11, 1).get_duration_between_months(date) == 304);\n    assert(Date::new(2023, 12, 1).get_duration_between_months(date) == 334);\n}\n\n#[test]\nfn test_date_get_duration_between_years() {\n    let date = Date::new(2023, 1, 1);\n\n    // Positive duration\n    assert(Date::new(2023, 1, 1).get_duration_between_years(date) == 0);\n    assert(Date::new(2024, 1, 1).get_duration_between_years(date) == 365);\n    assert(Date::new(2025, 1, 1).get_duration_between_years(date) == 731);\n    assert(Date::new(2026, 1, 1).get_duration_between_years(date) == 1096);\n    assert(Date::new(2027, 1, 1).get_duration_between_years(date) == 1461);\n    assert(Date::new(2028, 1, 1).get_duration_between_years(date) == 1826);\n    assert(Date::new(2029, 1, 1).get_duration_between_years(date) == 2192);\n    assert(Date::new(2030, 1, 1).get_duration_between_years(date) == 2557);\n    assert(Date::new(2031, 1, 1).get_duration_between_years(date) == 2922);\n    assert(Date::new(2032, 1, 1).get_duration_between_years(date) == 3287);\n    assert(Date::new(2033, 1, 1).get_duration_between_years(date) == 3653);\n    assert(Date::new(2034, 1, 1).get_duration_between_years(date) == 4018);\n\n    // Negative duration\n    assert(Date::new(2022, 1, 1).get_duration_between_years(date) == -365);\n    assert(Date::new(2021, 1, 1).get_duration_between_years(date) == -730);\n    assert(Date::new(2020, 1, 1).get_duration_between_years(date) == -1096);\n    assert(Date::new(2019, 1, 1).get_duration_between_years(date) == -1461);\n    assert(Date::new(2018, 1, 1).get_duration_between_years(date) == -1826);\n    assert(Date::new(2017, 1, 1).get_duration_between_years(date) == -2191);\n    assert(Date::new(2016, 1, 1).get_duration_between_years(date) == -2557);\n    assert(Date::new(2015, 1, 1).get_duration_between_years(date) == -2922);\n    assert(Date::new(2014, 1, 1).get_duration_between_years(date) == -3287);\n    assert(Date::new(2013, 1, 1).get_duration_between_years(date) == -3652);\n    assert(Date::new(2012, 1, 1).get_duration_between_years(date) == -4018);\n}\n\n#[test]\nfn test_date_get_duration_in_days() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(Date::new(2023, 1, 1).get_duration_in_days(date, false) == 0);\n    assert(Date::new(2023, 1, 15).get_duration_in_days(date, false) == 14);\n    assert(Date::new(2023, 2, 1).get_duration_in_days(date, false) == 31);\n    assert(Date::new(2023, 2, 15).get_duration_in_days(date, false) == 45);\n    assert(Date::new(2023, 3, 1).get_duration_in_days(date, false) == 59);\n    assert(Date::new(2023, 12, 31).get_duration_in_days(date, false) == 364);\n    assert(Date::new(2024, 1, 1).get_duration_in_days(date, false) == 365);\n    assert(Date::new(2024, 12, 31).get_duration_in_days(date, false) == 365 + 365);\n    assert(Date::new(2025, 1, 1).get_duration_in_days(date, false) == 365 + 366);\n}\n\n#[test]\nfn test_date_eq() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(date.eq(Date::new(2023, 1, 1)));\n    assert(!date.eq(Date::new(2023, 1, 2)));\n}\n\n#[test]\nfn test_date_ne() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(!date.ne(Date::new(2023, 1, 1)));\n    assert(date.ne(Date::new(2023, 1, 2)));\n}\n\n#[test]\nfn test_date_gt() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(!date.gt(Date::new(2023, 1, 1)));\n    assert(!date.gt(Date::new(2023, 1, 2)));\n    assert(date.gt(Date::new(2022, 12, 31)));\n}\n\n#[test]\nfn test_date_lt() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(!date.lt(Date::new(2023, 1, 1)));\n    assert(!date.lt(Date::new(2022, 12, 31)));\n    assert(date.lt(Date::new(2023, 1, 2)));\n}\n\n#[test]\nfn test_date_gte() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(date.gte(Date::new(2023, 1, 1)));\n    assert(!date.gte(Date::new(2023, 1, 2)));\n    assert(date.gte(Date::new(2022, 12, 31)));\n}\n\n#[test]\nfn test_date_lte() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(date.lte(Date::new(2023, 1, 1)));\n    assert(!date.lte(Date::new(2022, 12, 31)));\n    assert(date.lte(Date::new(2023, 1, 2)));\n}\n\n#[test]\nfn test_date_add_years() {\n    let date = Date::new(2023, 7, 14);\n\n    assert(date.add_years(0).eq(Date::new(2023, 7, 14)));\n    assert(date.add_years(1).eq(Date::new(2024, 7, 14)));\n    assert(date.add_years(2).eq(Date::new(2025, 7, 14)));\n    assert(date.add_years(3).eq(Date::new(2026, 7, 14)));\n    assert(date.add_years(4).eq(Date::new(2027, 7, 14)));\n    assert(date.add_years(5).eq(Date::new(2028, 7, 14)));\n}\n\n#[test]\nfn test_date_sub_years() {\n    let date = Date::new(2023, 7, 14);\n\n    assert(date.sub_years(0).eq(Date::new(2023, 7, 14)));\n    assert(date.sub_years(1).eq(Date::new(2022, 7, 14)));\n    assert(date.sub_years(2).eq(Date::new(2021, 7, 14)));\n    assert(date.sub_years(3).eq(Date::new(2020, 7, 14)));\n    assert(date.sub_years(4).eq(Date::new(2019, 7, 14)));\n    assert(date.sub_years(5).eq(Date::new(2018, 7, 14)));\n}\n\n#[test]\nfn test_date_add_months() {\n    let date = Date::new(2023, 7, 14);\n\n    assert(date.add_months(0).eq(Date::new(2023, 7, 14)));\n    assert(date.add_months(1).eq(Date::new(2023, 8, 14)));\n    assert(date.add_months(2).eq(Date::new(2023, 9, 14)));\n\n    assert(date.add_months(6).eq(Date::new(2024, 1, 14)));\n    assert(date.add_months(7).eq(Date::new(2024, 2, 14)));\n    assert(date.add_months(8).eq(Date::new(2024, 3, 14)));\n\n    assert(date.add_months(17).eq(Date::new(2024, 12, 14)));\n    assert(date.add_months(18).eq(Date::new(2025, 1, 14)));\n\n    assert(date.add_months(29).eq(Date::new(2025, 12, 14)));\n    assert(date.add_months(30).eq(Date::new(2026, 1, 14)));\n}\n\n#[test]\nfn test_date_sub_months() {\n    let date = Date::new(2023, 7, 14);\n\n    assert(date.sub_months(0).eq(Date::new(2023, 7, 14)));\n    assert(date.sub_months(1).eq(Date::new(2023, 6, 14)));\n    assert(date.sub_months(2).eq(Date::new(2023, 5, 14)));\n\n    assert(date.sub_months(6).eq(Date::new(2023, 1, 14)));\n    assert(date.sub_months(7).eq(Date::new(2022, 12, 14)));\n    assert(date.sub_months(8).eq(Date::new(2022, 11, 14)));\n\n    assert(date.sub_months(17).eq(Date::new(2022, 2, 14)));\n    assert(date.sub_months(18).eq(Date::new(2022, 1, 14)));\n    assert(date.sub_months(19).eq(Date::new(2021, 12, 14)));\n\n    assert(date.sub_months(30).eq(Date::new(2021, 1, 14)));\n    assert(date.sub_months(31).eq(Date::new(2020, 12, 14)));\n\n    assert(date.sub_months(41).eq(Date::new(2020, 2, 14)));\n    assert(date.sub_months(42).eq(Date::new(2020, 1, 14)));\n    assert(date.sub_months(43).eq(Date::new(2019, 12, 14)));\n}\n\n#[test]\nfn test_date_add_days() {\n    let date = Date::new(2023, 7, 14);\n\n    assert(date.add_days(0).eq(Date::new(2023, 7, 14)));\n    assert(date.add_days(1).eq(Date::new(2023, 7, 15)));\n    assert(date.add_days(2).eq(Date::new(2023, 7, 16)));\n\n    assert(date.add_days(17).eq(Date::new(2023, 7, 31)));\n    assert(date.add_days(18).eq(Date::new(2023, 8, 1)));\n    assert(date.add_days(19).eq(Date::new(2023, 8, 2)));\n\n    assert(date.add_days(31).eq(Date::new(2023, 8, 14)));\n    assert(date.add_days(32).eq(Date::new(2023, 8, 15)));\n    assert(date.add_days(33).eq(Date::new(2023, 8, 16)));\n\n    assert(date.add_days(365).eq(Date::new(2024, 7, 13)));\n    assert(date.add_days(366).eq(Date::new(2024, 7, 14)));\n    assert(date.add_days(367).eq(Date::new(2024, 7, 15)));\n\n    assert(date.add_days(365 + 365).eq(Date::new(2025, 7, 13)));\n    assert(date.add_days(365 + 366).eq(Date::new(2025, 7, 14)));\n    assert(date.add_days(365 + 367).eq(Date::new(2025, 7, 15)));\n\n    assert(date.add_days(365 + 366 + 364).eq(Date::new(2026, 7, 13)));\n    assert(date.add_days(365 + 366 + 365).eq(Date::new(2026, 7, 14)));\n    assert(date.add_days(365 + 366 + 366).eq(Date::new(2026, 7, 15)));\n\n    // After 4 regular years and 2 leap years\n    assert(date.add_days(365 * 4 + 366 * 2 - 1).eq(Date::new(2029, 7, 13)));\n    assert(date.add_days(365 * 4 + 366 * 2).eq(Date::new(2029, 7, 14)));\n    assert(date.add_days(365 * 4 + 366 * 2 + 1).eq(Date::new(2029, 7, 15)));\n}\n\n#[test]\nfn test_date_sub_days() {\n    let date = Date::new(2023, 7, 14);\n\n    assert(date.sub_days(0).eq(Date::new(2023, 7, 14)));\n    assert(date.sub_days(1).eq(Date::new(2023, 7, 13)));\n    assert(date.sub_days(2).eq(Date::new(2023, 7, 12)));\n\n    assert(date.sub_days(17).eq(Date::new(2023, 6, 28)));\n    assert(date.sub_days(18).eq(Date::new(2023, 6, 27)));\n    assert(date.sub_days(19).eq(Date::new(2023, 6, 26)));\n\n    assert(date.sub_days(31).eq(Date::new(2023, 6, 14)));\n    assert(date.sub_days(32).eq(Date::new(2023, 6, 13)));\n    assert(date.sub_days(33).eq(Date::new(2023, 6, 12)));\n\n    assert(date.sub_days(365).eq(Date::new(2022, 7, 14)));\n    assert(date.sub_days(366).eq(Date::new(2022, 7, 13)));\n    assert(date.sub_days(367).eq(Date::new(2022, 7, 12)));\n\n    assert(date.sub_days(365 + 365).eq(Date::new(2021, 7, 14)));\n    assert(date.sub_days(365 + 366).eq(Date::new(2021, 7, 13)));\n    assert(date.sub_days(365 + 367).eq(Date::new(2021, 7, 12)));\n\n    assert(date.sub_days(365 + 365 + 365).eq(Date::new(2020, 7, 14)));\n    assert(date.sub_days(365 + 365 + 366).eq(Date::new(2020, 7, 13)));\n    assert(date.sub_days(365 + 365 + 367).eq(Date::new(2020, 7, 12)));\n\n    // After 5 regular years and 1 leap year\n    assert(date.sub_days(365 * 5 + 366 - 1).eq(Date::new(2017, 7, 15)));\n    assert(date.sub_days(365 * 5 + 366).eq(Date::new(2017, 7, 14)));\n    assert(date.sub_days(365 * 5 + 366 + 1).eq(Date::new(2017, 7, 13)));\n\n    // After 6 regular years and 2 leap years\n    assert(date.sub_days(365 * 6 + 366 * 2 - 1).eq(Date::new(2015, 7, 15)));\n    assert(date.sub_days(365 * 6 + 366 * 2).eq(Date::new(2015, 7, 14)));\n    assert(date.sub_days(365 * 6 + 366 * 2 + 1).eq(Date::new(2015, 7, 13)));\n}\n\n#[test]\nfn test_date_age() {\n    let birthdate = Date::new(1995, 4, 13);\n\n    // Add 18 years to the birthdate\n    // to get the date when the person is 18 years old\n    let majority_date = birthdate.add_years(18);\n\n    // Make sure the majority date is correct\n    assert(majority_date.eq(Date::new(2013, 4, 13)));\n\n    // Compare the majority date to the current date\n    // to see if the person is 18 years old\n    assert(majority_date.lte(Date::new(2023, 12, 20)));\n}\n","path":"/Users/madztheo/nargo/github.com/madztheo/noir-date.git/0.4.3/src/lib.nr"}},"names":["main"],"brillig_names":["decompose_hint","lte_hint","directive_integer_quotient","directive_invert"]}