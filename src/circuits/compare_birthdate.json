{"noir_version":"1.0.0-beta.1+03b58fa2dfcc8acc8cf5198b1b23b55676fbdb02","hash":12650357299959300974,"abi":{"parameters":[{"name":"comm_in","type":{"kind":"field"},"visibility":"public"},{"name":"salt","type":{"kind":"field"},"visibility":"private"},{"name":"private_nullifier","type":{"kind":"field"},"visibility":"private"},{"name":"dg1","type":{"kind":"array","length":95,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"current_date","type":{"kind":"string","length":8},"visibility":"public"},{"name":"min_date","type":{"kind":"string","length":8},"visibility":"public"},{"name":"max_date","type":{"kind":"string","length":8},"visibility":"public"},{"name":"service_scope","type":{"kind":"field"},"visibility":"public"},{"name":"service_subscope","type":{"kind":"field"},"visibility":"public"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"7b3djiTJdWb7Lrzmhbv9uutVDg4GlMQZECBIQaIOcCDo3Seb3RFV3e7j3xTdqnLbt/xmMJoJZe5lkZ22zCNr2X/97l//+M//+b/+x5/+8j//+h+/+6f/579+9+e//ssf/vanv/7l43/6r9+t6/73/8f/+Lc//OWn//k//vaHf//b7/5pq+33v/vjX/714/+27//9+9/9zz/9+Y+/+6eW/vv3x5e27fXSLX95aTt5aW8p//La3nL98uL63//v73+3piXOKGucUdKPHKUs71FqOoyS44xS4oxSb46yL6+X7q1cj1L7a5K2iZf2tb6GLl8N0E9euvbXD+D69Vr0n/GaN173xtu88fbp8bbXAOvefouXF2+81RsveeNlo18tJ3jFG8/JWk7wnKzlBG96a0nLCy+t6YA3vbVc4wW1lm19DbDWG1JWglrLKLyg1jIKL6i1jMILai3fgHclZaV44wW1llF4Qa1lFF5Qa/mHfrWc4AW1llF401vLpZTV6a3lGi+mtWzlywD9MHNMFbmeOaZf7Hk5+6rfrE+1eOPF9ItheDH9YhheTL/4Frwrfaox/WIYXky/GIXXYvrFMLyYfvGP/Wo5wYupIsPwpreWS/ltxRsvqLXs/fUTt+T1xr7egmrLML6g3jKML6i4DOMLai7fwne1t/eg6jKML6i7DOMLKi/D+ILayz/2++WEr5jzze8vl37W5/eXa76Y/rIutbwBezlMHdNK1NQxXeNXU+8HQ9piGoSaOqYXqKlj7vZq6ph7+Lqm99QfD2BvHBK24g4YcxcfCBhzGx8IGHQf/ybAq4PCFnTLHwcY1A6GAe5BRWIcYFDn+Ad/yZwABtWTcYAGJnN53NuLO2BUk9n2F2BK+cZGv0c1mWGAUU1mGGBUkxkGGNVkvgXwYqNPS1STGQYY1WSGAUY1mWGAUU3mH/slcwJY3AENTOZK1dJiYDLXgEFNJpW3bKd2nDqonoipgzrH11P3/bdTr0FFQkwd1A7E1EG3fDF10H08r68G15p//V/jtx0W0lrcAYPu4+MAg+7j4wCD7uPfBHh1WFiDbvnjAIPawTDAFFQkxgEGdY5/8JfMCWBQPRkHaGAyl8e9213T8IBBTaYsr39nv5ZyIzCTgvZSBwIGNZlxgEFNZhxgUJP5JsCrjT5oN3UgYFCTGQcY1GTGAQY1mX/wl8wJYHEHNDCZS1UL2lAdCBjVZPZXZ3StbTlMHVVPrqcO6hx7+vKfeDn8hARNmaqpg9qBmDroli+mDrqP77V/2boOnwgFzYSqqYPuuGLqoNuomDro3iimDro3iqmj7o2XUwcNZqqpo+6N11NH3Ruvp55ybwyauFRTx9wb07K8XpuW4wksaJBSTR1zb1RTx9wb1dQx90YxddDYo5o65t6opo65N6qpY+6NauqYe6Oaesq9MWj1UE09wd+rH/9CNmihUE095d+rB60Jqqmn/Hv1oOU/NXXQc+NlwSgFrfSpqYM+UxVTB32mKqaeoJN3MvWU58agnTwxddBOnpp6ynNj0E6emvr23ri//2Xq8nUl5ebYg250T/czecH5qjlfM+fr8/Nd/V3i/URecL7dm+9+IC843+r0++WEL5nzze8vl39Tej+OF5wvqr+MuR887VH9ZRRfVH8ZxRfVX0bxRfWXMXeE5yWqv4zii+ovo/ii+ssovqj+MuaW97wUc775/eXKz/Iyv79c8wX1l6tL4fMSVEquhw5qGoNuC89rUNMYxhfUNIbxBTWNYXxBTWPQjeH5frQvOF9Q0xjGF9Q0hvEFNY1Bd77nNaiUDOOb318uTTjN7y/XfFH9ZdC14TlFFZhhgFENZhhgcQeM6jCDrg7PKarEDAOMajHDAKNqzDDAqB4z6Pr3nKOKzDBAA5O5VLVsYDLXgEFN5vqy+Hy/wfc5Ywe1jut/KJFzUJdQYwc1hGH3WuccVBEGEgZ1hHGEJagkDCQMagnD7rbOJagmDCSM6gnjCIs9YVT7GHVDeS5RRWUcoYPTXJ5IioPTXBOGdZpBd1znGtZphhGGdZphhGGdZhhhWKcZdM91vl98DE8Y1mmGEYZ1mmGEYZ1m0G3luYZ1mmGEDk5zaW3NwWmuCaM6zeXl5rlFFRUxdlT7uEyY5fuhzM8ZO6oniLGjbv6jLj7NLermP44w6uY/6urT3KJu/sMIe9TNf9Slb7lH3fzHEUb1hFHXvuUeVSnGEZaohFd3xOUe1T7E2FHt4/LmstyjKoUYO6oniLGjbv7XY29Rd/TL23DyFnWbFmNH3XvF2FE3VDF21F1SjB11lxRjh90lr8cOu0tejx12l7weO+wueTl21OimGnvOXTJqIvO63J2jli/V2EF3STV20F1SjR10l1RjB90l1dhBd0k1dtBd8nrsEjXtqMYOukuqsafcJUvUvqIaO+guef3BaYlaQ1RjRz1LirGjniXF2FHPkmLsqGfJ67GjZgnV2DP8VdTJ2DP8VdTJ2DP8e/TDPzUuUZN/auwp/z16iRroU2NH3SXF2FF3STF21F3yeuyo8Ts19pxnyailOjX2nGfJqFU5NfaUT1xL1AKcGnvKJ64laq1NjX26S+51ec/y9aUG6fQzrfcw675XsYvsy5tyX79akbPXrsv7w7I1ffXHaX8f/LytNsPg66yDp1kHz7MOXmYdvM46eJt18D7r4Nusg8+6c5ZZd87yg3fO7YuR7Wn/7TCz7oZl1t2wzLoblll3w9Ii/Qc36w5XZt3hyqw7XJ11h6uRdrg66w5XZ93h6qw7XJ11h6uRdrg66w5XZ93h6qw7XJt1h2uRdrg26w7XZt3h2qw7XJt1h2uRdrh2e4f71cdZ6cet4jbr4Pukg/dl1sHXWQdPsw6eZx28zDp4nXXwNuvgs+6cfdads//gnfNSnLZZd8Nt1t1wm3U33GbdDbcS6T+4WXe4bdYdbpt1h9tm3eG2SDvcPusOt8+6w+2z7nD7rDvcHmmH22fd4fZZd7h91h1un3WH2wPtcHWZdIery6Q7XF0m3eHqMukOV5dAO1xdBnxm1/Yvw7Svh/n7N2jf+xv07/0NBvxmL1++wb5ev19pfX+UmD7+F7+8+Fvv7qvLPung6zLr4GvgwS+ul6trmnXwPOvgZYqf8ZPB66yDt7iDX13oUdc+6+A/eOdMub0H78ud3+P7pIOnZdbB18CDX/0eT2nWwfOsg5cpfsZPBq+zDt7iDn65AaU+6+A/eOfM78vHUs71zu/xfdLB8zLr4Gvgwa9+j+c06+B51sHLFD/jJ4PXWQdvcQe/3IByn3XwH71zttej/lSW9c7v8X3Swcsy6+Br4MGvfo+XNOvgedbByxQ/4yeD11kHb3EHv9yASp918B+8c5a0vQff98M0e6Rp6vJp03zsr4dp1lDTpM+bpvfDNDnUND9432jr+6ObVu58kl3rrIO3WQfvgQe/cqO6zTr4PungbZniZ/xk8HXWwVPcwS+lruVZB//RO2d/a3Rf7zxVaHXWwdusg/fAg1/+Ht9mHXyfdPC+TPEzfjL4OuvgKe7glxtQz7MO/oN3zp7Le/BaDtPUUNO0z5umHzau3kNN84N3o215T7Pl7cb+3/dJB9+WWQdfAw9+tf9vadbB86yDlyl+xk8Gr7MO3uIOfikuW5918B+9c37594r7ku/8Ht8nHXxfZh18DTz41e/xPc06eJ518DLFz/jJ4HXWwVvcwS83oL3POvgP3jn39N7y93KcZg80TVuWz5um7odp1lDT3N+N1jW9fy6ruiB4VCGgDaiWfNLgZdbBa+DBL/b/dr+c8lmD91kH36b4GT8ZfJ908AGll+82+JW4tAGll08a/AfvnKMKAW3Nsw5eZh28Bh786vf42mYdvM86+DbFz/jJ4Pukg6cl7uCXG1BaZx38B++cowoBLeVZBy+zDl4DD371ezy1WQfvsw6+TfEzfjL4PungeYk7+OUGlNdZB//RO+egQkDLedbBy6yD18CDX/0ez23Wwfusg29T/IyfDL5POnhZ4g5+uQGVddbBf/DOeVlBaCWHmqZ82jTHCkIrNdQ07fOmOVQQWumhpvnB+8aoQkAr+6SD12XWwdfAg1+5UU2zDp5nHbxM8TN+MniddfAWd/BLqat91sF/9M45qBDQ6j7p4G2ZdfA18OBXv8dbmnXwPOvgZYqf8ZPB66yDt7iDX25Arc86+A/eOS8rCK3tkabpy+dNc6ggtL6GmuYH70ajCgGt51kHL7MOXgMPfrX/9zbr4H3WwbcpfsZPBt8nHXxb4g5+KS7bOuvgP3rnHFQIaFuedfAy6+A18OBXv8e3NuvgfdbBtyl+xk8G3ycdfF/iDn65Ae3rrIP/4J3zuoKw51DTlM+b5lhB2GuoaQbsRu39DVL6VSHi79/g/q6R1/cPfs7pGrek9zQlbfv1f1G5bK///HJN4p8Z9Y8z7y8v7m3fDgu5QTh3BGcfEHKZg3OFcCYIZ4ZwFhfOXl9/+Nh7TwfOCuFsEE4bHxKcNj7US/nCmQ+cNj50zbna+JDgtPEhwWnjQ9u7FdG31g+cNj4kOAuE08aHBKeND+1LfXHuv/4X6X/ntPEhwWnjQ4LTxoeuOZOND+3vT+/7fvhHiT3Z+JDgtPEhwWnjQ4KzQDhtfEhwGvnQV5zlwGnkQ5ecRj50yWnkQ1ec2dOHjpw+PrS9vvK2HP6gpGcfH7rm9PGha84C4fTxoWtOHx+65vTxoWtOHx+65vTxoUvO4uND15wQHyoQHyoQHxoQopuDE+JDBeJDBeJDBeJDxceHerrgrD4+dM3p40PXnD4+dM3p40PXnAXC6eND15w+PnTN6eND15w+PnTNCfGhBvGhBvGhBvGh5uJD21Lrm3NfD5wFwuniQ4rTxYcUp4sPKU4XH1KcLj4kOLuLDylOFx9SnC4+pDghPjQgsToHJ8SHOsSHOsSHOsSHOsSHNogPbRAf2iA+tEF8aEA4dw5OiA9tEB/aID60QXxoc/Shdf1tUrjvjj50xunoQ2ecjj50xunoQ2ecBcLp6ENnnI4+dMbp6ENnnI4+dMbJ8KHNpk+tOBk+tNn0qRUnw4e2pUA4GT602fSpFaeRD73/3dWalwOnkQ9dchr50BWnTZ9acRr50CWnkQ9dchr50CVngXAa+dAlp5EPXXJCfMimT604IT5k06dWnD4+lNoVp48PXXP6+NA1Z4Fw+vjQNaePD11z+vjQNaePD11z+vjQJadNn1pxQnzIpk+tOCE+ZNOnVpwQH7LpUytOiA/Z9KkVJ8SHbPrUihPiQzZ9asVp40NrXd+ch/t5N5s+teK08SHBaeNDgtPGhwSnjQ8JThsfSun14o+H7/23nDZ9asVp40OC08aHBKeND6W1fuHcDpwFwmnjQ3l97ys5H39ubXxIcNr4kOC08SHBaeNDdekvztrW6xd/fOv3zPvyBXDdzl689tcKpnXbvn7xTytoU77+jiuYyms1Umr5+sWlvaYo+1cv3X9ebBvdm2GxbZxzhsW2Ed/vuNhbewMu+53FLs9i/7jFtjkCfL/Fzvv2enFJ5aAYNoeLT1tBm2PLp62gzYHo01bwOWrdXEGfqP73W8H6fryaatuuX7y29xhrS/Ww3M9h64cu93PcGrvcvb6+8tp7u2GwPpci2L0z5Xlngr4zz6lv8Duzvz5nW7d1u/POPKfJqO8M85S6f1nsvazinbn+MMbn2pDvt4LDHln73F0ywWL7XKDyHRd71CNrn1tcZlhs5rn3mxb7+rmYzyU1n7aC5VnBmyvIPO+NXEHmuWzkCj7nJ7mCAx9Y+9xJNMdyP8etscs97Fmnz2VOdu/Mc5CL+s48p77B78yop9A+V3zZvTOF+M7k5f3ivJTllkP5XHf2aSuIPKV+2wqO2ySRB9rPWmzkcfazFht5mP3GxR7kDbvP5XozLLbPkXN/lxramr5+8d85fQ5w15w+x6H3w/OtHUpk+1IgnD5HgGtOH1Hf+xfOeuD0ceRrTh89veb0McNLTp8b/gSnkQ9dchr50Fec+4HTyIcuOQuE08iHLjk9fejIaeNDrb/PZX3pB04bHxKcNj50zelzw5/gtPEhwWnjQ4LTxocEZ4Fw2viQ4LTxIcEJ8SGfG/4EJ8SHfG74E5wQH/K54U9wQnzI54Y/wenjQ++P7U85fXzomtPHh645fXzomtPHhy45fW74E5w+PnTN6eND15w+PnTNWSCcEB/yueFPcEJ8yOeGP8Fp40P9PfPWt/ZbTp8b/gSnjQ8JThsfEpw2PiQ4C4TTxocEp40PCU4bHxKcNj4kOCE+5HMPn+CE+JDP7XOCE+JDPneuCU6ID/lcSiY4HX1oW9cDp6MPnXE6+tAJp89lWYLT0YfOOB196IzT0YfOOAuE09GHzjgdfeiME+JDPlfJCE6ID/lcoCI4IT7kc22I4IT4kM8VHILTx4fK++/Gt3ToYfhcZyE4fXzomtPHh645fXzoktPn0gLB6eND15w+PnTN6eND15wFwgnxIZ9wuuCE+JBPLlxw+vhQWv/PnOviU8lWoD5GJEB9lEiA+jiRAC0UUB8rEqA+WiRAfbxIgPqIkQClmJFPqlqBUszIJ1atQClm5JOrVqAUM/IJVitQihn5JKsVKMWMfKLVCpRiRj7ZagUa2Yxq+QK6iXv+2l5eY7S9bkfQQgGNbEZDQSOb0VDQyGb0baBtfYP2fgSNbEZDQSOb0UjQ0PnqoaCRzegf/mV0BhrZjIaC+pjR+1Ljvhz+EvkDtFBAfcxIgLqY0QddeYPmE1AXM5KgLmYkQV3MSIGGDln/w7+MzkB9zEiAuphRX7aX6/Z1OT4zCt2yHgpaKKAuZiRBbcwo5Vf+uKcmHgK3kl+/uVqpSbw4te314nQIIX0soY1zfd4S2tjc5y2hjSeu7ctvrG05gIYOfA8FdfFECWrjiQrUxhPXLb9/zS3pCFoooDaeqEBtPFGB2tjcV7+MTkFtnEuBUswodOp7KCjFjELHvoeCUswodO57KCjFjEIHv4eCUswodPJ7jqdRoavM37aE6f0ZV+rlCGqzcSlQm41LgdpsXArU56MfAerzAY0A9dm4BKjNkV6Ahq4zDwW1OdIrUIoZhQ40DwUtFFCKGYVuNA8FpZhR6ErzUFCKGYXuNA8FpZhR6FLzUFCKGYVuNQ8FpZhR6FrzUFCKGYXuNQ8FhZjRGjrYPPCPBtbQweahoJA/A1lDB5uHghbGHw2soYPNQ0Ehfwayhg42DwWF/IHsGjrYPNKMQgebh4JCnhmtoYPNQ0Ehz4zW0MHmoaCQZ0Zr6GDzUFDIM6M1dLB5KCjFjEIHm4eCUswodLB5KCjFjGyCzRKUYkY2wWYJSjEjm2CzBKWYkU2wWYJSzMgm2Kw+ZLIJNkvQQgH1+TRNgFI+TfMJNitQn0/TBKhPbuYa1CbYrD4ftQk2KzPyCTYrUMozI59gswKlPDMyCjYLUMozI6P4sQClPDPySRQrUIoZ+SSKFSjFjHwSxQqUYkY+iWIFSjEjn0SxAqWYkU+iWIFSzMgnUaxAKWZklCi+/pDJKFEsQH0+TROgjoniU1DKp2mN8mla9/k0TYD6/Kt9Aer4d0anoBQzojSwV0oDe6U0sFdKA3ulNLBXSgN7pTSwV0oDe6U0sFdKA3ulNLBXSgN7pTSwV0oDe6U0sFdKA3ulNLBXSgN7pTSwV0oDe6U0sFdKA3v1aWCLD5l8GtgK1LH0eAoKuQo9GTWwLz9kSkYNbAHq82maAIVchZ6Wwvh8NPk0sK/NKPk0sBUo5JlR8mlgK1DIM6NEaWAnSgM7URrYidLATpQGdqI0sBOlgZ0oDexEaWAnSgM7URrYidLATpQGdqI0sBOlgZ0oDexEaWAnSgM7+TSwxYdMPg1sAerTwFagkBtlk1ED+/pDJqMGtgAtFFDIjbLJqIF9/fmoTwNbmJFPA1uBUp4Z+TSwFSjlmRGlgZ0oDexEaWAnSgM7URrYidLATpQGdqI0sBOlgZ0oDexEaWAnSgM7URrYidLATpQGdqI0sBOlgZ0oDezk08AWHzL5NLAVKORG2eTTwFagBfIhk1EDW4BCbpRNRg1sAer4d0anoBQz8mlgK1DKMyOfBrYCpTwzojSwE6WBnSgN7ERpYCdKAztRGtiJ0sBOlAZ2ojSwE6WBnSgN7ERpYCdKAztRGtiJ0sBOlAZ2ojSwE6WBnXwa2OJDJp8GtgItFFDIjbLJqIF9/SGTUQNbgEJulE1GDexL0GzUwL78fDT7NLCvzSj7NLAVKOSZUV4KBRTyzChTGtiZ0sDOlAZ2pjSwM6WBnSkN7ExpYGdKAztTGtiZ0sDOlAZ2pjSwM6WBnSkN7ExpYGdKAztTGtiZ0sDOPg3s6w+Zsk8DW4FCbpTNPg1sBQr5NC0bNbCvQY0a2AIUcqNsNmpgX38+6tPAFmbk08BWoJRnRj4NbAVKeWZEaWBnSgM7UxrYmdLAzpQGdqY0sDOlgZ0pDexMaWBnSgM7UxrYmdLAzpQGdqY0sDOlgZ0pDexMaWBnSgM7+zSwxYdMPg1sBQq5UTb7NLAFqFED+/pDJqMGtgCF3CibjRrYArRAPh/1aWALM/JpYCtQyjMjnwa2AqU8M6I0sDOlgZ0pDexMaWBnSgM7UxrYmdLAzpQGdqY0sDOlgZ0pDexMaWBnSgM7UxrYmdLAzpQGdqY0sDOlgZ19GtjiuS6lgZ0pDexMaWBnnwa2AqWYkU8DW4FSzMinga1AKWbk08BWoBAzKj4NbAUKMaNCaWAXSgO7LIUCCjGjQmlgF0oDu1Aa2IXSwC6UBnahNLCLTwO71PcfJpder1/cSn6tSis1iRentr1enH49xs9LaONcn7eE5VnCu0to44mft4Q2BvqDlrAdl9DGbT9vCW2s+fOW0MbHc+/vJVy3A6hPeV2B2vh4Ke8/Pyi//so/g/r4uAD1sWYBWiigPgYqQH08UYD62JwA9XEuAWpjRgLUp7yuQClm5FNeV6AUM/IprytQihn5lNcVKMWMfMrrCpRiRj7ldQVKMSOf8roCpZiRT3ldPNf1Ka9/2ocdPmFs8R+FTxhbgVI2Lp8wtgKlbFw+YWwFSjnS+4SxFSjlSO8TxlagFDPyCWMrUIoZ+YSxFSjFjHzC2AqUYkY+YWwFSjEjnzC2AqWYkU8YW4FSzMgnjK1AKWbkE8ZWoBQz8gljK1CKGfmEsRUo5Z8O+YSxxTvqE8ZWoBQz8gljK9BCAaWYkU8YW4FSzMgnjK1AKc+MfMLYCpRiRj5hbAVKMSOfMLYCpZiRTxhbgVLMyCeMrUAhZlR9wtgKFGJG1SeMrUBtzOj6uW5dCuUdhZhR9QljK1CIGVWfMLYCpZiRTxhbgVLMyCiMLUAhz4yqUWRagFLMyCjYLEApZmQUPxagFDPySRQrUIoZURLFlZIorpREcaUkiislUVx9EsXiuS4lUVwpieJKSRRXSqK4UhLFlZIorpREcaUkiislUVwpieJKSRRXSqK4UhLFlZIorpREcaUkiqtPoliBUsyoUMyoUMyoUMyI0sCulAZ29Wlgi+e6lAZ2pTSwK6WBXSkN7EppYFdKA7tSGtiV0sCulAZ2pTSwK6WBXSkN7EppYFdKA7tSGtiV0sCulAZ2pTSwK6WBXSkN7EppYFdKA7tSGtjVp4EtnutSGtiV0sCulAZ29WlgC1BKA7tSGtiV0sCulAZ2pTSwK6WBXSkN7EppYFdKA7tSGtiV0sCulAZ2pTSwK6WBXSkN7EppYFdKA7tSGtiV0sCuPg3s6+e6jdLAbpQGdqM0sJtPA1uBFgooxIwapYHdKA3sRmlgN0oDu1Ea2I3SwG6UBnajNLAbpYHdKA3sRmlgN0oDu1Ea2I3SwG6UBnajNLAbpYHdfBrY4rkupYHdKA3sRmlgN58GtgKlmBGlgd0oDexGaWA3SgO7URrYjdLAbpQGdqM0sBulgd0oDexGaWA3SgO7URrYjdLAbpQGdqM0sBulgd0oDezm08AWz3UpDexGaWA3SgO7+TSwFSjFjCgN7EZpYDdKA7tRGtiN0sBulAZ2ozSwG6WB3SgN7EZpYDdKA7tRGtiN0sBulAZ2ozSwG6WB3SgN7EZpYDefBrZ4rktpYDdKA7tRGtjNp4GtQClmRGlgN0oDu1Ea2I3SwG6UBnajNLAbpYHdKA3sRmlgN0oDu1Ea2I3SwG6UBnajNLAbpYHdKA3sRmlgN0oDu/k0sMVzXUoDu1Ea2I3SwG4+Dexr0E5pYHdKA7tTGtid0sDuS6GAQp4ZdUoDu1Ma2J3SwO6UBnanNLA7pYHdKQ3sTmlgd0oDu1Ma2J3SwO6UBnanNLB76Ab2x8Bv0L0eZg+dtVazR/YXNXtkJVGzR7YMNXuZePbILqBmj7y9q9kj79hq9sibsJp94n01dBRZzT7xvho6Xaxmn3hfDR0YVrNPvK+GzgCr2SfeV0PHetXsE++roZO6avaJ99XQ4Vs1+8T7aug8rZp94n01dERWzT7xvho69apmj7yvtvX1DDu3cpw9dJBVzR55X1WzR95X1eyR91U1e+R9Vc0eeV9Vs0feV9XskfdVNXvkfVXNPvG+GjrnqWafeF8NHd1Us0+8r4ZOY6rZJ95XQwcs1ewT76uhM5Nq9on31dAxSDX7xPtq6GSjmn3ifTV0WFHNPslz4FbacfZJngOfzj7Jc+DT2Sd5Dnw6+ySfr57NHjolqGaf5PPV09kn+Xz1dPZJPl89nT3yvqpmn3hfDR3PU7NPvK+GTtyp2SfeV0OH6NTsE++roXNxavbQ59X25czXt+PskfdVNXvo58Bi9tDPgcXsoZ8Di9lDPwcWs4d+Dnw5+xY6Y6ZmH7uvll/N/vN3SN/9OwzYo9ry/g5bvV7/ddtfW+a6p6/W/5dpSqhpaqhpWqhpeqhptlDTDPh9vL+nKeu9aUbkkAZOs4aaJoWaJoeapoSaZsDv4rp/maYddsIRARvxHfp3/w7bd/8O93+31WV7fYeauvC13N++lvdv+fv+tFy/uLfefnlxb/tR7gaEVSYBXSmgiQKaKaCFAlopoM0FtNfXGL33dATtFNCNAmpjRgI025hRL+ULaD6C2piRArUxIwVqY0YKtLiAbvktDFvrR1AbM1KgNmakQG3MSIHamNG+1BfonusR1MaMBGixMSMFamNGCtTGjPblLQx7WY6gNmakQAsF1MaMFKiNGSlQGzNSoEZm9BVoOYIamdElaDUyo2tQIzO6BvU0oxNQHzPaXl95W9bjc90BSa1JQH3MSID6mJEA9TEjAepjRgLUx4yuQZuPGQlQHzMSoD5mJEApZjQgijYJKMWMGsWMGsWMGsWMGsWMOsWMuo8Z9XQJ6mNGAtTHjARooYD6mJEA9TEjAepjRgLUx4wEqI8ZXYNuPmYkQClmtFHMaKOY0YAw4SSgLma0LbW+Qff1COpiRhLUxYwkqIsZSVAXM1Kgu4sZSVAXM5KgLmYkQV3MSIIWCijFjHaKGe0UM9opZrRDzGhfIGa0LxAz2heIGe0LxIz2pVBAIWa0LxAz2hdHM1rXdgR1NKNTUEczOgNdHc3oFNTRjE5BHc3oFNTRjE5BCwXU0YxOQR3N6BSUYkYrxYxsGtgK1KaBLUEpZmTTwJagFDOyaWBLUCMzev9zkDUvR1AjM7oGNTKja1AjM7oGNTKjS1CbBrYENTKja1AjM7oGNTKja9BCAaWYkU0DW4JSzMimgS1BfcwotStQmwa2BPUxIwHqY0YC1MeMBGihgPqYkQD1MSMB6mNGAtTHjAQoxYxsGtgSlGJGNg1sCUoxI5sGtgSlmJFNA1uCUszIpoEtQSlmZNPAlqA2ZrTW9Q16vH90t2lgS1AbM1KghQJqY0YK1MaMFKiNGaX0evGWSj+C2piRArUxIwFq08CWoDZmlNb6BXQ7gtqYkQK1MaO8vreXnE9+dAsF1MaMFKiNGSlQGzOqS3+B1rZevzhte37NvC9fANft7MVrfy1hWrft6xf/vIQ2zvX9ljCV12qk1PL1i0t7TVH2r166/7LaNuI3w2rbdMbnWG0bBf6Oq729nq+mvOy3VtvGw6dYbZvDwPdb7by/AUsqB9GwCcp/4hLaHGA+bwltjkaft4TPoev2Ej6HLrmE9f3ANdW2Xb94be8x1pbqcb2fY9cPXW+fawyCrHevr6+89t7umKzPxQt+b81zpAv71jznv8Fvzf768G3d1u3WW1OetybqW8M8r+5fVnsvq3hrxMczPleTfL8lHPcI2+d+lClWm3kK/rbVHvYI2+emmPirnRaf62q+32pfPiT7WELmSXXoEjJPlEOXkHnyG7qE5VnCu0v4nKTkEo57gP2x3s+x68eu93PwGrveox59frw1zykt7FvzHOmivjU+l3JFeWsGPZX+eGuec2XYtwZ5Xs3L+8V5Kcs9k/K5Uu3zlrA8S6iWcOBOiTzaftpqIw+2n7bayGPtN672OHtAnlQ/bbV9Dp/7O+3Q1vT1i/8O6nOLoAL1ORi9n6Zv7ZAx+wD1OWYIUJ/DgAAtPqD9C2g9gvrYsgD1EVUB6uOIAtRHzwSokRldgvrcIvgr0P0IamRG16BGZnQNamRG16CFAmpjRq2/j2l96UdQGzNSoDZmpEBtzEiB2piRAPW5RVCB2piRArUxIwVqY0YKtFBAKWbkc4ugAqWYkc8tggqUYkY+twgqUIoZ+dwiqEB9zOj9yf45aKGA+piRAPUxIwHqY0YC1MeMBKiPGV2D+twiqEB9zEiA+piRAKWYkc8tggqUYkY+twgqUBsz6u+Zt761I6iNGSlQGzMSoD63CCpQGzNSoDZmpEBtzEiBFgqojRkpUBszUqAUM/K560+BUszI54Y7BUoxI5973RQoxYx8Lj5ToI5mtK3rEdTRjE5BHc3oFNTRjE5BHc3oDNTnCioF6mhGp6COZnQK6mhGp6CFAkoxI5/rahQoxYx8LmlRoBAzWn2uJlGgEDNafa75UKA+ZlTef2q+pXoELRRQHzMSoD5mJEB9zEiA+piRAPUxo2tQn2i/AvUxIwHqY0YClGJGPnF2BUoxI58kuQL1MaO0XoL6mJEA9TGja1CfBrYC9TEjAepjRgLUx4wEaKGA+piRAPUxIwFKMSOfBrYCpZiRTwNbgVLMyKeBrUApZuTTwFagFDPyaWArUIoZ+TSwFSjFjHwa2Ao0shnV8gV0E1cJtr28br5se+9H0MhmNBQ0shl9G+j7vse+nPxBVegG9lDQyGY0FDSyGX0L6AddeYPmE9DIZjQUNLIZDQWNbEYjQUM3sP/hX0ZnoD5mJEBdzKgv28t1+7ocXTd0A3soaKGAupiRBLUxo5Rfpceemji8tpJfv7laqUm8OLUXYEvHwsMauq49yRLa2NznLaGNJ65bfi/hkg6goYvgQ0FdPFGC2niiArXxxI8fzkvQQgG18UT1o2vjiQrUxuYUqI1zKVAfM7r+ZRS6CD6HRYcONn/bEqb3s7nUyxHUZuNSoD4POASoz2MIAerzsECA2mxcAjR0sHkoqM2RXoHaHOkVqM2RXoEWCijFjEIHm4eCUswodLB5KCjFjEIHm4eCUswodLB5KCjFjEIHm4eCUswodLB5KCjFjEIHm4eCQswohQ42DwWFmFEKHWwe+IFkCh1sHgpaKKCQPwNJoYPNAz9LT6GDzUN/60LMKIUONo8EDR1sHgpKMaPQweahoJBnRil0sHkoKOSZUQodbB4KSjGj0MHmoaAUMwodbB4KSjGj0MHmoaAUMwodbB4KSjGj0MHmoaAUMwodbB4KSjGj0MHmkQ+wQwebh4JSPk0LHWweClogn72EDjYP/a1LMaPQweahoBQzCh1sHgkaOtg8FJTyzMgm2CxBKc+MbILNEpRiRj7BZgVKMSOfYLMCpZiRTbBZglLMyCfYrEApZuQTbFagFDMyCjYLUIoZ+cSPxQNsSqI4URLFiZIoTkaJ4uvPXnwSxeK3rk+iWIFSzMgnUaxAKWbkkyhWoJRnRkaJYgFKeWbUKc+MOsWMKA3sRGlgJ0oDO1Ea2InSwE6UBnaiNLATpYGdKA3sRGlgJ0oDO1Ea2MmngS0eYPs0sBUo5dM0nwa2APVpYIvPXigN7ERpYCdKAztRGtiJ0sBOlAZ2ojSwE6WBnSgN7ExpYGdKAzv7NLAVKMSM8lIooBAzyj4NbAUKMaNMaWBnSgM7UxrYmdLAzpQGdqY0sLNPA/v6AXb2aWArUMinadmnga1AfT5Nu/zsJVMa2JnSwM6UBnamNLAzpYGdKQ3sTGlgZ0oDO1Ma2JnSwM6UBnb2aWArUIoZ+TSwFSjFjHwa2AqUYkaUBnamNLAzpYGdKQ3sTGlgZ0oDO/s0sMUDbJ8GtgItFFDKp2k+DWzx2QulgZ0pDexMaWBnSgM7UxrYmdLAzpQGdqY0sDOlgZ0pDexMaWBnnwa2AqWYkU8DW4FSzMinga1AKWZEaWBnSgM7UxrYmdLAzpQGdqY0sLNPA1s8wPZpYCtQyqdpPg1sBVogn71QGtiZ0sDOlAZ2pjSwM6WBnSkN7ExpYGdKAztTGtiZ0sDOlAZ29mlgK1CKGfk0sBUoxYx8GtgKlGJGlAZ2pjSwM6WBnSkN7ExpYGdKAzv7NLDFA2yfBvY1aPFpYCtQyKdpxaeBff3ZS6E0sMtSKKAQMyqUBnahNLALpYFdKA3sQmlgF0oDu1Aa2IXSwC4+DWwFSjEjnwa2AqWYkU8DW4FSzIjSwC6UBnahNLALpYFdKA3sQmlgF58GtniA7dPAVqCQT9OKTwNbgPo0sMVnL5QGdqE0sAulgV0oDexCaWAXSgO7UBrYhdLALpQGdqE0sAulgV18GtgKlGJGPg1sBUoxI58GtgKlmBGlgV0oDexCaWAXSgO7UBrYhdLALj4NbPFcl9LALpQGdqE0sAulgV0oDexCaWAXSgO7UBrYhdLALpQGdqE0sAulgV0oDexCaWAXSgO7+DSwFSjFjHwa2AqUYkY+DWwFSjEjSgO7UBrYxaeBnXt/gZZ1O4LamJEA9Wlgl/J+Ul+2/QhqY0YK1MaMFKiNGSnQQgG1MSMFamNGCtTGjBSojRkpUBszEqA+DWwFSjEjnwa2AqWYkU8DW4FSzMinga1AKWbk08BWoBAzqj4NbAUKMaPq08BWoDZmdP1cty7F5h2t74TIx0dn1y9uJb8+v2ilJvHi1F6ALW3tuISQjav6JIoFqE+iWIFSNi6fRLEChRzpq0+iWIFCjvTVJ1GsQCFH+uqTKFagFDPySRQrUIoZ+SSKFSjFjHwSxQqUYkY+iWIFSjEjn0SxAqWYkU+iWIFSzMgnUaxAKWbkkyhWoBQz8kkUK1CKGfkkisUnrz6JYvGO+iSKFSjFjHwSxQqUYkY+iWIFSjEjn0SxAqWYkU+iWIFSzMgnUaxAKWbkkyhWoBQz8kkUK1CKGfkkihUoxYx8EsUKlGJGPoliBUoxI59EsXiu65MoVu9ooYBSzMgnUaxAKWbkkyhWoBQz8kkUK1CKGfkkihUoxYx8EsUKlGJGPoliBUoxI59EsQKlmBElUVwpieJKSRRXSqK4UhLFlZIorj6JYvFcl5IorpREcaUkiislUVwpieJKSRRXSqK4UhLFlZIorpREcaUkiislUVwpieJGSRQ3SqK4URLFzSdRrEALBRRiRm2BmFFbIGbUKA3sRmlgN58G9vVz3UZpYDdKA7tRGtiN0sBulAZ2ozSwG6WB3SgN7EZpYDdKA7tRGtiN0sBulAZ2ozSwG6WB3SgN7EZpYDdKA7tRGtiN0sBulAZ2ozSwG6WB3Xwa2OK5LqWB3SgN7EZpYDefBrYCpZgRpYHdKA3sRmlgN0oDu1Ea2I3SwG6UBnajNLAbpYHdKA3sRmlgN0oDu1Ea2I3SwG6UBnajNLAbpYHdKA3s5tPAFs91KQ3sRmlgN0oDu/k0sBUoxYwoDexGaWA3SgO7URrYjdLAbpQGdqM0sBulgd0oDexGaWA3SgO7URrYjdLAbpQGdqM0sBulgd0oDexGaWA3nwa2eK5LaWA3SgO7URrYzaeBrUApZkRpYDdKA7tRGtiN0sBulAZ2ozSwG6WB3SgN7EZpYDdKA7tRGtiN0sDulAZ2pzSwO6WB3SkN7L4UCijEjLpPA/v6uW6nNLA7pYHdKQ3s7tPAVqAUM6I0sDulgd0pDexOaWB3SgO7UxrYndLA7pQGdqc0sDulgd0pDexOaWB3SgO7UxrYndLA7pQGdqc0sDulgd19GtjiuS6lgd0pDexOaWB3nwa2AqWYEaWB3SkN7E5pYHdKA7tTGtid0sDulAZ2pzSwO6WB3SkN7E5pYHdKA7tTGtid0sDulAZ2pzSwO6WB3SkN7O7TwBbPdSkN7E5pYHdKA7v7NLAVKMWMKA3sTmlgd0oDu1Ma2J3SwO6UBnanNLA7pYHdKQ3sTmlgd0oDu1Ma2J3SwO6UBnanNLA7pYHdKQ3sTmlg99AN7I+B36B7Pc4eWXbE7KFL1Wr2yEqiZo9sGWr2yOKgZi8Tzx55e1ezR96x1eyRN2E1+8T7augospg9dOdYzT7xvhq6Rqxmn3hfDd0MVrNPvK+GLvuq2SfeV0P3d9Xs8+6rW+hKrpp93n11C92yVbPPu69uy7z76hY6Iqtmn3df3UKnXtXskffVtr6eYedWTmaPvK+K2UM3VtXskfdVNXvkfVXNHnlfVbNH3lfV7JH3VTV75H1VzR55X1WzT7yvhs55itlDFzrV7BPvq6E7mmr2iffV0LVLNfvE+2roJqWafeJ9NXQ5Us0+8b4auu/41TOOVtpx9kmeA5/OPslz4NPZJ3kOfDp75H1VzT7Jc+DT2Sd5Dnw6+yTPgU9nn+Tz1dPZJ/l89Wz20HVANfvE+2rohp+afeJ9NXRpT80+8b4auoenZp94X/3Eat1J5Wj7xLbc2TifWIA7HWeNNU6KNU6ONU6JNU6NNc7Y3/f5V+P8/B36d/8OA353ti/fYVu+0+/9mpbrF/fW2y8v7m0/ebN2COiIrtUcoCsFNFFAMwW0uID28vrKvfd8BK0U0EYB7RRQGzP6eOD/At1aP4LamJEA7TZmpEBtzEiB2pjRvtQX6J6PfxrQbcxIgRYKqI0ZKVAbM9qXtzDsZTmC2piRArUxIwVqY0YCdLMxIwVqY0YK1MiMvgItR1AjM7oGLRRQIzO6BvU0oxNQHzPaXl95W9Z0BPUxIwHqY0bXoLuPGQlQHzMSoD5mJEB9zEiAFgqojxkJUB8zEqAUM9opZrRDzGhfIGa0LxAz2heIGe0LxIw+juUUUB8z6ukS1MeMBKiPGQlQHzMSoD5mdA26+piRAPUxIwHqY0YC1MeMBGihgFLMaKWY0Uoxo5ViRquLGW1LrW/QfT2AJhczkqAuZiRBXcxIgrqYkQQtFFAXM5KgLmYkQV3MSIK6mJEEpZhRpphRpphRpphRppjRiF7pHKAUM8oUM8qOZrSu7QjqaEanoI5mdAZaHM3oFNTRjE5BHc3oFNTRjE5BCwXU0YxOQR3N6BSUYkaFYkaFYkaVYkaVYkaVYkaVYkYjCspzgBqZ0ftPzde8HEGNzOga1MiMrkGNzOga1MiMLkFtGtgS1MiMrkGNzOga1MiMrkELBZRiRjYNbAlKMSObBrYE9TGj1K5AbRrYEtTHjASojxkJUB8zEqCFAupjRgLUx4wEqI8ZCVAfMxKgFDOyaWBLUIoZ2TSwJSjFjGwa2BKUYkY2DWwJSjEjmwa2BKWYkU0DW4LamNFa1zfo8W7D3aaBLUFtzEiBFgqojRkpUBszUqA2ZpTS68VbKv0IamNGCtTGjC5B82LTwJagNmaU1voFdDuC2piRArUxo7y+t5ecT350CwXUxowUqI0ZKVAbM6pLf4HWtl6/+Kebi14z78sXwHU7e/HaX0uY1m37+sU/L6GNc32/JUzltRoptXz94tJeU5T9q5fuv6y2jfjNsNo2nfE5VttGgb/jam+v56spL/ut1bbx8ClW2+Yw8P1WO+9vwJLKQTRsgvKfuIQ2B5jPW0Kbo9HnLeFz6JJLWN9PC39ivX7x2t5jrC3V43o/J7Qfu97PGW3sevf6+spr7+2Ohvlcj+D31jynv7BvzXNUHPzW7K9PjtZt3W69Nc+5MuxbU5Bvzf5ltfeyirdGfLbgc4HI91vCcc9ffW4xmWK1mafgb1vtYc9ffe5zmWK1mSfgb1pt8ZDM57qaz1tC5oly6BIyT35Dl5B5Qhu6hOVZQrWEIx9g+9xONMl6Pwevses97tGnz7VOfm/Nc6QL+9Y857/Bb82wp9I+l335vTXI8+pP/wjj9ZU/fjrvmZTPxWeft4TI8+q3LeG4ndLnXrcpVht5sP201UYea79xtcfZA/Kk+mmr7XP43N9dgramr1/8M6jPUe4a1Oeuv/p+mr61Q4PrA9TnmCFAfQ4DAtRH2ff+BbQeQQsF1EdUBaiPIwpQHz0ToEZmdA1qZEZfge4HUJ+7/hSokRldgxqZ0TWopxmdgBYX0Nbfx7S+9COojRkpUBszUqA2ZqRAbcxIgdqYkQD1uetPgdqYkQK1MSMFamNGCrRQQClm5HPXnwKlmJHPXX8KlGJGPnf9KVCKGfnc9dfen+yfg/qYkQAtFFAfMxKgPmYkQH3MSID6mJEA9TGja1Cfu/4UqI8ZCVCKGfnc9adACwWUYkY+d/3198xb39oR1MaMFKiNGSlQGzO6Bl197vpToDZmpEBtzEiB2piRAi0UUBszUqAQM1p97vpToBAzWn0uwxOgPvfQKVCKGfncvqZAKWbkcz3ZV6Dbuh5BHc3oFNTRjE5BHc3oFNTRjE5BHc3oDNTnQicF6mhGp6COZnQK6mhGp6CFAkoxI5+bYhQoxYx87kdRoBQz8rlARIFSzMjnMo5e3n9qvqV6BPUxIwFaKKA+ZiRAfcxIgPqYkQD1MSMB6mNG16A+CXwF6mNGApRiRj5xdgVaKKAUM/Kpgfe0XoL6mJEA9TEjAepjRtegPg1sBepjRgLUx4wEqI8ZCdBCAfUxIwFKMSOfBrYCpZiRTwNbgPo0sBUoxYx8GtgKlGJGPg1sBUoxI58GtgKlmJFPA1uBUswodAO7li+gm7hKsO3ldfNl23s/gkY2o6Ggkc3o20Df9z32JR//oCp0A3soaDEB7cv2+mXU1+Xkl1FkMxoKGtmMhoJGNqOhoJHN6JtAP54hvEDTko6gkc1oJGjoBvZQUBcz6in3N2gTYtxKfm26rdQkXpzegC2d/Ovx0Inib1vC9FaR1MsR1GbjUqA2G5cCtdm4FKjNxiVAQyeKh4L6bFwC1OVIL0FdjvQStFBAKWYUOlE8FJRiRqETxUNBIWaUQieKh4JCzCiFThQPBYWYUVoKBRRiRil0ongoKMSMUuhE8VBQihmFThQPBaWYUehE8VBQGzO6/pwuhU4UD31HKWYUOlE8FJRiRqETxUNBKWYUOlE8FJRiRqETxUNBKc+MQieKh4JSzCh0ongoKMWMQieKh4JSzCh0ongoKMWMQieKh4JSzCh0ongoKMWMQieKh4LamJF4rhs6UTz0HaWYUehE8VBQihmFThQPBaWYUehE8VBQihmFThQPBaU8MwqdKB4KSjGj0InioaAUMwqdKB4KSjGj0InioaAUMwqdKB4KSjGj0InioaAUMwqdKB4KamNG4rlu6ETx0HeUYkahE8VDQSlmFDpRPBSUYkahE8VDQSlmZJMolqCUZ0Y2iWIJSjEjn0SxAqWYkU+iWIFSzMgnUaxAKWbkkyhWoBQz2ihmtFHMaCsUUBszEs91KQ3sRGlgJ0oDO1Ea2InSwE6UBnaiNLATpYGdKA3sRGlgJ0oDO1Ea2InSwE6UBnamNLAzpYGdKQ3sTGlg56VQQCFmlCkN7ExpYGdKAzv7NLCvn+tmSgM7UxrYmdLAzj4NbAVaKKAUM6I0sDOlgZ0pDexMaWBnSgM7UxrYmdLAzpQGdqY0sDOlgZ0pDexMaWBnSgM7UxrYmdLAzpQGdqY0sLNPA1s816U0sDOlgZ0pDezs08BWoBQzojSwM6WBnSkN7ExpYGdKAztTGtiZ0sDOlAZ2pjSwM6WBnSkN7ExpYGdKAztTGtiZ0sDOlAZ2pjSwM6WBnX0a2OK5LqWBnSkN7ExpYGefBrYCpZgRpYGdKQ3sTGlgZ0oDO1Ma2JnSwM6UBnamNLAzpYGdKQ3sTGlgZ0oDO1Ma2JnSwM6UBnamNLAzpYGdKQ3s7NPAFs91KQ3sTGlgZ0oDO/s0sBUoxYwoDexMaWBnSgM7UxrYmdLAzpQGdqY0sDOlgZ0pDexMaWBnSgM7UxrYmdLALpQGdqE0sAulgV0oDeyyFAoo5N60QmlgF0oDu1Aa2MWngS1AKQ3sQmlgF0oDu1Aa2IXSwC6UBnahNLALpYFdKA3sQmlgF0oDu1Aa2IXSwC6UBnahNLALpYFdKA3sQmlgF0oDu/g0sMVzXUoDu1Aa2IXSwC4+DWwFWiigFDOiNLALpYFdKA3sQmlgF0oDu1Aa2IXSwC6UBnahNLALpYFdKA3sQmlgF0oDu1Aa2IXSwC6UBnahNLCLTwM79/4CLet2BC0UUBsz+jiIvUG3/QhqY0YK1MaMFKiNGSlQGzMSoD4NbAVqY0YK1MaMFKiNGSnQQgGlmJFPA1uBUszIp4GtQClm5NPAVqAUM/JpYCtQihn5NLAVKMWMfBrYCpRiRj4NbPFc16eB/fGhwxu01+sXt5Jfn1+0j09lxIvTG7ClrR2W0CdRLP6j8EkUK1DKxuWTKFaglI3LJ1GsQClHep9EsQKlHOl9EsUKlGJGPoliBUoxI59EsQKlmJFPoliBQsyo+iSKFSjEjKpPoliBQsyoLoUCCjGj6pMoVqAQM6o+iWIFSjEjn0SxAqWYkU+iWIFC/ulQ9UkUq3eUYkY+iWIFSjEjn0SxAqWYkU+iWIFSzMgnUaxAKc+MfBLFCpRiRj6JYgVKMSOfRLECpZiRT6JYgVLMyCdRrEApZuSTKFagFDPySRQrUBszEs91fRLF6h2lmJFPoliBUszIJ1GsQClm5JMoVqAUM/JJFCtQyjMjn0SxAqWYkU+iWIFSzMgnUaxAKWbkkyhWoBQzoiSKKyVRXCmJ4kpJFFdKorj6JIrFc11KorhSEsWVkiiulERxpSSKKyVRXCmJ4kpJFFdKorhSEsWVkiiulERxpSSKKyVRXCmJ4kpJFFefRLECpZjRRjGjjWJGG8WMKA3sSmlgV58GtniuS2lgV0oDu1Ia2JXSwK6UBnalNLArpYFdKQ3sSmlgV0oDu1Ia2JXSwK6UBnalNLAbpYHdKA3sRmlgN0oDuy2FAgoxo0ZpYDdKA7tRGtjNp4F9/Vy3URrYjdLAbpQGdvNpYCvQQgGlmBGlgd0oDexGaWA3SgO7URrYjdLAbpQGdqM0sBulgd0oDexGaWA3SgO7URrYjdLAbpQGdqM0sBulgd18GtjiuS6lgd0oDexGaWA3nwa2AqWYEaWB3SgN7EZpYDdKA7tRGtiN0sBulAZ2ozSwG6WB3SgN7EZpYDdKA7tRGtiN0sBulAZ2ozSwG6WB3SgN7ObTwBbPdSkN7EZpYDdKA7v5NLAVKMWMKA3sRmlgN0oDu1Ea2I3SwG6UBnajNLAbpYHdKA3sRmlgN0oDu1Ea2I3SwG6UBnajNLAbpYHdKA3sRmlgN58GtniuS2lgN0oDu1Ea2M2nga1AKWZEaWA3SgO7URrYjdLAbpQGdqM0sBulgd0oDexGaWA3SgO7URrYjdLAbpQGdqc0sDulgd0pDexOaWD3pVBAIfemdUoDu1Ma2J3SwO4+DWwBSmlgd0oDu1Ma2J3SwO6UBnanNLA7pYHdKQ3sTmlgd0oDu1Ma2J3SwO6UBnanNLA7pYHdKQ3sTmlgd0oDu1Ma2N2ngS2e61Ia2J3SwO6UBnb3aWAr0EIBpZgRpYHdKQ3sTmlgd0oDu1Ma2J3SwO6UBnanNLA7pYHdKQ3sTmlgd0oDu1Ma2J3SwO6UBnanNLA7pYHdQzewPwZ+g+71OHuZePbI/qJmj6wkavbIlqFmjywOavbILiBmDx1yVrNH3rHV7JE3YTX7xPtq6Ciymn3ifTV0uljNPvG+GjowrGafeF8NnQFWs0+8r4aO9arZJ95XQyd11ewT76uhw7dq9on31dB5WjX7xPtq6Iismn3ifTV06lXNHnlfbevrGfZPlx8fZ4+8r6rZI++ravbI+6qaPfK+qmaPvK+q2SPvq2L20AlSNXvkfVXNHnlfVbNPvK+Gznmq2SfeV0NHN9XsE++rodOYavZ599UtdMBSzT7JebWVdpx9kvPq6eyTPAc+nT3yvqpmn+Q58OnskzwHPp19kufAp7NP8hz4dPZJngOfzR46f6hmn3hfDR0pVLNPvK+GTgmq2SfeV0MH/9TsE++robN8avbP21dPqi/bJ/bwTsdZY42TYo2TY41TYo1TY43TYo0z9vf9/qtxfv4O23f/Dvd/d7b6+u2cWt/Ekqb2XtK0fcvfGaTl+sW9l9dX7r3nw5s1oMU1CehKAU0U0OwCuuX2At1+esVvQQsFtFJAGwW0u4DuS32B7vn4IdWAFtckoDZmJECLjRkpUBsz2pe3MOxlOYLamJECtTEjBVoooDZmpEBtzEiBGpnRV6DlCGpkRtegRmZ0CVqNzOga1NOMTkB9zGh7feVtWdMR1MeMBGihgPqYkQD1MSMB6mNGAtTHjASojxldgzYfMxKgPmYkQClm1ChmNCC9NgkoxYwaxYwaxYwaxYwaxYy6jxn1dAnqY0YC1MeMBKiPGQnQQgH1MSMB6mNGAtTHjASojxkJUB8zugbdKGa0Ucxoo5jRRjGjAfnDGKDbUusbdF+PoC5mJEFdzOhr0HU9/ivQzcWMJKiLGUlQFzNSoLuLGUlQFzOSoC5mJEFdzEiCFgqooxmdglLMaKeY0U4xox1iRvsCMaN9gZjRvkDMaF8gZrQvxQf0/dH+mpcjqJEZXYMamdE1qJEZXYMamdE1qJEZXYKuRmZ0DWpkRtegRmZ0DWpkRteghQJKMaOVYkYrxYxWHzNK7RLUx4yuQZOPGQlQHzMSoD5mJEB9zEiAFgqojxkJUB8zEqA+ZiRAKWZk08BWoDYNbAlKMSObBrYEpZiRTQNbglLMyKaBLUEpZmTTwJagFDOyaWBva13foMe7JHabBvaW0uvFWyr9CGpjRgrUxowUaKGA2phRWusX0O0IamNGCtTGjPL7Cvst55MfXRszUqA2ZiRAbRrYEtTGjOrSX6C1rdcv/vjW+TXzvnwB/Om6w+OL1/5awrRu29cv/nkJbZzr+y1hKq/VSKnl6xeX9pqi7F+9dP9ltW3Eb4rVLs9q/8DVtlHg77ja2+uRRsrLfmu1bTx8itW2OQx8v9XO+/vW4pLKUTRsjhmft4Q2B5hPW0KbCP4nLuFz6Lq9hM+hSy5hfT9wTbVt1y9e23uMtaV6XO/n2PVj17s86z10vXt9feW193bHZG0uXjB8a54jXdi35jn/DX5r9teHb+u2brfemudcGfatYZ5X9y+rvZdVvDXi4xmbq0m+4xKOe4Rtcz/KHKvNPAV/22oPe4Rtc1PMHKtdntVWqy0ektlchPOJS8g8UQ5dQubJb+gSMk9oQ5fwOUnJJRz5ANvm3qNZ1vs5eI1d73GPPm0ujDJ8a54jXdi3pjxvzdi3ZthTaZ9rxPzeGuR5NS/vF+elLDdNCnleHbuEyPPqty3hwJ0SebT9rNX2ubZuitVGHmu/cbWH2YPPBX5TrLbP4XN/vXhrx/uVd59bBBWoz8Ho/TR9ayflIJ9bBBWoz2FAgPoo+96/gNYjqI8tX4GWxecWQQXq44gC1EfPBKiRGV2DFkvQ/QhqZEbXoEZmdA1qZEbXoJ5mdAJqY0atv49pfekHUJ9bBBWojRkpUBszUqA2ZqRACwXUxowUqI0ZKVAbM1KgNmakQClm5HOLoAKlmJHPLYIKlGJGPrcIKlCKGfncIqhAfczo/cn+OaiPGQlQHzO6BvW5RVCB+piRAPUxIwHqY0YCtFBAfcxIgPqYkQClmJHPLYIKlGJGPrcIKlAbM+rvmbe+tSOojRkpUBsz+gp0W9cjaKGA2piRArUxIwVqY0YK1MaMFKiNGQlQn1sEFaijGZ2COprRKSjFjHxuuFOgFDPyuddNgVLMyOfiMwVKMSOfS8QUqI8ZlfdH+1s6/ksmnwu5FKiPGQnQQgH1MSMB6mNGAtTHjASojxkJUB8zugb1ua5GgVLMyOeSFgVKMSOfq0kUqI8ZpfUS1MeMBKiPGQlQHzMSoD5mdA3qc6OEAvUxIwHqY0YC1MeMBGihgFLMyCcor0ApZuQTZ1egFDPySZIrUIoZ+YS4FSjFjHwa2AqUYkY+DWwFSjEjnwa2Ao1sRrV8Ad3E1Q1tL6+bRtreD/9kaw3dwB4KGtmMvgW0r+31o9vTko6gkc1oKGhkMxoKWlxAU+5v0CZ+RbeSX/fItFKTeHFqr8sbWjr+O8Y1dKL425Yw1fcS9nIEddm4FGjoRPFQUJuNS4HabFwK1GbjUqA+G5cAjXykHwoa+Ug/FDTykX4oKMWMQieKR4KGThQPBaWYUehE8VBQihmFThQPBaWYUehE8VBQihmFThQPBaWYUehE8VBQihmFThQPBaWYUehE8VBQihmFThSP/JwudKJ46DtKMaPQieKRoKETxUNBKWYUOlE8FJRiRqETxUNBKWYUOlE8FJRiRqETxUNBKWYUOlE8FJRiRqETxUNBKWYUOlE8FJRiRqETxUNBKWYUOlE8FJRiRqETxSOf64ZOFA99RylmFDpRPBS0UEApZhQ6UTwUlGJGoRPFQ0EpZhQ6UTwUlGJGoRPFQ0EpZhQ6UTwUlGJGoRPFQ0EpZhQ6UTwUlGJGoRPFQ0EpZhQ6UTwUlGJGoRPFI5/rhk4UD31HKWYUOlE8FJRiRqETxSNBQyeKh4JSzCh0ongoKMWMQieKh4JSzCh0ongoKMWMQieKh4JCzCjZJIolKMSMkk+iWIFCzCgthQIKMaO0QMwoLRAzSj4N7OvnuonSwE6UBnaiNLATpYGdKA3sRGlgJ0oDO1Ea2InSwE6UBnaiNLATpYGdKA3sRGlgJ0oDO1Ea2InSwE6UBnaiNLATpYGdKA3sRGlgJ0oDO/k0sMVzXUoDO1Ea2InSwE4+DWwFSjEjSgM7URrYidLATpQGdqI0sBOlgZ0oDexEaWAnSgM7URrYidLATpQGdqI0sBOlgZ0oDexEaWAnSgM7URrYyaeBLZ7rUhrYidLATpQGdvJpYCtQihlRGtiJ0sBOlAZ2ojSwE6WBnSgN7ERpYCdKAztRGtiJ0sBOlAZ2ojSwE6WBnSgN7ERpYCdKAztRGtiJ0sBOPg1s8VyX0sBOlAZ2ojSwk08DW4FSzIjSwE6UBnaiNLATpYGdKA3sRGlgJ0oDO1Ea2InSwE6UBnaiNLATpYGdKA3sRGlgZ0oDO1Ma2JnSwM6UBnZeCuO5bqY0sDOlgZ0pDezs08BWoBQzojSwM6WBnSkN7ExpYGdKAztTGtiZ0sDOlAZ2pjSwM6WBnSkN7ExpYGdKAztTGtiZ0sDOlAZ2pjSwM6WBnX0a2OK5LqWBnSkN7ExpYGefBrYCpZgRpYGdKQ3sTGlgZ0oDO1Ma2JnSwM6UBnamNLAzpYGdKQ3sTGlgZ0oDO1Ma2JnSwM6UBnamNLAzpYGdKQ3s7NPAFs91KQ3sTGlgZ0oDO/s0sBUoxYwoDexMaWBnSgM7UxrYmdLAzpQGdqY0sDOlgZ0pDexMaWBnSgM7UxrYmdLAzpQGdqY0sDOlgZ0pDexMaWBnnwZ27v0FWtbtCGpjRgrUxoxKeT+pL7/+yj+D2piRAPVpYCtQGzNSoDZmpEBtzEiBFgqojRkpUBszUqA2ZqRAKWbk08AWoD4NbAVKMSOfBrYCpZiRTwNbgVLMyKeBrUApZuTTwFagEDMqPg1sBWpjRtfPdYtPA7vU/Abt9frFreTX5xet1CRenNr2enHa2nEJIRtX8UkUK1DIxlV8EsUC1CdRrEAhR/rikyhWoJAjffFJFCtQyJG++CSKFSjFjHwSxQqUYkY+iWIFSjEjn0SxAqWYkU+iWIFSzMgnUaxAKWbkkyhWoBQz8kkUK1CKGfkkihUoxYx8EsUKlGJGPoli8cmrT6JYvaMUM/JJFAtQn0SxAqWYkU+iWIFSzMgnUaxAKWbkkyhWoBQz8kkUK1CKGfkkihUoxYx8EsUKlGJGPoliBUoxI59EsQKlmJFPoliBUszIJ1Esnuv6JIrVO0oxI59EsQItFFCKGfkkihUoxYx8EsUKlGJGPoliBUoxI59EsQKlmJFPoliBUszIJ1GsQClmREkUF0qiuFASxYWSKC6URHGhJIqLT6JYPNelJIoLJVFcKIniQkkUF0qiuFASxYWSKC6URHGhJIoLJVFcKIniQkkUF0qiuFASxYWSKK6URHH1SRQrUIgZ1QViRnUpFFCIGVVKA7tSGtjVp4F9/Vy3UhrYldLArpQGdqU0sCulgV0pDexKaWBXSgO7UhrYldLArpQGdqU0sCulgV0pDexKaWBXSgO7UhrYldLArpQGdqU0sCulgV0pDexKaWBXnwa2eK5LaWBXSgO7UhrY1aeBrUApZkRpYFdKA7tSGtiV0sCulAZ2pTSwK6WBXSkN7EppYFdKA7tSGtiV0sCulAZ2pTSwK6WBXSkN7EppYFdKA7v6NLDFc11KA7tSGtiV0sCuPg1sBUoxI0oDu1Ia2JXSwK6UBnalNLArpYFdKQ3sSmlgV0oDu1Ia2JXSwK6UBnalNLArpYFdKQ3sSmlgV0oDu1Ia2NWngS2e61Ia2JXSwK6UBnb1aWArUIoZURrYldLArpQGdqU0sCulgV0pDexKaWBXSgO7UhrYldLArpQGdqU0sCulgV0pDexGaWA3SgO7URrYjdLAbkthPNdtlAZ2ozSwG6WB3Xwa2AqUYkaUBnajNLAbpYHdKA3sRmlgN0oDu1Ea2I3SwG6UBnajNLAbpYHdKA3sRmlgN0oDu1Ea2I3SwG6UBnajNLCbTwNbPNelNLAbpYHdKA3s5tPAVqAUM6I0sBulgd0oDexGaWA3SgO7URrYjdLAbpQGdqM0sBulgd0oDexGaWA3SgO7URrYjdLAbpQGdqM0sBulgd18GtjiuS6lgd0oDexGaWA3nwa2AqWYEaWB3SgN7EZpYDdKA7tRGtiN0sBulAZ2ozSwG6WB3SgN7EZpYDdKA7tRGtiN0sBulAZ2ozSwG6WB3SgN7Ba6gf0x8Bt0r8fZI8uOmj2yv6jZIyuJmD10T1rNHlkc1OyRXUDNHnl7V7NH3rHV7JE3YTX7xPtq6Ciymn3ifTV0uljMHrpGrGafeF8N3QxWs0+8r4Yu+6rZJ95XQ/d31ewT76uhK7lq9nn31R66Zatmn3df7aGLs2r2effVvsy7r/bQqVc1e+R9ta2vZ9i5lZPZI++ravZJ9tVW2nH2SfbVs9lDl1DV7JPsq6ezT7Kvns4+yb56Ovsk++rp7JPsq6ezT3JePZ19kvPq6ewT76uho5ti9tAdTTX7xPtq6Nqlmn3ifTV0k1LNPvG+Groc2dqXM1/fjrOHPq+K2SPvq2r2yPuqmD10hVHNHnlfVbNH3lfV7JH3VTX72H11+9XsP3+H+t2/w/096uO57Os7fGzXYv1zf69/3r/leXBarl/ce3l95d57Pr5ZnQK6UUB3COiAhl8Q0C2/xujbT6/4LehKAU0U0EwBLS6g+1JfoHs+fhg4oOE3CaiNGSlQGzNSoDZmtC9vYdjLcgS1MSMBWm3MSIHamJECtTEjBWpjRgq0WIKWI6iRGV2DGpnRNaiRGV2DeprRCaiPGW2vr7wtazqANh8zEqA+ZiRAfcxIgPqYkQAtFFAfMxKgPmYkQH3MSID6mJEApZhRp5hRp5hRp5hRp5jRgIbfJKAUM+oUM+o+ZtTTJaiPGQlQHzO6Bt18zEiA+piRAPUxIwHqY0YCtFBAfcxIgPqYkQClmNFGMaONYkY7xYx2FzPallrfoPt6BHUxIwnqYkZfg67r8V/bDqhdTgLqYkYS1MWMJKiLGUlQFzOSoC5mJEC3xcWMJKijGZ2COprRKSjEjLalUEAhZrQtEDPaFogZbQvEjLaFYkYrxYxWIzN6f7S/5uUIamRG16BGZnQNWiigRmZ0DWpkRtegRmZ0DWpkRtegRmZ0CZqMzOgalGJGiWJGiWJGA5rBk4D6mFFql6A+ZiRAfcxIgPqYkQD1MaNr0OxjRgLUx4wEqI8ZCVAfMxKghQJKMSObBrYEpZiRTQNbglLMyKaBLUEpZmTTwJagFDOyaWBLUIoZ2TSwJaiNGa11fYMe75LYbBrYH585vF788bC6H0FtzEiA2jSwJaiNGSlQGzNKa/0Cuh1BbcxIgRYX0Ly+t5ecT350bcxIgdqYkQK1MSMFamNGdekv0NrW6xenbc+vmffly8zrdvbitb+WMK1fXSb48eKfl9DGub7fEqbyWo2UWr5+cWmvKcr+1Uv3n1fbJvE9x2rb2OcUq22jwN9xtbc3YF72W6tt4+FTrHZ5Vlutdt6314tLKgfRsAnKf+IS2hxgPm8JbY5Gn7eEz6Hr9hI+hy65hPX9wDXVtl2/eG3vMdaW6mG9be4PmGW9n4PX2PXu9fWV197bHZO1uXjB8K15jnRh35ryvDVj35r99eHbuq3brbfmOVeGfWuY59X9y2rvZRVvjfh4xuZqku+4hOMeYdvcjzLHajNPwd+22sMeYdvcFDPHajNPwN+02uIhmc1FOJ+4hMwT5dAlLM8S3l1C5glt6BI+Jym5hCMfYNvcezTLej8Hr7HrPe7Rp82FUX5vjc0VV4ZvzXP+G/zWDHsq7XONmN9bgzyv5uX94ryU5Z5J+Vyp9nlLiDyvftsSDtwpkUfbT1tt5MH201Ybeaz9xtUeZw/Ik+onrfbuc4tg3d9ph3a8X3n3uUVQgfocjN5P07d2LAftPrcIKtBCAfVR9r1/Aa1HUB9bFqA+oipAfRxRgPro2TWozy2CCtTIjL4C3Y+gRmZ0DWpkRteghQLqaUYnoDZm1Pr7mNaXfgS1MSMFamNGCtTGjASozy2CCtTGjBSojRkpUBszUqCFAmpjRgqUYkY+twgqUIoZ+dwiKEB9bhFUoBQz8rlFUIFSzMjnFsH2/mT/HNTHjASojxkJUB8zEqA+ZiRAfczoGtTnFkEF6mNGAtTHjASojxkJ0EIBpZiRzy2CCpRiRj63CPb3zFvf2hHUxowEqM8tgl+Bbut6BLUxIwVqY0YK1MaMFGihgNqYkQK1MSMFamNGCtTRjE5BHc3oDNTnmj0FSjEjn8vlFCjFjHyuVFOgFDPyuZ5MgVLMyOeqr17eH+1v6fgvmXwu5BKgPjdhKVAfMxKgPmYkQH3MSIAWCqiPGQlQHzMSoD5mJEApZuRzSYsA9bkfRYFSzMjnApGe1ktQHzMSoIUC6mNGAtTHjASojxkJUB8zEqA+ZnQN6nPNgAL1MSMBSjEjn6C8Ai0UUIoZ+XTRFSjFjHxq4AqUYUZ18WlgK1CGGX2AMszoA5RhRh+ghQLKMKMP0MhmVMsX0E1c3dDX9gLtaUlH0MhmNBQ0shkNBY1sRt8EmnJ/gzbxH3Qr+XXrSCs1iRen9kr9t3T4V291CZ0o/rYlTPW9hL0cQSNvXENBI29cQ0FtNi4FarNxKVCbjUuB+mxc16ChE8VDQSMf6YeCRj7SDwWlmFHoRPFQUIoZhU4UDwWlmFHoRPFQUIoZhU4UDwWlmFHoRPFQUIoZhU4UDwWlmFHoRPFQUIoZhU4UDwWlmFHoRPFQUBszEp/ThU4UD31HKWYUOlE8FJRiRqETxUNBKWYUOlE8FJRiRqETxUNBKc+MQieKh4JSzCh0ongoKMWMQieKh4JSzCh0ongoKMWMQieKh4JSzCh0ongoKMWMQieKh4LamJF4rhs6UTz0HaWYUehE8VBQihmFThQPBaWYUehE8VBQihmFThQPBaU8MwqdKB4KSjGj0InioaAUMwqdKB4KSjGj0InioaAUMwqdKB4KSjGj0InioaAUMwqdKB4KamNG4rlu6ETxyHc0dKJ4KCjFjEInioeCFgooxYxCJ4qHglLMKHSieCgo5JnRGjpRPBQUYkZr6ETxUFCIGa1LoYBCzGj1SRQrUIgZrT6JYgVKMaOVYkYrxYxWihn5NLCvn+uulAb2Smlgr5QG9kppYK+UBvZKaWCvlAb2Smlgr5QG9kppYK+UBvZKaWCvlAb2Smlgr5QG9kppYK+UBvZKaWCvlAb2Smlgr5QG9kppYK+UBvbq08AWz3UpDeyV0sBeKQ3s1aeBrUApZkRpYK+UBvZKaWCvlAb2Smlgr5QG9kppYK+UBvZKaWCvlAb2Smlgr5QG9kppYK+UBvZKaWCvlAb2Smlgr5QG9urTwBbPdSkN7JXSwF4pDezVp4GtQClmRGlgr5QG9kppYK+UBvZKaWCvlAb2Smlgr5QG9kppYK+UBvZKaWCvlAb2Smlgr5QG9kppYK+UBvZKaWCvlAb26tPAFs91KQ3sldLAXikN7NWngS1AKQ3sldLAXikN7JXSwF4pDeyV0sBeKQ3sldLAXikN7JXSwE6UBnaiNLATpYGdKA3stBQKKMSMEqWBnSgN7ERpYCefBvb1c91EaWAnSgM7URrYyaeBrUALBZRiRpQGdqI0sBOlgZ0oDexEaWAnSgM7URrYidLATpQGdqI0sBOlgZ0oDexEaWAnSgM7URrYidLATpQGdvJpYIvnupQGdqI0sBOlgZ18GtgKlGJGlAZ2ojSwE6WBnSgN7ERpYCdKAztRGtiJ0sBOlAZ2ojSwE6WBnSgN7ERpYCdKAztRGtiJ0sBOlAZ2ojSwk08DWzzXpTSwE6WBnSgN7OTTwFagFDOiNLATpYGdKA3sRGlgJ0oDO1Ea2InSwE6UBnaiNLATpYGdKA3sRGlgJ0oDO1Ea2InSwE6UBnaiNLATpYGdfBrYufcXaFm3I6iNGSlQGzMq5f2kvmz7EbRQQG3MSIHamJECtTEjBWpjRgrUxowEqE8DW4HamJECtTEjBUoxI58GtgKlmJFPA1uBUszIp4GtQCFmlH0a2AoUYkbZp4GtQCFmlJdCAYWYUfZpYF8/180+DexS8xu01+sXt5Jfn1+0UpN4cWrb68UfDxMPS+iTKBb/UfgkihUoZePySRQrUMrG5ZMoVqCQI332SRQrUMqR3idRrEApZuSTKFagFDPySRQrUIoZ+SSKFSjFjHwSxQqUYkY+iWIFSjEjn0SxAqWYkU+iWIFSzMgnUaxAKWbkkyhWoBQz8kkUK1DIPx3KPoli9Y5SzMgnUaxAKWbkkyhWoBQz8kkUK1CKGfkkihUo5ZmRT6JYgVLMyCdRrEApZuSTKFagFDPySRQrUIoZ+SSKFSjFjHwSxQqUYkY+iWIFamNG4rmuT6JYvaMUM/JJFCtQihn5JIoVKMWMfBLFCpRiRj6JYgVKeWbkkyhWoBQz8kkUK1CKGfkkihUoxYx8EsUKlGJGlERxpiSKMyVRnCmJ4kxJFGefRLF4rktJFGdKojhTEsWZkijOlERxpiSKMyVRnCmJ4kxJFGdKorhQEsWFkigulERxoSSKy1IooBAzKj6JYgUKMaOyQMyoLBQzWilmRGlgF0oDu/g0sK+f6xZKA7tQGtiF0sAulAZ2oTSwC6WBXSgN7EJpYBdKA7tQGtiF0sAulAZ2oTSwC6WBXSgN7EJpYBdKA7tQGtiF0sAulAZ2oTSwC6WBXSgN7OLTwBbPdSkN7EJpYBdKA7v4NLAVKMWMKA3sQmlgF0oDu1Aa2IXSwC6UBnahNLALpYFdKA3sQmlgF0oDu1Aa2IXSwC6UBnahNLALpYFdKA3sQmlgF58GtniuS2lgF0oDu1Aa2MWnga1AKWZEaWAXSgO7UBrYhdLALpQGdqE0sAulgV0oDexCaWAXSgO7UBrYhdLALpQGdqE0sAulgV0oDexCaWAXSgO7+DSwxXNdSgO7UBrYhdLALj4NbAFKaWAXSgO7UBrYhdLALpQGdqE0sAulgV0oDexCaWAXSgO7UhrYldLArpQGdqU0sOtSKKAQM6qUBnalNLArpYFdfRrY1891K6WBXSkN7EppYFefBrYCLRRQihlRGtiV0sCulAZ2pTSwK6WBXSkN7EppYFdKA7tSGtiV0sCulAZ2pTSwK6WBXSkN7EppYFdKA7tSGtjVp4EtnutSGtiV0sCulAZ29WlgK1CKGVEa2JXSwK6UBnalNLArpYFdKQ3sSmlgV0oDu1Ia2JXSwK6UBnalNLArpYFdKQ3sSmlgV0oDu1Ia2JXSwK4+DWzxXJfSwK6UBnalNLCrTwNbgVLMiNLArpQGdqU0sCulgV0pDexKaWBXSgO7UhrYldLArpQGdqU0sCulgV0pDexKaWBXSgO7UhrYldLArpQGdg3dwP4Y+A261+PskWVHzR7ZX9TsZeLZI1uGmj2yOKjZI7uAmj3y9q5mj7xji9lD55bV7BPvq6GjyGr2iffV0OliNfvE+2rowLCafeJ9NXQGWM0+777aQsd61ezz7qstdFJXzT7vvtqWeffVFrplq2afd19toYuzavZ599UWugsrZg+delWzR95XP6Z7zd7KyeyR91U1+yT7aivtOPsk++rp7JPsq6ezT7Kvns4+yb56Ovsk++rp7JPsq2ezhw6FqtknOa+ezj7JefV09on31dDRTTX7xPtq6DSmmn3ifTV0wFLNPvG+GjozqWb/vH315F+Ntk/sO56Ok2ONU2KNU2ON02KN02ONs8UaZ+zv+/yrcf7+HQYn7s6+w+nvzlxf/0slLe//nXS2SCntr1/OKa/p+sVrXl8vXnPexIuX1N6cvaoX59c/5V/Xvl4vyrpu7xVM5asX5zPAtb9XMC1f7T7llxVMzwreXMH8rODNFSzPCt5cwfqs4M0VbM8K3lzB/qzgzRXcnhW8uYL7s4L3VvA8vvis4Des4HMmubuCz5nk7go+Z5K7K1ieFby5gs+Z5O4KPmeSuyv4nEnuruBzJrm7gs+Z5OYKtudMcncFnzPJ3RV8ziR3V/A5k9xdwfKs4M0VfM4kd1fwOZPcXcHnTHJ3BZ8zyd0VfM4kN1ewP2eSuyv4nEnuruBzJrm7gs+Z5O4KlmcFb67gcya5u4LPmeTuCj5nkrsr+JxJ7q7gcya5uYLbcya5u4LPmeTuCj5nkrsr+JxJ7q5geVbw5go+Z5K7K/icSe6u4HMmubuCz5nk7go+Z5KbK7g/Z5K7K/icSe6u4HMmubuCz5nk7gqWZwVvruBzJrm7gs+Z5O4KPmeSuyv4nEnuruBzJrm3gn15ziR3V/A5k9xdwedMcncFnzPJ3RUszwreXMHnTHJ3BZ8zyd0VfM4kd1fwOZPcXcHnTHJzBdfnTHJ3BZ8zyd0VfM4kd1fwOZPcXcHyrODNFXzOJHdX8DmT3F3B50xydwWfM8ndFXzOJDdXMD1nkrsr+JxJ7q7gcya5u4LPmeTuCpZnBW+u4HMmubuCz5nk7go+Z5K7K/icSe6u4HMmubmC+TmT3F3B50xydwWfM8ndFXzOJHdXsDwreHMFnzPJ3RV8ziR3V/A5k9xdwedMcncFnzPJzRUsz5nk7go+Z5K7K/icSe6u4HMmubuC5VnBmyv4nEnuruBzJrm7gs+Z5O4KPmeSuyv4nEluruBzj/vtFXzOJHdX8DmT3F3B50xydwXLs4I3V/A5k9xdwedMcncFnzPJ3RV8ziR3V/A5k9xcwece99sr+JxJ7q7gcya5u4LPmeTuCpZnBW+u4HMmubuCz5nk7grePpP0N2fqRbx47Vt+jb4tyWMFt2cFb67g6ZnkG+dp+/9hnr9/i/sXnc/4JuV1e/++2tv1m5TT+str854Pb9H9a8656/fxP/zzv//pz3/+0//6H3/+67/84W9/+utf/uOn/8Xlp//jvBS0Luv6ZspfmNbt5Dv3pfzy2v7VDvbx0o937jyjM+7Lt/tfPr/e6o/PS3/75fuAL59eX77l33757ft++f3+l99ev9X63n/z5c+7FuO+/Hr7y2/v/zC38tufnPMiwjd++fr68rX99svn+1++v97a7bg4ZeCX33/zn9XH/7Be/Gr4+H33/g22bP9X/8VsS33t1tvSv/o53U+30lLf36D9emH/++N/+v/+8O9/+sM///mPP/0O++n/8z//8i+vX2kf/+Pf/v9/e/3/vH7p/du///Vf/viv//nvf/zp199Xv/l++vlN/fc5fSH++/9T/X1ePr7Tx3f73w==","file_map":{"6":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n","path":"std/cmp.nr"},"18":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        /*@safety: borrow is enforced to be boolean due to its type.\n            if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n            if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n        */\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            /*@safety: decomposition is properly checked below*/\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            unsafe {\n                //@safety: already unconstrained\n                field_less_than(b, a)\n            },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            //@safety: unsafe in unconstrained\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        unsafe {\n            //@safety: Take a hint of the comparison and verify it\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"19":{"source":"pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            //@safety : unconstrained context\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"26":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"62":{"source":"use commitment::nullify;\nuse compare_date_lib::{compare_date, get_birthdate};\n\nfn main(\n    comm_in: pub Field,\n    salt: Field,\n    private_nullifier: Field,\n    dg1: [u8; 95],\n    // The current date is public so verifiers can check the date\n    // provided to the proof is correct\n    current_date: pub str<8>,\n    // The minimum date required is public so verifiers can check\n    // the date provided to the proof is correct\n    // If the minimum date is a string of 1 (i.e. \"11111111\") it is not checked\n    min_date: pub str<8>,\n    // The maximum date required is public so verifiers can check\n    // the date provided to the proof is correct\n    // If the maximum date is a string of 1 (i.e. \"11111111\") it is not checked\n    max_date: pub str<8>,\n    service_scope: pub Field,\n    service_subscope: pub Field,\n) -> pub Field {\n    let birthdate = get_birthdate(dg1, current_date.as_bytes());\n    // Verify the birthdate of the ID holder\n    compare_date(birthdate, min_date.as_bytes(), max_date.as_bytes());\n    let nullifier = nullify(\n        comm_in,\n        salt,\n        dg1,\n        private_nullifier,\n        service_scope,\n        service_subscope,\n    );\n    nullifier\n}\n","path":"/Users/madztheo/Documents/Wagmi/Studio/RnD/Docaproof/Circuits/zk_id_check_circuits/src/noir/bin/compare/birthdate/src/main.nr"},"63":{"source":"use common::{calculate_scoped_nullifier, hash_salt_dg1_private_nullifier};\n\n/*\n############################################################\n# Circuit D\n############################################################\n# Generates a scoped nullifier that is scoped by service\n# Allows selective disclosure of dg1 via a reveal bitmask\n############################################################\n\n# Inputs/Outputs\n############################################################\ncomm_in             `assert comm_in == H(salt, dg1, private_nullifier)`\nsalt\ndg1\nprivate_nullifier\nservice_scope       `H(<domain_name>)`\nservice_subscope    `H(<purpose>)` (Service-specific subscope)\nscoped_nullifier    `H(private_nullifier, service_scope, service_subscope)`\n\n# Checks\n############################################################\n- Checks that dg1_reveal is the correct reveal of dg1 for the given dg1_mask\n- Constrains scoped_nullifier to be `H(private_nullifier, service_scope, service_subscope)`\n*/\npub fn nullify(\n    comm_in: Field,\n    salt: Field,\n    dg1: [u8; 95],\n    private_nullifier: Field,\n    service_scope: Field,\n    service_subscope: Field,\n) -> Field {\n    assert(comm_in == hash_salt_dg1_private_nullifier(salt, dg1, private_nullifier));\n    // println(f\"comm_in: {comm_in}\");\n    let scoped_nullifier =\n        calculate_scoped_nullifier(private_nullifier, service_scope, service_subscope);\n    // println(f\"scoped_nullifier: {scoped_nullifier}\");\n    scoped_nullifier\n}\n\n","path":"/Users/madztheo/Documents/Wagmi/Studio/RnD/Docaproof/Circuits/zk_id_check_circuits/src/noir/lib/commitment/scoped-nullifier/src/lib.nr"},"64":{"source":"//use std::hash::pedersen_hash;\nuse std::hash::poseidon2::Poseidon2;\nuse utils::PASSPORT_MRZ_COUNTRY_INDEX;\n\npub global CSC_CERT_TYPE: Field = 1;\npub global DSC_CERT_TYPE: Field = 2;\n\npub fn calculate_scoped_nullifier(\n    private_nullifier: Field,\n    service_scope: Field,\n    service_subscope: Field,\n) -> Field {\n    Poseidon2::hash([private_nullifier, service_scope, service_subscope], 3)\n}\n\npub fn calculate_certificate_registry_leaf<let N: u32>(\n    registry_id: Field,\n    cert_type: Field,\n    country: str<3>,\n    csc_pubkey: [u8; N],\n) -> Field {\n    let country_bytes: [u8; 3] = country.as_bytes();\n    let mut result: [Field; N + 5] = [0; N + 5];\n    result[0] = registry_id as Field;\n    result[1] = cert_type as Field;\n    result[2] = country_bytes[0] as Field;\n    result[3] = country_bytes[1] as Field;\n    result[4] = country_bytes[2] as Field;\n    for i in 0..N {\n        result[i + 5] = csc_pubkey[i] as Field;\n    }\n    Poseidon2::hash(result, N + 5)\n}\n\npub fn get_country_from_dg1(dg1: [u8; 95]) -> str<3> {\n    // There 5 padding bytes in the dg1 before the actual MRZ\n    let country_offset = 5 + PASSPORT_MRZ_COUNTRY_INDEX;\n    let mut country_bytes: [u8; 3] = [0; 3];\n    for i in 0..3 {\n        country_bytes[i] = dg1[country_offset + i];\n    }\n    country_bytes.as_str_unchecked()\n}\n\npub fn hash_salt_country_tbs<let TBS_MAX_SIZE: u32>(\n    salt: Field,\n    country: str<3>,\n    tbs: [u8; TBS_MAX_SIZE],\n) -> Field {\n    let country_bytes: [u8; 3] = country.as_bytes();\n    let mut result: [Field; TBS_MAX_SIZE + 4] = [0; TBS_MAX_SIZE + 4];\n    result[0] = salt as Field;\n    result[1] = country_bytes[0] as Field;\n    result[2] = country_bytes[1] as Field;\n    result[3] = country_bytes[2] as Field;\n    for i in 0..TBS_MAX_SIZE {\n        result[4 + i] = tbs[i] as Field;\n    }\n    Poseidon2::hash(result, TBS_MAX_SIZE + 4)\n}\n\npub fn hash_salt_dg1_private_nullifier<let N: u32>(\n    salt: Field,\n    dg1: [u8; N],\n    private_nullifier: Field,\n) -> Field {\n    let mut result: [Field; N + 2] = [0; N + 2];\n    result[0] = salt as Field;\n    for i in 0..N {\n        result[1 + i] = dg1[i] as Field;\n    }\n    result[1 + N] = private_nullifier;\n    Poseidon2::hash(result, N + 2)\n}\n\npub fn calculate_private_nullifier<let DG1: u32, let SIG: u32>(\n    dg1: [u8; DG1],\n    sod_sig: [u8; SIG],\n) -> Field {\n    let mut result: [Field; DG1 + SIG] = [0; DG1 + SIG];\n    for i in 0..DG1 {\n        result[i] = dg1[i] as Field;\n    }\n    for i in 0..SIG {\n        result[DG1 + i] = sod_sig[i] as Field;\n    }\n    Poseidon2::hash(result, DG1 + SIG)\n}\n\npub fn hash_salt_country_signed_attr_dg1_private_nullifier<let SA: u32>(\n    salt: Field,\n    country: str<3>,\n    signed_attr: [u8; SA],\n    signed_attr_size: Field,\n    dg1: [u8; 95],\n    private_nullifier: Field,\n) -> Field {\n    let country_bytes: [u8; 3] = country.as_bytes();\n    let mut result: [Field; SA + 101] = [0; SA + 101];\n    result[0] = salt as Field;\n    result[1] = country_bytes[0] as Field;\n    result[2] = country_bytes[1] as Field;\n    result[3] = country_bytes[2] as Field;\n    for i in 0..SA {\n        result[4 + i] = signed_attr[i] as Field;\n    }\n    result[4 + SA] = signed_attr_size;\n    for i in 0..95 {\n        result[4 + SA + 1 + i] = dg1[i] as Field;\n    }\n    result[4 + SA + 1 + 95] = private_nullifier;\n    Poseidon2::hash(result, SA + 101)\n}\n","path":"/Users/madztheo/Documents/Wagmi/Studio/RnD/Docaproof/Circuits/zk_id_check_circuits/src/noir/lib/commitment/common/src/lib.nr"},"65":{"source":"/**\n* The standards for passports and any other travel documents, electronic or not,\n* are defined in the ICAO (International Civil Aviation Organization) 9303 document available here:\n* https://www.icao.int/publications/pages/publication.aspx?docnum=9303\n*/\n\n/**\n* The structure of the MRZ is well defined and standardized by the ICAO\n* so the index will always be the same for every passport\n* c.f. ICAO 9303-4, Appendix B\n*/\n\n// The following constants define the indices of the information\n// we need to generate various proofs of identity from the MRZ\n// The structure of the MRZ is slightly different between passports\n// and ID cards so we need to define indices for both types\n\n// Index for the country of issuance of the passport\npub global PASSPORT_MRZ_COUNTRY_INDEX: u32 = 2;\n// Index for the three letter code of the country of citizenship\n// Note that the first three letter code (index 2) in the MRZ is the country of issuance\n// not citizenship. It is important to keep in mind for residence permits\n// where the issuing country differs from the citizenship country\npub global PASSPORT_MRZ_NATIONALITY_INDEX: u32 = 54;\n// Index for the gender of the passport holder (M, F or < if unspecified)\npub global PASSPORT_MRZ_GENDER_INDEX: u32 = 64;\n// Index for the date of expiry (YYMMDD)\npub global PASSPORT_MRZ_EXPIRY_DATE_INDEX: u32 = 65;\n// Index for the date of birth (YYMMDD) in TD1 (i.e. passport) MRZ\npub global PASSPORT_MRZ_BIRTHDATE_INDEX: u32 = 57;\n// Index for the document number in the MRZ\npub global PASSPORT_MRZ_DOCUMENT_NUMBER_INDEX: u32 = 44;\n// Index for the document type in the MRZ\npub global PASSPORT_MRZ_DOCUMENT_TYPE_INDEX: u32 = 0;\n// Index for the name of the passport holder\npub global PASSPORT_MRZ_NAME_INDEX: u32 = 5;\n// Length of the MRZ on a passport\npub global PASSPORT_MRZ_LENGTH: u32 = 88;\n\n// Index for the country of issuance of the ID card\npub global ID_CARD_MRZ_COUNTRY_INDEX: u32 = 2;\n// Note that the first three letter code (index 2) in the MRZ is the country of issuance\n// not citizenship. It is important to keep in mind for residence permits\n// where the issuing country differs from the citizenship country\npub global ID_CARD_MRZ_NATIONALITY_INDEX: u32 = 45;\n// Index for the gender of the passport holder (M, F or < if unspecified)\npub global ID_CARD_MRZ_GENDER_INDEX: u32 = 37;\n// Index for the date of expiry (YYMMDD)\npub global ID_CARD_MRZ_EXPIRY_DATE_INDEX: u32 = 38;\n// Index for the date of birth (YYMMDD) in TD3 (i.e. ID cards) MRZ\npub global ID_CARD_MRZ_BIRTHDATE_INDEX: u32 = 30;\n// Index for the document number in the MRZ\npub global ID_CARD_MRZ_DOCUMENT_NUMBER_INDEX: u32 = 5;\n// Index for the document type in the MRZ\npub global ID_CARD_MRZ_DOCUMENT_TYPE_INDEX: u32 = 0;\n// Index for the name of the passport holder\npub global ID_CARD_MRZ_NAME_INDEX: u32 = 60;\n// Length of the MRZ on an ID card\npub global ID_CARD_MRZ_LENGTH: u32 = 90;\n\n// ECDSA curves mapping\npub global ECDSA_CURVE_P256: u32 = 0;\npub global ECDSA_CURVE_P384: u32 = 1;\npub global ECDSA_CURVE_P521: u32 = 2;\npub global ECDSA_CURVE_BRAINPOOL_B256R1: u32 = 3;\npub global ECDSA_CURVE_BRAINPOOL_B256T1: u32 = 4;\npub global ECDSA_CURVE_BRAINPOOL_B384R1: u32 = 5;\npub global ECDSA_CURVE_BRAINPOOL_B384T1: u32 = 6;\npub global ECDSA_CURVE_BRAINPOOL_B512R1: u32 = 7;\npub global ECDSA_CURVE_BRAINPOOL_B512T1: u32 = 8;\n\npub struct IDData {\n    // Regroups the hashes of all the data groups plus some padding\n    // at the start and in between each data group hashes\n    pub e_content: [u8; 700],\n    pub e_content_size: u32,\n    // Where we can find e_content in the signed_attributes\n    // It varies from document to document according to the length\n    // of the padding at the start\n    pub dg1_offset_in_e_content: u32,\n    // Last 32 bytes: result of the hash of all the hashes of the data groups\n    // Rest of the bytes: information about the signature algorithm, date, etc.\n    pub signed_attributes: [u8; 200],\n    pub signed_attributes_size: u32,\n    // The DG1 contains the Machine Readable Zone (MRZ) of the document\n    // The two lines at the bottom of the passport data page\n    // or the three bottom lines on the rear of an ID card\n    // 95 bytes for passports, 93 bytes for ID cards\n    // Including 88 bytes of MRZ and 5 bytes of padding for passports\n    // and 90 bytes of MRZ and 5 bytes of padding for ID cards\n    pub dg1: [u8; 95],\n    // The signature over the data groups\n    pub sod_signature: [u8; 512],\n    pub sod_signature_size: u32,\n}\n\npub struct DSCData {\n    // The TBS certificate of the DSC\n    // TBS stands for To Be Signed\n    pub tbs_certificate: [u8; 1500],\n    pub tbs_certificate_size: u32,\n    // The public key of the DSC (up to 512 bytes to account for RSA-4096)\n    pub pubkey: [u8; 512],\n    // The actual size of the public key\n    pub pubkey_size: u32,\n    // The index of the public key in the TBS certificate\n    pub pubkey_index: u32,\n    // Data used to verify the signature\n    // Generated by the pre-compute function in Rust\n    // c.f. main.rs\n    pub pubkey_redc_param: [u8; 513],\n    // The signature over the TBS certificate\n    pub signature: [u8; 512],\n    pub signature_size: u32,\n    // The exponent of the public key\n    // Only useful for RSA, can be ignored for ECDSA\n    pub exponent: u32,\n}\n\npub struct CSCData {\n    // The public key of the CSC (up to 512 bytes to account for RSA-4096)\n    pub pubkey: [u8; 512],\n    // The actual size of the public key\n    pub pubkey_size: u32,\n    // Data used to verify the signature\n    // Generated by the pre-compute function in Rust\n    // c.f. main.rs\n    pub pubkey_redc_param: [u8; 513],\n    // Only useful for RSA, can be ignored for ECDSA\n    pub exponent: u32,\n}\n\npub struct DiscloseFlags {\n    pub issuing_country: bool,\n    pub nationality: bool,\n    pub document_type: bool,\n    pub document_number: bool,\n    pub date_of_expiry: bool,\n    pub date_of_birth: bool,\n    pub gender: bool,\n    pub name: bool,\n}\n\npub struct DisclosedData {\n    pub issuing_country: [u8; 3],\n    pub nationality: [u8; 3],\n    pub document_type: [u8; 2],\n    pub document_number: [u8; 9],\n    pub date_of_expiry: [u8; 6],\n    pub date_of_birth: [u8; 6],\n    pub name: [u8; 39],\n    pub gender: [u8; 1],\n}\n\npub fn get_array_slice<let N: u32, let M: u32>(arr: [u8; N], start: u32, end: u32) -> [u8; M] {\n    let mut slice = [0 as u8; M];\n    for i in start..end {\n        slice[i - start] = arr[i];\n    }\n    slice\n}\n\npub fn get_array_slice_constant<let N: u32, let M: u32>(arr: [u8; N]) -> [u8; M] {\n    let mut slice = [0 as u8; M];\n    for i in 0..M {\n        slice[i] = arr[i];\n    }\n    slice\n}\n\n// Reverse the bytes of an array so you can switch from\n// big endian to little endian order and vice versa\npub fn reverse_bytes_array<let N: u32>(arr: [u8; N]) -> [u8; N] {\n    let mut reversed_arr = [0 as u8; N];\n    for i in 0..N {\n        // Reverse\n        reversed_arr[i] = arr[N - 1 - i];\n    }\n    reversed_arr\n}\n\npub fn insert_into_array<let N: u32, let M: u32>(\n    mut arr: [u8; N],\n    sub_arr: [u8; M],\n    index: u32,\n) -> [u8; N] {\n    for i in index..index + M {\n        arr[i] = sub_arr[i - index];\n    }\n    arr\n}\n\npub fn dynamic_insert_into_array<let N: u32, let M: u32>(\n    mut arr: [u8; N],\n    sub_arr: [u8; M],\n    index: u32,\n    max_size: u32,\n) -> [u8; N] {\n    for i in index..index + max_size {\n        if i - index < M {\n            arr[i] = sub_arr[i - index];\n        }\n    }\n    arr\n}\n\npub fn is_id_card(dg1: [u8; 95]) -> bool {\n    // For passport, the last two bytes are 0\n    // since the real length is 93 for passports\n    // while it is 95 for ID cards\n    (dg1[93] != 0) & (dg1[94] != 0)\n}\n\npub fn from_byte_be_to_fields<let NBytes: u32, let N: u32>(x: [u8; NBytes]) -> [Field; N] {\n    let mut result = [0 as Field; N];\n\n    let mut limb: Field = 0;\n    let mut k = 0;\n    for _j in 0..(15 - (N * 15 - NBytes)) {\n        limb *= 256;\n        limb += x[k] as Field;\n        k += 1;\n    }\n    std::as_witness(limb);\n\n    result[N - 1] = limb;\n\n    for i in 1..N {\n        let mut limb: Field = 0;\n        for _j in 0..15 {\n            limb *= 256;\n            limb += x[k] as Field;\n            k += 1;\n        }\n        std::as_witness(limb);\n        result[N - i - 1] = limb;\n    }\n\n    result\n}\n\npub unconstrained fn __from_byte_be_to_fields<let NBytes: u32, let N: u32>(\n    x: [u8; NBytes],\n) -> [Field; N] {\n    from_byte_be_to_fields(x)\n}\n\npub fn get_mrz_from_dg1(dg1: [u8; 95]) -> [u8; 90] {\n    let mut mrz = [0 as u8; 90];\n    for i in 0..90 {\n        mrz[i] = dg1[i + 5];\n    }\n    mrz\n}\n\npub fn split_array<let N: u32>(array: [u8; N * 2]) -> ([u8; N], [u8; N]) {\n    let mut array_x = [0 as u8; N];\n    let mut array_y = [0 as u8; N];\n    for i in 0..N {\n        array_x[i] = array[i];\n        array_y[i] = array[i + N];\n    }\n    (array_x, array_y)\n}\n\npub fn concat_array<let N: u32>(array_x: [u8; N], array_y: [u8; N]) -> [u8; N * 2] {\n    let mut array = [0 as u8; N * 2];\n    for i in 0..N {\n        array[i] = array_x[i];\n        array[i + N] = array_y[i];\n    }\n    array\n}\n\npub fn check_zero_padding<let N: u32, T>(padded_array: [T; N], len: u32)\nwhere\n    T: Eq,\n    T: Default,\n{\n    for i in 0..N {\n        if i >= len {\n            assert_eq(padded_array[i], T::default());\n        }\n    }\n}\n\npub fn get_nationality_from_mrz(dg1: [u8; 95]) -> [u8; 3] {\n    let mrz = get_mrz_from_dg1(dg1);\n\n    let mut country_bytes: [u8; 3] = [0; 3];\n\n    if is_id_card(dg1) {\n        country_bytes = get_array_slice(\n            mrz,\n            ID_CARD_MRZ_NATIONALITY_INDEX,\n            ID_CARD_MRZ_NATIONALITY_INDEX + 3,\n        );\n    } else {\n        country_bytes = get_array_slice(\n            mrz,\n            PASSPORT_MRZ_NATIONALITY_INDEX,\n            PASSPORT_MRZ_NATIONALITY_INDEX + 3,\n        );\n    }\n\n    country_bytes\n}\n","path":"/Users/madztheo/Documents/Wagmi/Studio/RnD/Docaproof/Circuits/zk_id_check_circuits/src/noir/lib/utils/src/lib.nr"},"66":{"source":"use date::Date;\nuse utils::{\n    get_array_slice, get_mrz_from_dg1, ID_CARD_MRZ_BIRTHDATE_INDEX, ID_CARD_MRZ_EXPIRY_DATE_INDEX,\n    is_id_card, PASSPORT_MRZ_BIRTHDATE_INDEX, PASSPORT_MRZ_EXPIRY_DATE_INDEX,\n};\n\nfn get_date<let INDEX: u32>(dg1: [u8; 95], threshold_year_bytes: [u8; 8]) -> Date {\n    let mrz = get_mrz_from_dg1(dg1);\n\n    let date_bytes = get_array_slice(mrz, INDEX, INDEX + 6);\n\n    // Create a Date object from the date using the current date as\n    // the pivot year to differentiate between 20th and 21st centuries\n    // as the format is \"YYMMDD\"\n    Date::from_bytes_short_year(\n        date_bytes,\n        [threshold_year_bytes[2], threshold_year_bytes[3]],\n    )\n}\n\npub fn get_birthdate(dg1: [u8; 95], current_date: [u8; 8]) -> Date {\n    let mut birthdate = Date::new(1, 1, 1);\n\n    // Get the slice of the MRZ representing the birthdate\n    if is_id_card(dg1) {\n        birthdate = get_date::<ID_CARD_MRZ_BIRTHDATE_INDEX>(dg1, current_date);\n    } else {\n        birthdate = get_date::<PASSPORT_MRZ_BIRTHDATE_INDEX>(dg1, current_date);\n    }\n\n    birthdate\n}\n\npub fn get_expiry_date(dg1: [u8; 95], current_date: [u8; 8]) -> Date {\n    let mut expiry_date = Date::new(1, 1, 1);\n\n    // We base the threshold year for the expiry date on the current date plus 20 years\n    // As most documents will have a 10 year validity (and some maybe 15 years?)\n    // So with 20 years we should be safe\n    let threshold_year = Date::from_bytes_long_year(current_date).add_years(20);\n    let threshold_year_bytes = threshold_year.to_bytes();\n\n    // Get the slice of the MRZ representing the expiry date\n    if is_id_card(dg1) {\n        expiry_date = get_date::<ID_CARD_MRZ_EXPIRY_DATE_INDEX>(dg1, threshold_year_bytes);\n    } else {\n        expiry_date = get_date::<PASSPORT_MRZ_EXPIRY_DATE_INDEX>(dg1, threshold_year_bytes);\n    }\n\n    expiry_date\n}\n\npub fn compare_date(date_to_compare: Date, min_date_bytes: [u8; 8], max_date_bytes: [u8; 8]) {\n    assert((min_date_bytes != [49; 8]) | (max_date_bytes != [49; 8]));\n\n    let min_date = Date::from_bytes_long_year(min_date_bytes);\n    let max_date = Date::from_bytes_long_year(max_date_bytes);\n\n    if (min_date_bytes != [49; 8]) & (max_date_bytes == [49; 8]) {\n        // The minimum date is more likely to be inclusive, so we use gte\n        assert(date_to_compare.gte(min_date));\n    } else if (max_date_bytes != [49; 8]) & (min_date_bytes == [49; 8]) {\n        // The maximum date is more likely to be inclusive, so we use lte\n        assert(date_to_compare.lte(max_date));\n    } else {\n        assert(min_date.lte(max_date));\n\n        // Check if birthdate is within the range\n        assert(date_to_compare.gte(min_date));\n        assert(date_to_compare.lte(max_date));\n    }\n}\n","path":"/Users/madztheo/Documents/Wagmi/Studio/RnD/Docaproof/Circuits/zk_id_check_circuits/src/noir/lib/compare/date/src/lib.nr"},"67":{"source":"use dep::std::{field::bn254::assert_gt, println};\n\npub struct Date {\n    day: u8,\n    month: u8,\n    year: u32,\n}\n\nfn get_number_from_utf8_code(code: u8) -> u8 {\n    assert(code >= 48 & code <= 57);\n    code - 48\n}\n\nfn number_to_utf8_code(number: u8) -> u8 {\n    assert(number >= 0 & number <= 9);\n    number + 48\n}\n\nimpl Date {\n    pub fn new(year: u32, month: u8, day: u8) -> Self {\n        assert(month >= 1 & month <= 12);\n        assert(day >= 1 & day <= 31);\n        let date = Self { day: day, month: month, year: year };\n        assert(day <= date.get_days_in_month(month));\n        date\n    }\n\n    pub fn from_bytes_short_year(date: [u8; 6], threshold_year: [u8; 2]) -> Self {\n        let firstYearDigit = get_number_from_utf8_code(date[0]);\n        let secondYearDigit = get_number_from_utf8_code(date[1]);\n\n        let mut year: u32 = firstYearDigit as u32 * 10 + secondYearDigit as u32;\n\n        let firstMonthDigit = get_number_from_utf8_code(date[2]);\n        let secondMonthDigit = get_number_from_utf8_code(date[3]);\n\n        let month = firstMonthDigit * 10 + secondMonthDigit;\n\n        let firstDayDigit = get_number_from_utf8_code(date[4]);\n        let secondDayDigit = get_number_from_utf8_code(date[5]);\n\n        let day = firstDayDigit * 10 + secondDayDigit;\n\n        let currentYearFirstDigit = get_number_from_utf8_code(threshold_year[0]);\n        let currentYearSecondDigit = get_number_from_utf8_code(threshold_year[1]);\n\n        let mut currentYear: u32 =\n            currentYearFirstDigit as u32 * 10 + currentYearSecondDigit as u32;\n\n        // This way we have a smooth 100 years period according to a threshold year\n        // Taking the current year as threshold year (for birthdates for example)\n        // if the current year is 2023, then 24 will be interpreted as 1924\n        // while 22 will be interpreted as 2022\n        // A bit problematic for people over 100 years old\n        if year <= currentYear {\n            year += 2000;\n        } else {\n            year += 1900;\n        }\n\n        Self { day: day, month: month, year: year }\n    }\n\n    pub fn from_bytes_long_year(date: [u8; 8]) -> Self {\n        let firstYearDigit = get_number_from_utf8_code(date[0]);\n        let secondYearDigit = get_number_from_utf8_code(date[1]);\n        let thirdYearDigit = get_number_from_utf8_code(date[2]);\n        let fourthYearDigit = get_number_from_utf8_code(date[3]);\n\n        let year: u32 = firstYearDigit as u32 * 1000\n            + secondYearDigit as u32 * 100\n            + thirdYearDigit as u32 * 10\n            + fourthYearDigit as u32;\n\n        let firstMonthDigit = get_number_from_utf8_code(date[4]);\n        let secondMonthDigit = get_number_from_utf8_code(date[5]);\n\n        let month = firstMonthDigit * 10 + secondMonthDigit;\n\n        let firstDayDigit = get_number_from_utf8_code(date[6]);\n        let secondDayDigit = get_number_from_utf8_code(date[7]);\n\n        let day = firstDayDigit * 10 + secondDayDigit;\n\n        Self { day: day, month: month, year: year }\n    }\n\n    pub fn from_str_short_year(date: str<6>, threshold_year: str<2>) -> Self {\n        let date_bytes = date.as_bytes();\n        Date::from_bytes_short_year(date_bytes, threshold_year.as_bytes())\n    }\n\n    pub fn from_str_long_year(date: str<8>) -> Self {\n        let date_bytes = date.as_bytes();\n        Date::from_bytes_long_year(date_bytes)\n    }\n\n    pub fn get_duration_in_days(self: Self, other: Self, absolute: bool) -> i32 {\n        let totalDuration: i32 = self.get_duration_between_years(other) as i32\n            + self.get_duration_between_months(other) as i32\n            + (self.day as i32 - other.day as i32);\n\n        if (totalDuration < 0) & absolute {\n            -1 * totalDuration\n        }\n\n        totalDuration\n    }\n\n    pub fn gt(self: Self, other: Self) -> bool {\n        self.get_duration_in_days(other, false) > 0\n    }\n\n    pub fn lt(self: Self, other: Self) -> bool {\n        self.get_duration_in_days(other, false) < 0\n    }\n\n    pub fn eq(self: Self, other: Self) -> bool {\n        (self.day == other.day) & (self.month == other.month) & (self.year == other.year)\n    }\n\n    pub fn ne(self: Self, other: Self) -> bool {\n        !self.eq(other)\n    }\n\n    pub fn gte(self: Self, other: Self) -> bool {\n        self.get_duration_in_days(other, false) >= 0\n    }\n\n    pub fn lte(self: Self, other: Self) -> bool {\n        self.get_duration_in_days(other, false) <= 0\n    }\n\n    pub fn println(self: Self) {\n        let year = self.year;\n        let month = self.month;\n        let day = self.day;\n        // Let's write the date in the YYYY-MM-DD format\n        // since people don't agree on which format is best\n        // between MM/DD/YYYY and DD/MM/YYYY\n        if (month < 10) & (day < 10) {\n            println(f\"Date: {year}-0{month}-0{day}\");\n        } else if month < 10 {\n            println(f\"Date: {year}-0{month}-{day}\");\n        } else if day < 10 {\n            println(f\"Date: {year}-{month}-0{day}\");\n        } else {\n            println(f\"Date: {year}-{month}-{day}\");\n        }\n    }\n\n    pub fn to_bytes(self: Self) -> [u8; 8] {\n        let mut date: [u8; 8] = [0; 8];\n\n        let firstYearDigit = self.year / 1000;\n        let secondYearDigit = (self.year - firstYearDigit * 1000) / 100;\n        let thirdYearDigit = (self.year - firstYearDigit * 1000 - secondYearDigit * 100) / 10;\n        let fourthYearDigit =\n            self.year - firstYearDigit * 1000 - secondYearDigit * 100 - thirdYearDigit * 10;\n\n        date[0] = number_to_utf8_code(firstYearDigit as u8);\n        date[1] = number_to_utf8_code(secondYearDigit as u8);\n        date[2] = number_to_utf8_code(thirdYearDigit as u8);\n        date[3] = number_to_utf8_code(fourthYearDigit as u8);\n\n        let firstMonthDigit = self.month / 10;\n        let secondMonthDigit = self.month - firstMonthDigit * 10;\n\n        date[4] = number_to_utf8_code(firstMonthDigit as u8);\n        date[5] = number_to_utf8_code(secondMonthDigit as u8);\n\n        let firstDayDigit = self.day / 10;\n        let secondDayDigit = self.day - firstDayDigit * 10;\n\n        date[6] = number_to_utf8_code(firstDayDigit as u8);\n        date[7] = number_to_utf8_code(secondDayDigit as u8);\n\n        date\n    }\n\n    pub fn is_leap_year(self: Self) -> bool {\n        self.year % 4 == 0\n    }\n\n    pub fn get_days_in_month(self: Self, month: u8) -> u8 {\n        assert(month >= 1 & month <= 12);\n        if month == 2 {\n            if self.is_leap_year() {\n                29\n            } else {\n                28\n            }\n        } else {\n            if (month == 1)\n                | (month == 3)\n                | (month == 5)\n                | (month == 7)\n                | (month == 8)\n                | (month == 10)\n                | (month == 12) {\n                31\n            } else {\n                30\n            }\n        }\n    }\n\n    pub fn get_duration_between_months(self: Self, other: Self) -> i32 {\n        assert(self.month >= 1 & self.month <= 12);\n        assert(other.month >= 1 & other.month <= 12);\n        let mut duration: i32 = 0;\n        if (self.month < other.month) {\n            for month in 1..13 {\n                if month >= self.month & month < other.month {\n                    duration -= other.get_days_in_month(month) as i32;\n                }\n            }\n        } else {\n            for month in 1..13 {\n                if month >= other.month & month < self.month {\n                    duration += self.get_days_in_month(month) as i32;\n                }\n            }\n        }\n        duration\n    }\n\n    pub fn get_duration_between_years(self: Self, other: Self) -> i32 {\n        let mut duration: i32 = 0;\n        if (self.year < other.year) {\n            let previous_leap_year: u32 = other.year - (other.year % 4);\n            let mut leap_year_count: u32 = 0;\n            if self.year <= previous_leap_year {\n                leap_year_count = (previous_leap_year - self.year) / 4 + 1;\n            }\n            duration -= leap_year_count as i32 * 366;\n            duration -=\n                (other.year as i32 - self.year as i32 - leap_year_count as i32) as i32 * 365;\n        } else if (self.year > other.year) {\n            let next_leap_year: u32 = other.year + (4 - other.year % 4);\n            let mut leap_year_count: u32 = 0;\n            if self.year > next_leap_year {\n                // Fixes a weird bug where the line below triggers a fail constraint\n                // while self.year is greater than next_leap_year\n                assert_gt(self.year as Field, next_leap_year as Field);\n                leap_year_count = ((self.year - 1) - next_leap_year) / 4 + 1;\n            }\n            duration += leap_year_count as i32 * 366;\n            duration +=\n                (self.year as i32 - other.year as i32 - leap_year_count as i32) as i32 * 365;\n        }\n        duration\n    }\n\n    pub fn add_years(self: Self, years: u32) -> Self {\n        Self { day: self.day, month: self.month, year: self.year + years }\n    }\n\n    pub fn sub_years(self: Self, years: u32) -> Self {\n        Self { day: self.day, month: self.month, year: self.year - years }\n    }\n\n    pub fn add_months(self: Self, months: u32) -> Self {\n        let mut newMonth = self.month as u32 + months;\n        let mut newYear = self.year;\n        let yearToAdd = (newMonth - 1) / 12;\n        if newMonth > 12 {\n            newYear += yearToAdd as u32;\n            newMonth -= 12 * yearToAdd;\n        }\n        Self { day: self.day, month: newMonth as u8, year: newYear }\n    }\n\n    pub fn sub_months(self: Self, months: u32) -> Self {\n        let mut newMonth = self.month as i32 - months as i32;\n        let mut newYear = self.year;\n        if newMonth < 1 {\n            let yearToSub = ((newMonth as i32 - 12 as i32) * -1) / 12;\n            newYear -= yearToSub as u32;\n            newMonth += 12 * yearToSub;\n        }\n        Self { day: self.day, month: newMonth as u8, year: newYear }\n    }\n\n    pub fn add_days(self: Self, days: u32) -> Self {\n        let mut newDay = self.day as u32 + days;\n        let mut newMonth = self.month as u32;\n        let mut newYear = self.year;\n        let mut date = Self { day: newDay as u8, month: newMonth as u8, year: newYear };\n        if newDay > self.get_days_in_month(self.month) as u32 {\n            let max_months = (newDay / 30) + 1;\n            let bound = self.month + max_months as u8;\n            for _ in self.month..bound {\n                let days_in_month = date.get_days_in_month(newMonth as u8) as u32;\n                if newDay > days_in_month {\n                    newDay -= days_in_month;\n                    newMonth += 1;\n                    if newMonth > 12 {\n                        newYear += 1;\n                        newMonth = 1;\n                    }\n                    // We need to mutate the date object inside the loop\n                    // so we can use get_days_in_month properly\n                    date.day = newDay as u8;\n                    date.year = newYear;\n                    date.month = newMonth as u8;\n                }\n            }\n        }\n        date\n    }\n\n    // Performance could be improved\n    pub fn sub_days(self: Self, days: u32) -> Self {\n        let mut newDay = self.day as i32 - days as i32;\n        let mut newMonth = self.month as i32;\n        let mut newYear = self.year;\n        let mut date = Self { day: newDay as u8, month: newMonth as u8, year: newYear };\n        if newDay < 1 {\n            let max_months = (self.day as u32 + days) / 30 + 1;\n            let bound = self.month + max_months as u8;\n            for _ in self.month..bound {\n                let days_in_month = date.get_days_in_month(newMonth as u8) as i32;\n                if newDay < 1 {\n                    newDay += days_in_month;\n                    newMonth -= 1;\n                    if newMonth < 1 {\n                        newYear -= 1;\n                        newMonth = 12;\n                    }\n                    // We need to mutate the date object inside the loop\n                    // so we can use get_days_in_month properly\n                    date.day = newDay as u8;\n                    date.year = newYear;\n                    date.month = newMonth as u8;\n                }\n            }\n        }\n        date\n    }\n}\n\n#[test]\nfn test_date_init() {\n    let date = Date::new(2023, 12, 19);\n\n    assert(date.day == 19);\n    assert(date.month == 12);\n    assert(date.year == 2023);\n}\n\n#[test]\nfn test_date_from_bytes_short_year() {\n    let date = Date::from_bytes_short_year([50, 51, 49, 50, 49, 57], [50, 52]);\n\n    assert(date.day == 19);\n    assert(date.month == 12);\n    assert(date.year == 2023);\n}\n\n#[test]\nfn test_date_from_bytes_long_year() {\n    let date = Date::from_bytes_long_year([50, 48, 50, 51, 49, 50, 49, 57]);\n\n    assert(date.day == 19);\n    assert(date.month == 12);\n    assert(date.year == 2023);\n}\n\n#[test]\nfn test_date_from_str_short_year() {\n    let date = Date::from_str_short_year(\"231219\", \"24\");\n\n    assert(date.day == 19);\n    assert(date.month == 12);\n    assert(date.year == 2023);\n}\n\n#[test]\nfn test_date_from_str_long_year() {\n    let date = Date::from_str_long_year(\"20231219\");\n\n    assert(date.day == 19);\n    assert(date.month == 12);\n    assert(date.year == 2023);\n}\n\n#[test]\nfn test_date_to_bytes() {\n    let date = Date::new(2023, 12, 19);\n\n    let date_bytes = date.to_bytes();\n\n    assert(date_bytes[0] == 50);\n    assert(date_bytes[1] == 48);\n    assert(date_bytes[2] == 50);\n    assert(date_bytes[3] == 51);\n    assert(date_bytes[4] == 49);\n    assert(date_bytes[5] == 50);\n    assert(date_bytes[6] == 49);\n    assert(date_bytes[7] == 57);\n}\n\n#[test]\nfn test_date_is_leap_year() {\n    let date = Date::new(2023, 12, 19);\n\n    assert(date.is_leap_year() == false);\n\n    let date = Date::new(2024, 12, 19);\n\n    assert(date.is_leap_year() == true);\n}\n\n#[test]\nfn test_date_get_days_in_month() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(date.get_days_in_month(1) == 31);\n    assert(date.get_days_in_month(2) == 28);\n    assert(date.get_days_in_month(3) == 31);\n    assert(date.get_days_in_month(4) == 30);\n    assert(date.get_days_in_month(5) == 31);\n    assert(date.get_days_in_month(6) == 30);\n    assert(date.get_days_in_month(7) == 31);\n    assert(date.get_days_in_month(8) == 31);\n    assert(date.get_days_in_month(9) == 30);\n    assert(date.get_days_in_month(10) == 31);\n    assert(date.get_days_in_month(11) == 30);\n    assert(date.get_days_in_month(12) == 31);\n\n    let date = Date::new(2024, 1, 1);\n\n    assert(date.get_days_in_month(1) == 31);\n    assert(date.get_days_in_month(2) == 29);\n    assert(date.get_days_in_month(3) == 31);\n    assert(date.get_days_in_month(4) == 30);\n    assert(date.get_days_in_month(5) == 31);\n    assert(date.get_days_in_month(6) == 30);\n    assert(date.get_days_in_month(7) == 31);\n    assert(date.get_days_in_month(8) == 31);\n    assert(date.get_days_in_month(9) == 30);\n    assert(date.get_days_in_month(10) == 31);\n    assert(date.get_days_in_month(11) == 30);\n    assert(date.get_days_in_month(12) == 31);\n}\n\n#[test]\nfn test_date_get_duration_between_months() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(Date::new(2023, 1, 1).get_duration_between_months(date) == 0);\n    assert(Date::new(2023, 2, 1).get_duration_between_months(date) == 31);\n    assert(Date::new(2023, 3, 1).get_duration_between_months(date) == 59);\n    assert(Date::new(2023, 4, 1).get_duration_between_months(date) == 90);\n    assert(Date::new(2023, 5, 1).get_duration_between_months(date) == 120);\n    assert(Date::new(2023, 6, 1).get_duration_between_months(date) == 151);\n    assert(Date::new(2023, 7, 1).get_duration_between_months(date) == 181);\n    assert(Date::new(2023, 8, 1).get_duration_between_months(date) == 212);\n    assert(Date::new(2023, 9, 1).get_duration_between_months(date) == 243);\n    assert(Date::new(2023, 10, 1).get_duration_between_months(date) == 273);\n    assert(Date::new(2023, 11, 1).get_duration_between_months(date) == 304);\n    assert(Date::new(2023, 12, 1).get_duration_between_months(date) == 334);\n}\n\n#[test]\nfn test_date_get_duration_between_years() {\n    let date = Date::new(2023, 1, 1);\n\n    // Positive duration\n    assert(Date::new(2023, 1, 1).get_duration_between_years(date) == 0);\n    assert(Date::new(2024, 1, 1).get_duration_between_years(date) == 365);\n    assert(Date::new(2025, 1, 1).get_duration_between_years(date) == 731);\n    assert(Date::new(2026, 1, 1).get_duration_between_years(date) == 1096);\n    assert(Date::new(2027, 1, 1).get_duration_between_years(date) == 1461);\n    assert(Date::new(2028, 1, 1).get_duration_between_years(date) == 1826);\n    assert(Date::new(2029, 1, 1).get_duration_between_years(date) == 2192);\n    assert(Date::new(2030, 1, 1).get_duration_between_years(date) == 2557);\n    assert(Date::new(2031, 1, 1).get_duration_between_years(date) == 2922);\n    assert(Date::new(2032, 1, 1).get_duration_between_years(date) == 3287);\n    assert(Date::new(2033, 1, 1).get_duration_between_years(date) == 3653);\n    assert(Date::new(2034, 1, 1).get_duration_between_years(date) == 4018);\n\n    // Negative duration\n    assert(Date::new(2022, 1, 1).get_duration_between_years(date) == -365);\n    assert(Date::new(2021, 1, 1).get_duration_between_years(date) == -730);\n    assert(Date::new(2020, 1, 1).get_duration_between_years(date) == -1096);\n    assert(Date::new(2019, 1, 1).get_duration_between_years(date) == -1461);\n    assert(Date::new(2018, 1, 1).get_duration_between_years(date) == -1826);\n    assert(Date::new(2017, 1, 1).get_duration_between_years(date) == -2191);\n    assert(Date::new(2016, 1, 1).get_duration_between_years(date) == -2557);\n    assert(Date::new(2015, 1, 1).get_duration_between_years(date) == -2922);\n    assert(Date::new(2014, 1, 1).get_duration_between_years(date) == -3287);\n    assert(Date::new(2013, 1, 1).get_duration_between_years(date) == -3652);\n    assert(Date::new(2012, 1, 1).get_duration_between_years(date) == -4018);\n}\n\n#[test]\nfn test_date_get_duration_in_days() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(Date::new(2023, 1, 1).get_duration_in_days(date, false) == 0);\n    assert(Date::new(2023, 1, 15).get_duration_in_days(date, false) == 14);\n    assert(Date::new(2023, 2, 1).get_duration_in_days(date, false) == 31);\n    assert(Date::new(2023, 2, 15).get_duration_in_days(date, false) == 45);\n    assert(Date::new(2023, 3, 1).get_duration_in_days(date, false) == 59);\n    assert(Date::new(2023, 12, 31).get_duration_in_days(date, false) == 364);\n    assert(Date::new(2024, 1, 1).get_duration_in_days(date, false) == 365);\n    assert(Date::new(2024, 12, 31).get_duration_in_days(date, false) == 365 + 365);\n    assert(Date::new(2025, 1, 1).get_duration_in_days(date, false) == 365 + 366);\n}\n\n#[test]\nfn test_date_eq() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(date.eq(Date::new(2023, 1, 1)));\n    assert(!date.eq(Date::new(2023, 1, 2)));\n}\n\n#[test]\nfn test_date_ne() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(!date.ne(Date::new(2023, 1, 1)));\n    assert(date.ne(Date::new(2023, 1, 2)));\n}\n\n#[test]\nfn test_date_gt() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(!date.gt(Date::new(2023, 1, 1)));\n    assert(!date.gt(Date::new(2023, 1, 2)));\n    assert(date.gt(Date::new(2022, 12, 31)));\n}\n\n#[test]\nfn test_date_lt() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(!date.lt(Date::new(2023, 1, 1)));\n    assert(!date.lt(Date::new(2022, 12, 31)));\n    assert(date.lt(Date::new(2023, 1, 2)));\n}\n\n#[test]\nfn test_date_gte() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(date.gte(Date::new(2023, 1, 1)));\n    assert(!date.gte(Date::new(2023, 1, 2)));\n    assert(date.gte(Date::new(2022, 12, 31)));\n}\n\n#[test]\nfn test_date_lte() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(date.lte(Date::new(2023, 1, 1)));\n    assert(!date.lte(Date::new(2022, 12, 31)));\n    assert(date.lte(Date::new(2023, 1, 2)));\n}\n\n#[test]\nfn test_date_add_years() {\n    let date = Date::new(2023, 7, 14);\n\n    assert(date.add_years(0).eq(Date::new(2023, 7, 14)));\n    assert(date.add_years(1).eq(Date::new(2024, 7, 14)));\n    assert(date.add_years(2).eq(Date::new(2025, 7, 14)));\n    assert(date.add_years(3).eq(Date::new(2026, 7, 14)));\n    assert(date.add_years(4).eq(Date::new(2027, 7, 14)));\n    assert(date.add_years(5).eq(Date::new(2028, 7, 14)));\n}\n\n#[test]\nfn test_date_sub_years() {\n    let date = Date::new(2023, 7, 14);\n\n    assert(date.sub_years(0).eq(Date::new(2023, 7, 14)));\n    assert(date.sub_years(1).eq(Date::new(2022, 7, 14)));\n    assert(date.sub_years(2).eq(Date::new(2021, 7, 14)));\n    assert(date.sub_years(3).eq(Date::new(2020, 7, 14)));\n    assert(date.sub_years(4).eq(Date::new(2019, 7, 14)));\n    assert(date.sub_years(5).eq(Date::new(2018, 7, 14)));\n}\n\n#[test]\nfn test_date_add_months() {\n    let date = Date::new(2023, 7, 14);\n\n    assert(date.add_months(0).eq(Date::new(2023, 7, 14)));\n    assert(date.add_months(1).eq(Date::new(2023, 8, 14)));\n    assert(date.add_months(2).eq(Date::new(2023, 9, 14)));\n\n    assert(date.add_months(6).eq(Date::new(2024, 1, 14)));\n    assert(date.add_months(7).eq(Date::new(2024, 2, 14)));\n    assert(date.add_months(8).eq(Date::new(2024, 3, 14)));\n\n    assert(date.add_months(17).eq(Date::new(2024, 12, 14)));\n    assert(date.add_months(18).eq(Date::new(2025, 1, 14)));\n\n    assert(date.add_months(29).eq(Date::new(2025, 12, 14)));\n    assert(date.add_months(30).eq(Date::new(2026, 1, 14)));\n}\n\n#[test]\nfn test_date_sub_months() {\n    let date = Date::new(2023, 7, 14);\n\n    assert(date.sub_months(0).eq(Date::new(2023, 7, 14)));\n    assert(date.sub_months(1).eq(Date::new(2023, 6, 14)));\n    assert(date.sub_months(2).eq(Date::new(2023, 5, 14)));\n\n    assert(date.sub_months(6).eq(Date::new(2023, 1, 14)));\n    assert(date.sub_months(7).eq(Date::new(2022, 12, 14)));\n    assert(date.sub_months(8).eq(Date::new(2022, 11, 14)));\n\n    assert(date.sub_months(17).eq(Date::new(2022, 2, 14)));\n    assert(date.sub_months(18).eq(Date::new(2022, 1, 14)));\n    assert(date.sub_months(19).eq(Date::new(2021, 12, 14)));\n\n    assert(date.sub_months(30).eq(Date::new(2021, 1, 14)));\n    assert(date.sub_months(31).eq(Date::new(2020, 12, 14)));\n\n    assert(date.sub_months(41).eq(Date::new(2020, 2, 14)));\n    assert(date.sub_months(42).eq(Date::new(2020, 1, 14)));\n    assert(date.sub_months(43).eq(Date::new(2019, 12, 14)));\n}\n\n#[test]\nfn test_date_add_days() {\n    let date = Date::new(2023, 7, 14);\n\n    assert(date.add_days(0).eq(Date::new(2023, 7, 14)));\n    assert(date.add_days(1).eq(Date::new(2023, 7, 15)));\n    assert(date.add_days(2).eq(Date::new(2023, 7, 16)));\n\n    assert(date.add_days(17).eq(Date::new(2023, 7, 31)));\n    assert(date.add_days(18).eq(Date::new(2023, 8, 1)));\n    assert(date.add_days(19).eq(Date::new(2023, 8, 2)));\n\n    assert(date.add_days(31).eq(Date::new(2023, 8, 14)));\n    assert(date.add_days(32).eq(Date::new(2023, 8, 15)));\n    assert(date.add_days(33).eq(Date::new(2023, 8, 16)));\n\n    assert(date.add_days(365).eq(Date::new(2024, 7, 13)));\n    assert(date.add_days(366).eq(Date::new(2024, 7, 14)));\n    assert(date.add_days(367).eq(Date::new(2024, 7, 15)));\n\n    assert(date.add_days(365 + 365).eq(Date::new(2025, 7, 13)));\n    assert(date.add_days(365 + 366).eq(Date::new(2025, 7, 14)));\n    assert(date.add_days(365 + 367).eq(Date::new(2025, 7, 15)));\n\n    assert(date.add_days(365 + 366 + 364).eq(Date::new(2026, 7, 13)));\n    assert(date.add_days(365 + 366 + 365).eq(Date::new(2026, 7, 14)));\n    assert(date.add_days(365 + 366 + 366).eq(Date::new(2026, 7, 15)));\n\n    // After 4 regular years and 2 leap years\n    assert(date.add_days(365 * 4 + 366 * 2 - 1).eq(Date::new(2029, 7, 13)));\n    assert(date.add_days(365 * 4 + 366 * 2).eq(Date::new(2029, 7, 14)));\n    assert(date.add_days(365 * 4 + 366 * 2 + 1).eq(Date::new(2029, 7, 15)));\n}\n\n#[test]\nfn test_date_sub_days() {\n    let date = Date::new(2023, 7, 14);\n\n    assert(date.sub_days(0).eq(Date::new(2023, 7, 14)));\n    assert(date.sub_days(1).eq(Date::new(2023, 7, 13)));\n    assert(date.sub_days(2).eq(Date::new(2023, 7, 12)));\n\n    assert(date.sub_days(17).eq(Date::new(2023, 6, 28)));\n    assert(date.sub_days(18).eq(Date::new(2023, 6, 27)));\n    assert(date.sub_days(19).eq(Date::new(2023, 6, 26)));\n\n    assert(date.sub_days(31).eq(Date::new(2023, 6, 14)));\n    assert(date.sub_days(32).eq(Date::new(2023, 6, 13)));\n    assert(date.sub_days(33).eq(Date::new(2023, 6, 12)));\n\n    assert(date.sub_days(365).eq(Date::new(2022, 7, 14)));\n    assert(date.sub_days(366).eq(Date::new(2022, 7, 13)));\n    assert(date.sub_days(367).eq(Date::new(2022, 7, 12)));\n\n    assert(date.sub_days(365 + 365).eq(Date::new(2021, 7, 14)));\n    assert(date.sub_days(365 + 366).eq(Date::new(2021, 7, 13)));\n    assert(date.sub_days(365 + 367).eq(Date::new(2021, 7, 12)));\n\n    assert(date.sub_days(365 + 365 + 365).eq(Date::new(2020, 7, 14)));\n    assert(date.sub_days(365 + 365 + 366).eq(Date::new(2020, 7, 13)));\n    assert(date.sub_days(365 + 365 + 367).eq(Date::new(2020, 7, 12)));\n\n    // After 5 regular years and 1 leap year\n    assert(date.sub_days(365 * 5 + 366 - 1).eq(Date::new(2017, 7, 15)));\n    assert(date.sub_days(365 * 5 + 366).eq(Date::new(2017, 7, 14)));\n    assert(date.sub_days(365 * 5 + 366 + 1).eq(Date::new(2017, 7, 13)));\n\n    // After 6 regular years and 2 leap years\n    assert(date.sub_days(365 * 6 + 366 * 2 - 1).eq(Date::new(2015, 7, 15)));\n    assert(date.sub_days(365 * 6 + 366 * 2).eq(Date::new(2015, 7, 14)));\n    assert(date.sub_days(365 * 6 + 366 * 2 + 1).eq(Date::new(2015, 7, 13)));\n}\n\n#[test]\nfn test_date_age() {\n    let birthdate = Date::new(1995, 4, 13);\n\n    // Add 18 years to the birthdate\n    // to get the date when the person is 18 years old\n    let majority_date = birthdate.add_years(18);\n\n    // Make sure the majority date is correct\n    assert(majority_date.eq(Date::new(2013, 4, 13)));\n\n    // Compare the majority date to the current date\n    // to see if the person is 18 years old\n    assert(majority_date.lte(Date::new(2023, 12, 20)));\n}\n","path":"/Users/madztheo/nargo/github.com/madztheo/noir-date.git/0.4.3/src/lib.nr"}},"names":["main"],"brillig_names":["decompose_hint","lte_hint","directive_invert","directive_integer_quotient"]}