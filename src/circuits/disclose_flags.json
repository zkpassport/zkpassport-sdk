{"noir_version":"1.0.0-beta.1+03b58fa2dfcc8acc8cf5198b1b23b55676fbdb02","hash":3382626065828878246,"abi":{"parameters":[{"name":"comm_in","type":{"kind":"field"},"visibility":"public"},{"name":"salt","type":{"kind":"field"},"visibility":"private"},{"name":"private_nullifier","type":{"kind":"field"},"visibility":"private"},{"name":"dg1","type":{"kind":"array","length":95,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"disclose_flags","type":{"kind":"struct","path":"utils::DiscloseFlags","fields":[{"name":"issuing_country","type":{"kind":"boolean"}},{"name":"nationality","type":{"kind":"boolean"}},{"name":"document_type","type":{"kind":"boolean"}},{"name":"document_number","type":{"kind":"boolean"}},{"name":"date_of_expiry","type":{"kind":"boolean"}},{"name":"date_of_birth","type":{"kind":"boolean"}},{"name":"gender","type":{"kind":"boolean"}},{"name":"name","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"service_scope","type":{"kind":"field"},"visibility":"public"},{"name":"service_subscope","type":{"kind":"field"},"visibility":"public"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"struct","path":"utils::DisclosedData","fields":[{"name":"issuing_country","type":{"kind":"array","length":3,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"nationality","type":{"kind":"array","length":3,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"document_type","type":{"kind":"array","length":2,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"document_number","type":{"kind":"array","length":9,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"date_of_expiry","type":{"kind":"array","length":6,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"date_of_birth","type":{"kind":"array","length":6,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"name","type":{"kind":"array","length":39,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"gender","type":{"kind":"array","length":1,"type":{"kind":"integer","sign":"unsigned","width":8}}}]},{"kind":"field"}]},"visibility":"public"},"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"}}},"bytecode":"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","debug_symbols":"7d3bil7XcgXgd9G1L/5ZVfPkVwlh4+NGYGzjQyAYv3uWHcnb4FOSuQkfybxTq1e3SqNhoFrio3548+lnH3//97+9/fLzr7598+G//PDmi68++ei7t199+Xz0w5v2yp9/89uvP/ryp4+//e6jb75782H2/cGbz7789PnVXj9+8Obzt1989ubDET9+8JtHW77au2dbtvGPh8fvPDxH5LuH58j+j4f7j//6wTNMScN0aZjxvztMvX4ZpsdvhpnSMAsapr0Oh9lZ7x7dvf/5KKvnePfs6jV+M0pzRglnlHRGKWeU7owynFGmM8pyRtnMKOG0bThtG07bhtO24bRtOG0bTtuG07bhtG04bZtO26bTtum0bTptm07bptO26bRtOm2bTtum07bltG05bVtO25bTtuW0bTltW07bltO25bRtnbZtvHa8ezba+KthfnnLu9r89aM/jdJfzijNGSWcUdIZpZxRujPKcEaZzijLGcVp2+G07XDadjhtO5y2HU7bDqdth9O2w2nb4fzbdjhvEqbzJmE6bxKm8yZhOm8SZjmjOG8SpvMmYTpvEqbTttNp2+W07XLadjltu5y2XU7bLqdtl9O2y2nb5bTtctp2O227nbbdTttup22307bbadvttO122nY7bbuZto0X07bxYto2Xkzbxotp23gxbRsvpm3jxbRtvJi2jRfTts+7aGYUx5KFY8nCsWThWLJwLFk4liwcSxaOJQvHkoVjycKxZOFYsnAsWTiWLBxLFo4lC8eShWPJwrFk4ViycCxZOJYsHEsWjiULx5KFY8nCsWThWLJwLFk4liwcSxaOJQvHkoVjycKxZOFYsnAsWTiWLBxLFuW0bXfatjtt25227U7bdqdtu9O23Wnb7rRtd9rWsWThWLJwLFk4liwcSxaOJQvHkoVjycKxZDEYuRvDadvptO102nY6bTudtp1O206nbafTttNp2+m07XTadjltu5y2XU7bLqdtl9O2y2lbx5KFY8nCsWThWLJwLFk4liwcSxaOJQvHkoVjycKxZOFYsnAsWTiWLB1Llo4lS8eSpWPJ8sW0bTqWLB1Llo4lS8eSpWPJ0rFk6ViydCxZOpYsHUuWjiVLx5KlY8nSsWTpWLJ0LFk6liwdS5aOJUvHkqVjydKxZOlYsnQsWTqWLB1Llo4lS8eSpWPJ0rFk6ViydCxZOpYsHUuWjiVL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HfJqHfJqHfJqHfJqHfJqHfJqHfJqHfJqHfJqHfJqHfJqHfJqHfJqHfJqHfJqHfJqHfJqHfJqHfJqHfJqHfJqHfJqHfJqHfJqHfJqHfJqHfJqHfJqHfJqHfJqHfJqHfJqHfJqHfJqHfJqHfJqHfJqHfJqHfJq/Y+82vsvqnj98jXxe39AxH4/d2SLP3+4ZXv/8E+naf/i4Ve8n6K9Zv/zhyvmu2f7aH+eXmvr9f77Rv3q4fy9v16b74eIeP0qv3qXX7/5HeU3bn5H+c2b31F+6+Z3lN+++Z3k90fO9eb3X8yv3fyO8oub31F+efM7yq9ufkf53f3jLL+7f5zld/ePs/zu/nGW390/jvKbd/84y+/uH2f53f3jLL+7f5zlVze/o/zu/nGW390/zvK7+8dZfnf/OMvv7h9H+a27f5zld/ePs/zu/nGW390/zvKrm99Rfnf/OMvv7h9n+d394yy/u3+c5Xf3j6P89t0/zvK7+8dZfnf/OMvv7h9n+dXN7yi/u3+c5Xf3j7P87v5xlt/dP87yu/vHSX7jdfePs/zu/nGW390/zvK7+8dZfnXzO8rv7h9n+d394yy/u3+c5Xf3j7P87v5xlF+7+8dZfnf/OMvv7h9n+d394yy/uvkd5Xf3j7P87v5xlt/dP87yu/vHWX53/zjKL+7+cZbf3T/O8rv7x1l+d/84y69ufkf53f3jLL+7f5zld/ePs/zu/nGW390/jvLLu3+c5Xf3j7P87v5xlt/dP87yq5vfUX53/zjL7+4fZ/nd/eMsv7t/nOV394+j/OruH2f53f3jLL+7f5zld/ePs/zq5neU390/zvK7+8dZfnf/OMvv7h9n+d394yi/fvePs/zu/nGW390/zvK7+8dZfnXzO8rv7h9n+d394yy/u3+c5Xf3j7P87v5xlN+9f36Y390/zvK7+8dZfnf/OMuvbn5H+d394yy/u3+c5Xf3j7P87v5xlt/dP47yu/fPD/O7+8dZfnf/OMvv7h9n+dXN7yi/u3+c5Xf3j7P87v5xlt/dP87yu/vHUX7n98/nL3/LmPUXD7e58v3o6xX/F/JrN7+j/H53//hvTTP2H0zzn39A/v/7AWVbv7TUHn/+A8po757Nnb/98dRN73+W3vPBx9+8/eKLt3//2xdfffLRd2+/+vLb5wuf3/63j755+9HHX3z27sPPv//yk1999rt///r9Z95//dfffPXJZ59+/81nP32nnz/3fPv/AA==","file_map":{"26":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"62":{"source":"use utils::{DiscloseFlags, DisclosedData};\nuse disclose::get_disclosed_data;\nuse commitment::nullify;\n\nfn main(\n    comm_in: pub Field,\n    salt: Field,\n    private_nullifier: Field,\n    dg1: [u8; 95],\n    disclose_flags: DiscloseFlags,\n    service_scope: pub Field,\n    service_subscope: pub Field,\n) -> pub (DisclosedData, Field) {\n    let disclosed_data = get_disclosed_data(dg1, disclose_flags);\n    let scoped_nullifier = nullify(\n        comm_in,\n        salt,\n        dg1,\n        private_nullifier,\n        service_scope,\n        service_subscope,\n    );\n    (disclosed_data, scoped_nullifier)\n}\n","path":"/Users/madztheo/Documents/Wagmi/Studio/RnD/Docaproof/Circuits/zk_id_check_circuits/src/noir/bin/disclose/flags/src/main.nr"},"63":{"source":"use common::{calculate_scoped_nullifier, hash_salt_dg1_private_nullifier};\n\n/*\n############################################################\n# Circuit D\n############################################################\n# Generates a scoped nullifier that is scoped by service\n# Allows selective disclosure of dg1 via a reveal bitmask\n############################################################\n\n# Inputs/Outputs\n############################################################\ncomm_in             `assert comm_in == H(salt, dg1, private_nullifier)`\nsalt\ndg1\nprivate_nullifier\nservice_scope       `H(<domain_name>)`\nservice_subscope    `H(<purpose>)` (Service-specific subscope)\nscoped_nullifier    `H(private_nullifier, service_scope, service_subscope)`\n\n# Checks\n############################################################\n- Checks that dg1_reveal is the correct reveal of dg1 for the given dg1_mask\n- Constrains scoped_nullifier to be `H(private_nullifier, service_scope, service_subscope)`\n*/\npub fn nullify(\n    comm_in: Field,\n    salt: Field,\n    dg1: [u8; 95],\n    private_nullifier: Field,\n    service_scope: Field,\n    service_subscope: Field,\n) -> Field {\n    assert(comm_in == hash_salt_dg1_private_nullifier(salt, dg1, private_nullifier));\n    // println(f\"comm_in: {comm_in}\");\n    let scoped_nullifier =\n        calculate_scoped_nullifier(private_nullifier, service_scope, service_subscope);\n    // println(f\"scoped_nullifier: {scoped_nullifier}\");\n    scoped_nullifier\n}\n\n","path":"/Users/madztheo/Documents/Wagmi/Studio/RnD/Docaproof/Circuits/zk_id_check_circuits/src/noir/lib/commitment/scoped-nullifier/src/lib.nr"},"64":{"source":"//use std::hash::pedersen_hash;\nuse std::hash::poseidon2::Poseidon2;\nuse utils::PASSPORT_MRZ_COUNTRY_INDEX;\n\npub global CSC_CERT_TYPE: Field = 1;\npub global DSC_CERT_TYPE: Field = 2;\n\npub fn calculate_scoped_nullifier(\n    private_nullifier: Field,\n    service_scope: Field,\n    service_subscope: Field,\n) -> Field {\n    Poseidon2::hash([private_nullifier, service_scope, service_subscope], 3)\n}\n\npub fn calculate_certificate_registry_leaf<let N: u32>(\n    registry_id: Field,\n    cert_type: Field,\n    country: str<3>,\n    csc_pubkey: [u8; N],\n) -> Field {\n    let country_bytes: [u8; 3] = country.as_bytes();\n    let mut result: [Field; N + 5] = [0; N + 5];\n    result[0] = registry_id as Field;\n    result[1] = cert_type as Field;\n    result[2] = country_bytes[0] as Field;\n    result[3] = country_bytes[1] as Field;\n    result[4] = country_bytes[2] as Field;\n    for i in 0..N {\n        result[i + 5] = csc_pubkey[i] as Field;\n    }\n    Poseidon2::hash(result, N + 5)\n}\n\npub fn get_country_from_dg1(dg1: [u8; 95]) -> str<3> {\n    // There 5 padding bytes in the dg1 before the actual MRZ\n    let country_offset = 5 + PASSPORT_MRZ_COUNTRY_INDEX;\n    let mut country_bytes: [u8; 3] = [0; 3];\n    for i in 0..3 {\n        country_bytes[i] = dg1[country_offset + i];\n    }\n    country_bytes.as_str_unchecked()\n}\n\npub fn hash_salt_country_tbs<let TBS_MAX_SIZE: u32>(\n    salt: Field,\n    country: str<3>,\n    tbs: [u8; TBS_MAX_SIZE],\n) -> Field {\n    let country_bytes: [u8; 3] = country.as_bytes();\n    let mut result: [Field; TBS_MAX_SIZE + 4] = [0; TBS_MAX_SIZE + 4];\n    result[0] = salt as Field;\n    result[1] = country_bytes[0] as Field;\n    result[2] = country_bytes[1] as Field;\n    result[3] = country_bytes[2] as Field;\n    for i in 0..TBS_MAX_SIZE {\n        result[4 + i] = tbs[i] as Field;\n    }\n    Poseidon2::hash(result, TBS_MAX_SIZE + 4)\n}\n\npub fn hash_salt_dg1_private_nullifier<let N: u32>(\n    salt: Field,\n    dg1: [u8; N],\n    private_nullifier: Field,\n) -> Field {\n    let mut result: [Field; N + 2] = [0; N + 2];\n    result[0] = salt as Field;\n    for i in 0..N {\n        result[1 + i] = dg1[i] as Field;\n    }\n    result[1 + N] = private_nullifier;\n    Poseidon2::hash(result, N + 2)\n}\n\npub fn calculate_private_nullifier<let DG1: u32, let SIG: u32>(\n    dg1: [u8; DG1],\n    sod_sig: [u8; SIG],\n) -> Field {\n    let mut result: [Field; DG1 + SIG] = [0; DG1 + SIG];\n    for i in 0..DG1 {\n        result[i] = dg1[i] as Field;\n    }\n    for i in 0..SIG {\n        result[DG1 + i] = sod_sig[i] as Field;\n    }\n    Poseidon2::hash(result, DG1 + SIG)\n}\n\npub fn hash_salt_country_signed_attr_dg1_private_nullifier<let SA: u32>(\n    salt: Field,\n    country: str<3>,\n    signed_attr: [u8; SA],\n    signed_attr_size: Field,\n    dg1: [u8; 95],\n    private_nullifier: Field,\n) -> Field {\n    let country_bytes: [u8; 3] = country.as_bytes();\n    let mut result: [Field; SA + 101] = [0; SA + 101];\n    result[0] = salt as Field;\n    result[1] = country_bytes[0] as Field;\n    result[2] = country_bytes[1] as Field;\n    result[3] = country_bytes[2] as Field;\n    for i in 0..SA {\n        result[4 + i] = signed_attr[i] as Field;\n    }\n    result[4 + SA] = signed_attr_size;\n    for i in 0..95 {\n        result[4 + SA + 1 + i] = dg1[i] as Field;\n    }\n    result[4 + SA + 1 + 95] = private_nullifier;\n    Poseidon2::hash(result, SA + 101)\n}\n","path":"/Users/madztheo/Documents/Wagmi/Studio/RnD/Docaproof/Circuits/zk_id_check_circuits/src/noir/lib/commitment/common/src/lib.nr"},"65":{"source":"/**\n* The standards for passports and any other travel documents, electronic or not,\n* are defined in the ICAO (International Civil Aviation Organization) 9303 document available here:\n* https://www.icao.int/publications/pages/publication.aspx?docnum=9303\n*/\n\n/**\n* The structure of the MRZ is well defined and standardized by the ICAO\n* so the index will always be the same for every passport\n* c.f. ICAO 9303-4, Appendix B\n*/\n\n// The following constants define the indices of the information\n// we need to generate various proofs of identity from the MRZ\n// The structure of the MRZ is slightly different between passports\n// and ID cards so we need to define indices for both types\n\n// Index for the country of issuance of the passport\npub global PASSPORT_MRZ_COUNTRY_INDEX: u32 = 2;\n// Index for the three letter code of the country of citizenship\n// Note that the first three letter code (index 2) in the MRZ is the country of issuance\n// not citizenship. It is important to keep in mind for residence permits\n// where the issuing country differs from the citizenship country\npub global PASSPORT_MRZ_NATIONALITY_INDEX: u32 = 54;\n// Index for the gender of the passport holder (M, F or < if unspecified)\npub global PASSPORT_MRZ_GENDER_INDEX: u32 = 64;\n// Index for the date of expiry (YYMMDD)\npub global PASSPORT_MRZ_EXPIRY_DATE_INDEX: u32 = 65;\n// Index for the date of birth (YYMMDD) in TD1 (i.e. passport) MRZ\npub global PASSPORT_MRZ_BIRTHDATE_INDEX: u32 = 57;\n// Index for the document number in the MRZ\npub global PASSPORT_MRZ_DOCUMENT_NUMBER_INDEX: u32 = 44;\n// Index for the document type in the MRZ\npub global PASSPORT_MRZ_DOCUMENT_TYPE_INDEX: u32 = 0;\n// Index for the name of the passport holder\npub global PASSPORT_MRZ_NAME_INDEX: u32 = 5;\n// Length of the MRZ on a passport\npub global PASSPORT_MRZ_LENGTH: u32 = 88;\n\n// Index for the country of issuance of the ID card\npub global ID_CARD_MRZ_COUNTRY_INDEX: u32 = 2;\n// Note that the first three letter code (index 2) in the MRZ is the country of issuance\n// not citizenship. It is important to keep in mind for residence permits\n// where the issuing country differs from the citizenship country\npub global ID_CARD_MRZ_NATIONALITY_INDEX: u32 = 45;\n// Index for the gender of the passport holder (M, F or < if unspecified)\npub global ID_CARD_MRZ_GENDER_INDEX: u32 = 37;\n// Index for the date of expiry (YYMMDD)\npub global ID_CARD_MRZ_EXPIRY_DATE_INDEX: u32 = 38;\n// Index for the date of birth (YYMMDD) in TD3 (i.e. ID cards) MRZ\npub global ID_CARD_MRZ_BIRTHDATE_INDEX: u32 = 30;\n// Index for the document number in the MRZ\npub global ID_CARD_MRZ_DOCUMENT_NUMBER_INDEX: u32 = 5;\n// Index for the document type in the MRZ\npub global ID_CARD_MRZ_DOCUMENT_TYPE_INDEX: u32 = 0;\n// Index for the name of the passport holder\npub global ID_CARD_MRZ_NAME_INDEX: u32 = 60;\n// Length of the MRZ on an ID card\npub global ID_CARD_MRZ_LENGTH: u32 = 90;\n\n// ECDSA curves mapping\npub global ECDSA_CURVE_P256: u32 = 0;\npub global ECDSA_CURVE_P384: u32 = 1;\npub global ECDSA_CURVE_P521: u32 = 2;\npub global ECDSA_CURVE_BRAINPOOL_B256R1: u32 = 3;\npub global ECDSA_CURVE_BRAINPOOL_B256T1: u32 = 4;\npub global ECDSA_CURVE_BRAINPOOL_B384R1: u32 = 5;\npub global ECDSA_CURVE_BRAINPOOL_B384T1: u32 = 6;\npub global ECDSA_CURVE_BRAINPOOL_B512R1: u32 = 7;\npub global ECDSA_CURVE_BRAINPOOL_B512T1: u32 = 8;\n\npub struct IDData {\n    // Regroups the hashes of all the data groups plus some padding\n    // at the start and in between each data group hashes\n    pub e_content: [u8; 700],\n    pub e_content_size: u32,\n    // Where we can find e_content in the signed_attributes\n    // It varies from document to document according to the length\n    // of the padding at the start\n    pub dg1_offset_in_e_content: u32,\n    // Last 32 bytes: result of the hash of all the hashes of the data groups\n    // Rest of the bytes: information about the signature algorithm, date, etc.\n    pub signed_attributes: [u8; 200],\n    pub signed_attributes_size: u32,\n    // The DG1 contains the Machine Readable Zone (MRZ) of the document\n    // The two lines at the bottom of the passport data page\n    // or the three bottom lines on the rear of an ID card\n    // 95 bytes for passports, 93 bytes for ID cards\n    // Including 88 bytes of MRZ and 5 bytes of padding for passports\n    // and 90 bytes of MRZ and 5 bytes of padding for ID cards\n    pub dg1: [u8; 95],\n    // The signature over the data groups\n    pub sod_signature: [u8; 512],\n    pub sod_signature_size: u32,\n}\n\npub struct DSCData {\n    // The TBS certificate of the DSC\n    // TBS stands for To Be Signed\n    pub tbs_certificate: [u8; 1500],\n    pub tbs_certificate_size: u32,\n    // The public key of the DSC (up to 512 bytes to account for RSA-4096)\n    pub pubkey: [u8; 512],\n    // The actual size of the public key\n    pub pubkey_size: u32,\n    // The index of the public key in the TBS certificate\n    pub pubkey_index: u32,\n    // Data used to verify the signature\n    // Generated by the pre-compute function in Rust\n    // c.f. main.rs\n    pub pubkey_redc_param: [u8; 513],\n    // The signature over the TBS certificate\n    pub signature: [u8; 512],\n    pub signature_size: u32,\n    // The exponent of the public key\n    // Only useful for RSA, can be ignored for ECDSA\n    pub exponent: u32,\n}\n\npub struct CSCData {\n    // The public key of the CSC (up to 512 bytes to account for RSA-4096)\n    pub pubkey: [u8; 512],\n    // The actual size of the public key\n    pub pubkey_size: u32,\n    // Data used to verify the signature\n    // Generated by the pre-compute function in Rust\n    // c.f. main.rs\n    pub pubkey_redc_param: [u8; 513],\n    // Only useful for RSA, can be ignored for ECDSA\n    pub exponent: u32,\n}\n\npub struct DiscloseFlags {\n    pub issuing_country: bool,\n    pub nationality: bool,\n    pub document_type: bool,\n    pub document_number: bool,\n    pub date_of_expiry: bool,\n    pub date_of_birth: bool,\n    pub gender: bool,\n    pub name: bool,\n}\n\npub struct DisclosedData {\n    pub issuing_country: [u8; 3],\n    pub nationality: [u8; 3],\n    pub document_type: [u8; 2],\n    pub document_number: [u8; 9],\n    pub date_of_expiry: [u8; 6],\n    pub date_of_birth: [u8; 6],\n    pub name: [u8; 39],\n    pub gender: [u8; 1],\n}\n\npub fn get_array_slice<let N: u32, let M: u32>(arr: [u8; N], start: u32, end: u32) -> [u8; M] {\n    let mut slice = [0 as u8; M];\n    for i in start..end {\n        slice[i - start] = arr[i];\n    }\n    slice\n}\n\npub fn get_array_slice_constant<let N: u32, let M: u32>(arr: [u8; N]) -> [u8; M] {\n    let mut slice = [0 as u8; M];\n    for i in 0..M {\n        slice[i] = arr[i];\n    }\n    slice\n}\n\n// Reverse the bytes of an array so you can switch from\n// big endian to little endian order and vice versa\npub fn reverse_bytes_array<let N: u32>(arr: [u8; N]) -> [u8; N] {\n    let mut reversed_arr = [0 as u8; N];\n    for i in 0..N {\n        // Reverse\n        reversed_arr[i] = arr[N - 1 - i];\n    }\n    reversed_arr\n}\n\npub fn insert_into_array<let N: u32, let M: u32>(\n    mut arr: [u8; N],\n    sub_arr: [u8; M],\n    index: u32,\n) -> [u8; N] {\n    for i in index..index + M {\n        arr[i] = sub_arr[i - index];\n    }\n    arr\n}\n\npub fn dynamic_insert_into_array<let N: u32, let M: u32>(\n    mut arr: [u8; N],\n    sub_arr: [u8; M],\n    index: u32,\n    max_size: u32,\n) -> [u8; N] {\n    for i in index..index + max_size {\n        if i - index < M {\n            arr[i] = sub_arr[i - index];\n        }\n    }\n    arr\n}\n\npub fn is_id_card(dg1: [u8; 95]) -> bool {\n    // For passport, the last two bytes are 0\n    // since the real length is 93 for passports\n    // while it is 95 for ID cards\n    (dg1[93] != 0) & (dg1[94] != 0)\n}\n\npub fn from_byte_be_to_fields<let NBytes: u32, let N: u32>(x: [u8; NBytes]) -> [Field; N] {\n    let mut result = [0 as Field; N];\n\n    let mut limb: Field = 0;\n    let mut k = 0;\n    for _j in 0..(15 - (N * 15 - NBytes)) {\n        limb *= 256;\n        limb += x[k] as Field;\n        k += 1;\n    }\n    std::as_witness(limb);\n\n    result[N - 1] = limb;\n\n    for i in 1..N {\n        let mut limb: Field = 0;\n        for _j in 0..15 {\n            limb *= 256;\n            limb += x[k] as Field;\n            k += 1;\n        }\n        std::as_witness(limb);\n        result[N - i - 1] = limb;\n    }\n\n    result\n}\n\npub unconstrained fn __from_byte_be_to_fields<let NBytes: u32, let N: u32>(\n    x: [u8; NBytes],\n) -> [Field; N] {\n    from_byte_be_to_fields(x)\n}\n\npub fn get_mrz_from_dg1(dg1: [u8; 95]) -> [u8; 90] {\n    let mut mrz = [0 as u8; 90];\n    for i in 0..90 {\n        mrz[i] = dg1[i + 5];\n    }\n    mrz\n}\n\npub fn split_array<let N: u32>(array: [u8; N * 2]) -> ([u8; N], [u8; N]) {\n    let mut array_x = [0 as u8; N];\n    let mut array_y = [0 as u8; N];\n    for i in 0..N {\n        array_x[i] = array[i];\n        array_y[i] = array[i + N];\n    }\n    (array_x, array_y)\n}\n\npub fn concat_array<let N: u32>(array_x: [u8; N], array_y: [u8; N]) -> [u8; N * 2] {\n    let mut array = [0 as u8; N * 2];\n    for i in 0..N {\n        array[i] = array_x[i];\n        array[i + N] = array_y[i];\n    }\n    array\n}\n\npub fn check_zero_padding<let N: u32, T>(padded_array: [T; N], len: u32)\nwhere\n    T: Eq,\n    T: Default,\n{\n    for i in 0..N {\n        if i >= len {\n            assert_eq(padded_array[i], T::default());\n        }\n    }\n}\n\npub fn get_nationality_from_mrz(dg1: [u8; 95]) -> [u8; 3] {\n    let mrz = get_mrz_from_dg1(dg1);\n\n    let mut country_bytes: [u8; 3] = [0; 3];\n\n    if is_id_card(dg1) {\n        country_bytes = get_array_slice(\n            mrz,\n            ID_CARD_MRZ_NATIONALITY_INDEX,\n            ID_CARD_MRZ_NATIONALITY_INDEX + 3,\n        );\n    } else {\n        country_bytes = get_array_slice(\n            mrz,\n            PASSPORT_MRZ_NATIONALITY_INDEX,\n            PASSPORT_MRZ_NATIONALITY_INDEX + 3,\n        );\n    }\n\n    country_bytes\n}\n","path":"/Users/madztheo/Documents/Wagmi/Studio/RnD/Docaproof/Circuits/zk_id_check_circuits/src/noir/lib/utils/src/lib.nr"},"66":{"source":"use utils::{\n    IDData, is_id_card, DisclosedData, DiscloseFlags, PASSPORT_MRZ_COUNTRY_INDEX,\n    PASSPORT_MRZ_LENGTH, PASSPORT_MRZ_BIRTHDATE_INDEX, PASSPORT_MRZ_NATIONALITY_INDEX,\n    PASSPORT_MRZ_NAME_INDEX, PASSPORT_MRZ_DOCUMENT_NUMBER_INDEX, PASSPORT_MRZ_GENDER_INDEX,\n    PASSPORT_MRZ_EXPIRY_DATE_INDEX, PASSPORT_MRZ_DOCUMENT_TYPE_INDEX, ID_CARD_MRZ_COUNTRY_INDEX,\n    ID_CARD_MRZ_LENGTH, ID_CARD_MRZ_BIRTHDATE_INDEX, ID_CARD_MRZ_NATIONALITY_INDEX,\n    ID_CARD_MRZ_NAME_INDEX, ID_CARD_MRZ_DOCUMENT_NUMBER_INDEX, ID_CARD_MRZ_GENDER_INDEX,\n    ID_CARD_MRZ_EXPIRY_DATE_INDEX, ID_CARD_MRZ_DOCUMENT_TYPE_INDEX, get_mrz_from_dg1,\n};\n\nfn get_array_slice<let N: u32, let M: u32>(array: [u8; N], start: u32, end: u32) -> [u8; M] {\n    let mut slice = [0 as u8; M];\n    for i in 0..M {\n        slice[i] = array[start + i];\n    }\n    slice\n}\n\npub fn get_disclosed_data(dg1: [u8; 95], flags: DiscloseFlags) -> DisclosedData {\n    let mrz = get_mrz_from_dg1(dg1);\n    let mut disclosed_data = DisclosedData {\n        issuing_country: [0 as u8; 3],\n        date_of_birth: [0 as u8; 6],\n        nationality: [0 as u8; 3],\n        name: [0 as u8; 39],\n        document_number: [0 as u8; 9],\n        date_of_expiry: [0 as u8; 6],\n        document_type: [0 as u8; 2],\n        gender: [0 as u8; 1],\n    };\n\n    if is_id_card(dg1) {\n        if flags.issuing_country {\n            disclosed_data.issuing_country = get_array_slice(\n                mrz,\n                ID_CARD_MRZ_COUNTRY_INDEX,\n                ID_CARD_MRZ_COUNTRY_INDEX + 3,\n            );\n        }\n        if flags.date_of_birth {\n            disclosed_data.date_of_birth = get_array_slice(\n                mrz,\n                ID_CARD_MRZ_BIRTHDATE_INDEX,\n                ID_CARD_MRZ_BIRTHDATE_INDEX + 6,\n            );\n        }\n        if flags.nationality {\n            disclosed_data.nationality = get_array_slice(\n                mrz,\n                ID_CARD_MRZ_NATIONALITY_INDEX,\n                ID_CARD_MRZ_NATIONALITY_INDEX + 3,\n            );\n        }\n        if flags.name {\n            disclosed_data.name =\n                get_array_slice(mrz, ID_CARD_MRZ_NAME_INDEX, ID_CARD_MRZ_NAME_INDEX + 30);\n        }\n        if flags.document_number {\n            disclosed_data.document_number = get_array_slice(\n                mrz,\n                ID_CARD_MRZ_DOCUMENT_NUMBER_INDEX,\n                ID_CARD_MRZ_DOCUMENT_NUMBER_INDEX + 9,\n            );\n        }\n        if flags.date_of_expiry {\n            disclosed_data.date_of_expiry = get_array_slice(\n                mrz,\n                ID_CARD_MRZ_EXPIRY_DATE_INDEX,\n                ID_CARD_MRZ_EXPIRY_DATE_INDEX + 6,\n            );\n        }\n        if flags.document_type {\n            disclosed_data.document_type = get_array_slice(\n                mrz,\n                ID_CARD_MRZ_DOCUMENT_TYPE_INDEX,\n                ID_CARD_MRZ_DOCUMENT_TYPE_INDEX + 2,\n            );\n        }\n        if flags.gender {\n            disclosed_data.gender = get_array_slice(\n                mrz,\n                ID_CARD_MRZ_GENDER_INDEX,\n                ID_CARD_MRZ_GENDER_INDEX + 1,\n            );\n        }\n    } else {\n        if flags.issuing_country {\n            disclosed_data.issuing_country = get_array_slice(\n                mrz,\n                PASSPORT_MRZ_COUNTRY_INDEX,\n                PASSPORT_MRZ_COUNTRY_INDEX + 3,\n            );\n        }\n        if flags.date_of_birth {\n            disclosed_data.date_of_birth = get_array_slice(\n                mrz,\n                PASSPORT_MRZ_BIRTHDATE_INDEX,\n                PASSPORT_MRZ_BIRTHDATE_INDEX + 6,\n            );\n        }\n        if flags.nationality {\n            disclosed_data.nationality = get_array_slice(\n                mrz,\n                PASSPORT_MRZ_NATIONALITY_INDEX,\n                PASSPORT_MRZ_NATIONALITY_INDEX + 3,\n            );\n        }\n        if flags.name {\n            disclosed_data.name =\n                get_array_slice(mrz, PASSPORT_MRZ_NAME_INDEX, PASSPORT_MRZ_NAME_INDEX + 39);\n        }\n        if flags.document_number {\n            disclosed_data.document_number = get_array_slice(\n                mrz,\n                PASSPORT_MRZ_DOCUMENT_NUMBER_INDEX,\n                PASSPORT_MRZ_DOCUMENT_NUMBER_INDEX + 9,\n            );\n        }\n        if flags.date_of_expiry {\n            disclosed_data.date_of_expiry = get_array_slice(\n                mrz,\n                PASSPORT_MRZ_EXPIRY_DATE_INDEX,\n                PASSPORT_MRZ_EXPIRY_DATE_INDEX + 6,\n            );\n        }\n        if flags.document_type {\n            disclosed_data.document_type = get_array_slice(\n                mrz,\n                PASSPORT_MRZ_DOCUMENT_TYPE_INDEX,\n                PASSPORT_MRZ_DOCUMENT_TYPE_INDEX + 2,\n            );\n        }\n        if flags.gender {\n            disclosed_data.gender = get_array_slice(\n                mrz,\n                PASSPORT_MRZ_GENDER_INDEX,\n                PASSPORT_MRZ_GENDER_INDEX + 1,\n            );\n        }\n    }\n\n    disclosed_data\n}\n\npub fn get_disclosed_bytes(dg1: [u8; 95], mask: [u8; 90]) -> [u8; 90] {\n    let mut disclosed_bytes = [0 as u8; 90];\n    let mrz = get_mrz_from_dg1(dg1);\n    for i in 0..90 {\n        disclosed_bytes[i] = mask[i] * mrz[i];\n    }\n    disclosed_bytes\n}\n","path":"/Users/madztheo/Documents/Wagmi/Studio/RnD/Docaproof/Circuits/zk_id_check_circuits/src/noir/lib/disclose/src/lib.nr"}},"names":["main"],"brillig_names":["directive_invert"]}