{"noir_version":"1.0.0-beta.1+03b58fa2dfcc8acc8cf5198b1b23b55676fbdb02","hash":7510293008002760687,"abi":{"parameters":[{"name":"comm_in","type":{"kind":"field"},"visibility":"public"},{"name":"salt","type":{"kind":"field"},"visibility":"private"},{"name":"private_nullifier","type":{"kind":"field"},"visibility":"private"},{"name":"dg1","type":{"kind":"array","length":95,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"current_date","type":{"kind":"string","length":8},"visibility":"public"},{"name":"min_date","type":{"kind":"string","length":8},"visibility":"public"},{"name":"max_date","type":{"kind":"string","length":8},"visibility":"public"},{"name":"service_scope","type":{"kind":"field"},"visibility":"public"},{"name":"service_subscope","type":{"kind":"field"},"visibility":"public"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/+x9CZyN1f//M3f2GVubiCxtpMV9Zh+0F4qkVJSSYWYUKWQtJUtpIYmoFG2yt5ettNpJEUKbJUu0SSpRv3um8/g9czp9U8/7c+75XM7r9f+Puc3vfN/n83l/tvd57r1xzp9rUwXHaXH0n/+Oi/y/eN/PFOW1BM1riZrXkjSvJWteS9G8lqp5LU3zWrrmtTKa18pqXiunea285rUKmtcO07x2uOa1IzSvHal57SjNaxU1rx2tea2S5rXKmteO0bxWRfNaVc1rx2peq6Z5rbrmtRqa12pqXjtO89rxmtdO0Lx2oua1kzSv1dK8Vlvz2sma1+poXjtF89qpmtdO07x2uua1uprXwprXXM1rGZrXMjWvZWley9a8lqN5LVfzWp7mtXzNa/U0r9XXvNZA89oZmtfO1Lx2lua1szWvnaN57VzNa+dpXjtf89oFmtcaal5rpHmtsea1CzWvXaR5rYnmtaaa1y7WvNZM89olmteaa167VPPaZZrXWmheu1zz2hWa167UvNZS81orzWtXaV67WvNaa81r12heu1bzWhvNa9dpXmurea1A81o7zWvtNa8Val4r0rxWrHmtg+a16zWv3aB5raPmtU6a127UvNZZ89pNmtdu1rzWRfNaV81r3TSv3aJ5rbvmtR6a13pqXuulea235rU+8jXRK4Xk/1NXnPx5tvwZDrbcdrC9CsMauJi93XDYb4vb5c87HMWAd0gD+lc8ocEywzlZWUW5GUVuplsQzshvl5cdzspul5Pn5rnZedmFGXmZmUV5WXm5+e3yc8P5blZmkVucnZ9ZVCxW2L0dsFexBHYH0JH/hoBBccMI6GbmO4YI2E/+vNNRCHjnARAQabCgBOwHxHUnkSPRhLvdwSUDSpz9iHCGFJzhYAuSEL0z94dxu9D1x6XY13Rlbe/wq6wD5M+BnkE8Aw506CtreweX2AY4OFIOdHhWVhgBDVbWQfLnXY5CwLsc+sqKJOAgIK67HB6VdYDjsKisgxwelRXBR+/Mdzs0lVXsa7qyFjr8Kutg+fMezyCeAe9x6CtroYNLbIMdHCnvcXhWVhgBDVbWe+XP+xyFgPc59JUVScB7gbjuc3hU1sGOw6Ky3uvwqKwIPnpnvt+hqaxiX9OVtcjhV1mHyJ9DPYN4Bhzq0FfWIgeX2IY4OFIOdXhWVhgBDVbWB+TPYY5CwGEOfWVFEvABIK5hDo/KOsRxWFTWBxwelRXBR+/MDzo0lVXsS1oYIkj6w2yak4WY3T2bDsf5Ouy3qdi3BqVNw+GC+4E8HQ606UNENn2I3qbug8C9HgLadASRTUdIm5rsqosdXDOmgUvS1IyUPx/2DOIZULxA3VUXO7imZqSDI+XDQEea7KphBDTYVY+SP0c7CgFHO/RdNZKAo4C4RhM5Ek24kQ4uGVDiHEWEE91VI/jonfkRGLdLd9ViX9N6VQeHX2V9VP58zDOIZ8DHHPrK2sHBJbZHHRwpH3N4VlYYAQ1W1jHy5+OOQsDHHfrKiiTgGCCuxx0elfVRx2FRWcc4PCorgo/emZ9waCqr2FeNS7AdChBdgWeHsThcpWb3sQ59gXwCuNdYoE3HEdl0nGO+a7vewRV7DVySovmk/PmUZxDPgE859KS83sEVzScdHCmfAjrSZNcGI6DBru1p+fMZRyHgMw5914Yk4NNAXM8QORJNuCcdXDKgxPk0EU5014bgo3fmZ2HcLt21iX1NV9YbHH6Vdbz8+ZxnEM+Azzn0lfUGB5fYxjs4Uj7n8KysMAIarKwT5M+JjkLAiQ59ZUUScAIQ10SHR2Ud7zgsKusEh0dlRfDRO/Mkh6ayin2p9RBEV+DZYTIOV6nZfbJDXyAnAfeaDLTpFCKbTqHnljsCaIepMFxult8OYt8ajtnuFXeWMF33GvGG3xbT5M/nPYN4BhT/4WjlNfFHaQooNLmed3DkegGGy83z2+EFjR3QiWuqAyo+7d38aUCbPu/QkBzKo8gJkGd+0aFJ1mLfGo79PNLZIeheLxHZ9CXHfOJHnkUDF7R3TpbfFi/Ln694BvEMKP7DMcpr4o+SFVDoxP+KgyPXqzBcbnu/HV7V2AEdsC85oMRfnF/4MtCmrzgMEn/kjMgzv+bQJCmxbw3Hfh7p7BB0r9eJbPq6Yz7xI8+igQtTA/y2mC5/zvAM4hlQ/IdjlddmSIP6Fzrxz3Bw5JqJw5Xjt8NMjR3QAfu6g0r8xbnTgTad4XBI/OEC5JlnOTRJSuxbw7GfRzo7BN1rNpFNZzvmE/80h0HiV+6J3pA/3/QM4hlQ/IdKymvij6i1WcSI7t0dveHgiPom7oxGLy9huN2wscvLOfLnW45CwLcc+svLN4EEnAPE9RaRI9GEm+PgkoHJ7P2ywy97vy1/vuMZxAsU8R/U7C3+iDp7I+ZsL3jednCkfMfhmb1huA1m73flz/cchYDvOfTZ+x0HR8B3gbjec3hk73cdntl7usMve78vf871DOIFivgPavYWf0SdvRHDshc87zs4Us51eGZvGG6D2Xue/DnfUQg436HP3nOBBJwHxDXf4ZG95zm4ZODHiVZ3EX72zrwAhiuzlIK0wDH/qDtMDXPNVbGF8ucizyCeAcV/UKvYIoe+is12cElkoYMj6iKgA0xWMSBuY1Vssfy5xFEIuMShr2KLgARcDMS1xOFRxRY7PKoYws/emZc6NFVsqWO+iiHf1q2BS3IB/oH8ucwziGdA8R8SldeWOfQX4MscHLk+xOEqdQH+oUN/AT7OQSXT4twPgDZd5tCQHH0BjjzzR8Az+3kk9qXuChE80tkh6F7LiWy63Pn3iT/oWT5waBoMB8kFpVNcIX9+7BnEM+DHDn2niAhOr1NcAcT1MZEj0YRb4eAShMlAgQW9wUBZKX+u8gziBYp4gTpQlju4QFkJxLXK4REoK53oBEo42HKR74jUwCUZJVbLn594BvECRfwHdZQQf0Q9SnwCJNIaHK5So8Qah36UmOKgkkhx7mqgTT9xaEiOHiWQZ14LPLOfR2Jf6lECwSOdHYLutY7Ipusc86PEaodfh/Sp/PmZZxDPgJ859B0SIji9DulTIK7PHB4d0qcOLkGYDBRY0BsMlM/lzy88g3iBIl6gDpR1Di5QPgfi+sLhESifO9hAifdh/F+4w8GW29bBVkdvfUkJ+EuCfdcDyUB17vU+A4P2DZskW4FDQ7YNlIA3EOy70XKyiXNvdGjIZkokOR22l7kPyNwkf37lGcSLzE3yp/818UfUQ53fiEHbgk0OjvRfAZ1rsi+FkdLgh2Zulj+3OAoBNzt/JaX4I+peFUnKzUBcW4icGwLbDxmIWx1csvH45TjYtm4jAQeR7SKyG9hmuT8EX7Y5/79A+2q7oKC23Cyxom2wjfjc4WCrpOgLjKi8432w6zagb74G2tBfv8S+pp8MrOvgmhkNXJKmYLv8ucMziGfA7c5fm4IdDn2nWtfBNQXbHRxRdwCda7JThZHSYKf6jfz5raMQ8Bvnr6QUf0TdqSJJ+Q0Q17dg56LJJyrFdodf5UWc+xuG5w4HWyXJ2/aO4zuHpuMQ+3p5CP1sgtfJWe2nwmKon74n8pPYt4ZjtjMMO7jmQQOXpAj/IH/u9AziGfAH569FWPwRdWfoN2LQIvyDgyPqTqBzTXaGMFIa7Ax/lD93OQoBf3T+SkrxR9SdIZKUPwJx7QI7l6JD+sE5ODvDHxmeOxxslSRv2zvDnxyajkPsa1qLch1+Hcdu+fNnzyCeAXc7f03uPzv0HYfr4JL7bgdH1J8dnh0HjJQGO45f5M9fHYWAvzh/JaX4I+qOA0nKX4C4fnXs7zh2Owdnx/ELw3OHg62S5G17x7HHoek4xL5eHgLbtYCkkyvKgNr1NyK7/mbAruj4/70sjzhFn/sP8Lm9lYDkPVgz3Qv0C5A3LtIX/njc65ifrDJge5mbrPbJn797BvEMuM/5axP7u0M/WfmNGLSJ3ecAkyXQuSYnKxgpDU5Wf/iN4SfgH5rXxP9HPVkhSfkHEJc4O9K5FBPGPufgnKz+YHjucLBVkrxtn6zi4mg6jrg48x1HpsOv4whJI8SriVz8B/W1+Dj6jiPTwSX3UByOqPFxPDsOGCkNdhwJ0giJKgETNKRMNNBxIEmZACRlIoOOw0skMLIw6TgSGJ47HGyVJG/bO44koo4jKY5OcyTp5MBabjKRXZMN2BUd/045HnGKPncc+NzeslnLTcHx3gXyxkX6wh+PKVGYrHDfrmJuskqVRkhTG9ZUTRObZmCy8hsxaBObCmxi05hOVjBSGpys0qURyqgETNeQsoyByQpJynQgKcswmKxSD9LJKv0gnKxEnNg+WZUlmgDKRqHjwH0TjrmOo5w0Qnk1kZfTJPfyBjqOpQ4uuZcDJvfyTDsOGCkNdhwVpBEOUwlYQUPKwwx0HEhSVgCS8jAGHUe5g7TjqHAQdhwiTmzvOA4n6jgOj6N7j7jXyVntJ7BGdgSRn8S+NZz/3RlCtcPi4lzEp+HBP/RF8grJqYB7ud4/NC6B7e3395EyAR6lNhVHahqNoyRx/CvpEFH+7UJ0+BnyjO6RwGbqqDgaAoMnpALch+ZiPpHLs19FVMLObk/SnGzzxbUDPPfRwEJFcW7hl6MJzl2JqEBX8uVZLraobDkHxJkrE5z7GCIOHOPjAHaY+LPGHh2HrbNivwSsz8jyfDjIynDDSNtViQP5NTJ8UMVNFYK4qUoUN1X/R9yEg639OcR22x5LZNtjNf3/wdLbVYP1dtntdXGKENxEb4fmPFLQqG55jyB8XJ0gHmsQxWMNwj6RyhY1LeeAOHNNgnMfR8SB4wj6RH9PXx3c64j90DemyJpcBXje4xlw/XgCrp9AxPUTCHs7L+7Pdv5c4WCLzLYnEtn2RE1vZ/MDxCcBfWXrA8SOQ6MBnkTAy1pEvKwV9/dvZED0zLpLwHCwhX08jAmf0L1HbWB8lyV6qL923F8fvLE5Z54MtKmtH6BDxfGTCXJmHaKcWSeO7M1f+22BjvdTGMT7KXFkD7iU2BXZf4r9KPrPUy2facS5TyU492lEsXoaoYbj2QIdq6cziNXT4/75ISe0vS+E7WXu8fe60gglxvMbsG7cXx8ACsfRP/7uN2LQJ43rAsWccBzOuSYff4eR0uDj7640QoZKQFdDyow4+sffkaR0gaTMiMM6l6IC1SWoQMipqC5SSSKyoWu5DV1iGyLid5tDW6zCgVYm1B+Zcah8Vej6c21mnPk3FV7k4AqvBi5JAcuSRshWi1WWpoBlG+iqLnJwBSwLWMCymXZVMFIa7KpypBFyVQLmaEiZa6CrQpIyB0jKXAZdVZblHUEWg64qx3Ib5ljeVYn4peiqcBUf21XlEXVVef9DVw76rLfX+aJ9jn7WG9dJA/mT4UL5k4/iT+Re0M+f/ChonU1ge5nryutJI9RXm516mgaovoGuvImDCvSwWw/YANVn2pXDSGmwK28gjXCGSsAGGlKeYaArR5KyAZCUZzDoyutZ3lHWY9CVN7Dchg0s78pF/FJ05biKj+3KzyTqys+MgtbZ1MEVXg1ckgJ2ljTC2WqxOktTwM420FU1dXAF7CxgATubaVcFI6XBruocaYRzVQKeoyHluQa6KiQpzwGS8lwGXdVZlncEZzHoqs6x3IbnWN5Vifil6KpwFR/bVZ1H1FWdF4d/P4endRJ1vgU4WaEI6qPzUT4qyijlo/MJ9WjPRygbeHGJ1qNx0w4wxsF69AVEevQFUZicLobtZW5yaiiN0EhtSBtqmtRGBianix1UoIfdhsAmtRHTyQlGSoOTU2NphAtVAjbWkPJCA5MTkpSNgaS8kMHk1NDyrr8hg8mpseU2bGz55CTil2JywlV87OR0EdHkdFEUuqpmDq7wauCSFLAm0ghN1WLVRFPAmhroqpo5uALWBFjAmjLtqmCkNNhVXSyN0Ewl4MUaUjYz0FUhSXkxkJTNGHRVTSzvCJow6KouttyGF1veVYn4peiqcBUf21VdQtRVXUKoRxN1vgU4WQGrRzcn0qObG/ARWj/GTSfAmATrx4cTfzYVKkei68ylwNrgtyFSg780jvYzgFItr9+pDHqgdMttmG55D+R9KRjld36HAy1sD3QZUQ90GXGuKGc5z8sxyBUVLLdhBctzxVKiXIH7ymNsrmhBlCtaED4bon7JI8rn6N7esi8N/HOBe/vLiZ4NEfvWcMx++eSFQLvg3pt86Msnr5BJ/kpVAL9CI4pfKYnjX+gvnzzYiPIfz7j/yyevAAr/V8bREBgtvlG9UT2o/VqiGrC/+fJJRLN5RRz+g3ORHGyFa2JJPtxW+LhVHN43VwHP7c/ZV/lyNhdbXG05B8SZryY4d2siDrT2cQA9MIhc3CoOW7PFfgfLh5sgbXcNcGCgiptrCOLmWqK4ufZ/xE042NqfQ2y3bRsi27bRzBIHS594HaxP1H+RZTjYcr0+Ef3AE1IcQfacbS0XnwVf2hLEdgFRbBcQ9pxUtmhnec8pztyO4NztiTjQnqDn9M8HbcF9U9s4/MUEsr5fAzxvIQOuFxJwvYiI60WEfaIX97bbtpjItsX/o5bY+nBSB6C/kA8nOb5l80X29Zb3Y8K/1xPE0A1EMST2pXy4hOLLJzsCOWD7F3gKLnUk4FMnIj51iqP7Ej4vtmy37Y1Etr2RzrYlH6iBtG1TuR9UU47UqeuBvW5ny3tdcdbOBPy8iYifN8Xx+2LTmw+yWnIzAZ+6EPGpC2Et8WLLdtt2JbJtV0LbtgPX6UKinrobg/zfjeDctxBx6hZCbZfqy3K7H2T5vzsBn3oQ8akHoXbmxZbttu1JZNuePts6f2PjwHM6cK9eMDtkugk+O6gLHXO9wP7zVu84QsC94/D79gEOblTn7uOzMGjfUg+7ogOsE3CvW5kGGA536QC7LY4Q8G0EAdbX8gAT5+7LLMBuBO51O9MAw+EuHWB3xBECvoMgwPpZHmDi3P2IAoyiG+hL0C7fGccjsXQG7tWfaWLpT5RYBsQRAh5AkFgGWp5YxLkHMkksIgHeSZBYBjFJLDcB97qLaWK5iyix3B1HCPhugsQy2PLEIs49mEliEQlwEEFiuYdJYrkZuNe9TBPLvUSJ5b44QsD3ESSW+y1PLOLc9zNJLCIB3kOQWIYwSSxdgHsNZZpYhhIllgfiCAE/QJBYhlmeWMS5hzFJLCIBDiFILA8ySSxdgXsNZ5pYhhMllofiCAE/RJBYRlieWMS5RzBJLCIBPkiQWEYySSzdgHs9zDSxPEyUWEbFEQIeRZBYRlueWMS5RxMlFm+hA+wW4F6PMA0wHO7SAfZoHCHgRwkC7DHLA0yc+zFmAdYduNcYpgGGw106wB6PIwT8OEGAPWF5gIlzP8GkNR4tkwG6NR7LpDXuAdxrHNPEMo4osTwZRwj4SYLE8pTliUWc+ykmiUUkwLEEieVpJomlJ3CvZ5gmlmeIEsuzcYSAnyVILOMtTyzi3OOZJBaRAJ8mSCzPMUksvYB7TWCaWCYQJZaJcYSAJxIklkmWJxZx7klMEotIgM8RJJbJTBJLb+BeU5gmlilEiWVqHCHgqQSJZZrliUWcexqTxCIS4GSCxPI8k8TSB7jXC0wTywtEieXFOELALxIklpcsTyzi3C8xSSwiAT5PkFhejqM9d1B84rmTkQTnfgV3bpIvnRS8fJng3K9afm7hF4FRLUzhYMtF+vtVYF77X19miM4hHWF7FVJ80Z9EWfqL/l6TRng9ThrEq+LihRQFAPqD0BEfEvPnFw6F3deApHk9DufIf0NA5IfuhIMsNzPfMUTA6dIIM1QCzjgAAtrwKUUeAacDCTgjjsaRaMK9Bq52VDinE+FEV1Hkp2bNjENxu/TXTM+UcWmysnZy+FXWWdIIs9XENttAZUV8OpSX2GYBE9tsppUVRkCDlfUNaYQ3VQK+aaCyIgn4BpCAbzKprLOYVNY3mFRW5MflzSGqrHOiUFlvdPhV1rekEd5WE9vbBior4mPhvMT2FjCxvc20ssIIaLCyviON8K5KwHcNVFYkAd8BEvBdJpX1LSaV9R0mlRX5OZnvEVXW96JQWTs7/Crr+9IIc9XENtdAZUV8LqKX2N4HJra5TCsrjIAGK+s8aYT5KgHnG6isSALOAxJwPpPK+j6TyjqPSWVFflDsAqLKuoC6MESQzIT5KydrDjAuF+J4VOr7OcS+NShtGg4XvAeMgYVAmy4isukiepu6C4A2XQS06WIimy6WNjXZVd/k4JoxDVySpmaJNMJStalZaqCrRnwosNfULAGScinTrhpGQINd9QfSCMtUAi4z0FUjCfgBkIDLmHTVS5h01R8w6aqRn5L+IVFX/WEU9KqbHX6V9SNphOVqYltuoLIiPhXbS2wfARPbcqaVFUZAg5V1hTTCxyoBPzZQWZEEXAEk4MdMKutHTCrrCiaVFfk1ASuJKutKTVyC7VDwITCWVhHN7qsMFMiVQN6uAtp0NZFNV0eha+vi4Iq9Bi5J0fxEGmGNWjTXGCAl4isHvKL5CZCUa5h2bTACGuza1kojrFMJuM5A14Yk4FogAdcx6do+YdK1rWXStSG/g+VToq7t0yhU1q4Ov8r6mTTC52pi+9xAZUV854aX2D4DJrbPmVZWGAENVtYvpBG+VAn4pYHKiiTgF0ACfsmksn7GpLJ+waSyIr+EaD1RZV1vQA/5FBhLG4hm9w0GCuR6IG83AG26kcimG6PQtXVzcMVeA5ekaG6SRvhKLZpfGSAl4guNvKK5CUjKr5h2bTACGuzaNksjbFEJuMVA14Yk4GYgAbcw6do2MenaNjPp2pDf8LaVqGvbGoXKeovDr7Juk0b4Wk1sXxuorIhvMvMS2zZgYvuaaWWFEdBgZd0ujbBDJeAOA5UVScDtQALuYFJZtzGprNuZVFbkVzt+Q1RZv4lCZe3u8Kus30ojfKcmtu8MVFbEVxh6ie1bYGL7jmllhRHQYGX9XhrhB5WAPxiorEgCfg8k4A9MKuu3TCrr90wqK/I7XXcSVdadUaisPRx+lfVHaYRdamLbZaCyIr7D00tsPwIT2y6mlRVGQIOV9SdphN0qAXcbqKxIAv4EJOBuJpX1RyaV9ScmlRX5pcY/E1XWn+PoP4NjK8xfOVnfAOPyFxyPSt1di31rUNo0HC7YCYyBX4A2/ZXIpr/S29T9GWjTX4E23UNk0z1x5j+Do6eDa8Y0cEmamt+kEfaqTc1eA1014gusvabmNyAp9zLtqmEENNhV75NG+F0l4O8GumokAfcBCfg7k676NyZd9T4mXTWCj96Z/yDqqv+Igl7Vy+FXWT3DxIWc0olNvEBdWRHf4O4lNnGQoHt5pIwL8aysMAIarKwh+Uu8SsD4EH1lRRIwBCRgfIhHZXVCNBULjTMU4lFZEXzc/92ZIZrKmhCif8/JH8AuNRHn+1Kze6KBApkA5G0iMD8lEdk0KWS+a+vt4Iq9Bi5J0UyWv6SoRTPFACn9BgtaNJOBpExh2rXBCGiwa0uVv6SpBEwz0LUhCZgKJGAak64tmUnXlsqka0Pw0TtzOlHXlh6FytrH4VdZy8hfyqqJrayBytrHwSW2MsDEVpZpZYUR0GBlLSd/Ka8SsLyByookYDkgAcszqaxlmFTWckwqK4KP3pkrEFXWCgb0kHRgLB1GNLsfZqBAVgDy9jCgTQ8nsunhPpuiu7OXIhu+HIfPLUcAbfG/mgX4R2kAb1+7A/VLwPf/uN4/NGaE7e330ZHyl6PUJkb8B/URCvFHNRRQCRhw+0FycG7QvWqVwwWe3xegJjND4nSPBCbeo4AFAWC/UoGGTtivRDY8IoRP2BVDNLwJgXEieXM0kDcmJRXkl8Fp4KL2zvLbopL8pbJaDMR/qKa8Jv5INSS60iOS7p+TQHFhJSApK4fMJPBwsOUii1ZloP2OAdsPHbwi0R5NkMCrWH5u4ZcqBOeuSjR1VQ3981P58M9RA8ZU9zis7wLuZXz6OFb+Uk0tOMdqpo9qob9OH4kHoXODdvXHAhN5NSLSJRzy67/GVd3y4iIKy7EExaWG5ecWfqlBcO6aREW15gEUVQoboc6igUsyLR0nfzne51u4YWoQOfk4zUQnDhKvGA49kQDP4x4PTJ4n4HBl+m16gs+maFt6iSWoDbwJWex1XAibmI/3RQzo3CRJ2jt7iJDvQe15IlEuONHXWB+Mdj3J8gZCnPUkggaiFhGfapluINycIrQP1RVwb+30W1v+crI6/daWBvS/dnLor9MvtKAoRgw6ZdYGBujJQOea7GoRpMyTPx1DpKwjfzlFJWUdjSRzCjUpFSMGJWUdIClPATsXld1LurnCjGxhtzoh2iQR/i8rsof3T6Q/TrW8igv541SCKn4aURU/jbArrCK5ieoKvTiqAuTT6UR2Pf0AuqMQmCN1gFM3Is5MF7W68pewWtTqaopaOPTPTznZ6pCgBbIuMIDClhZI/2Vs3RCMePuXyfdNADpj45d+rvwlQw1GVxOMGQfQYSKNGDSAXGAAZQCda3LsOTnEr0Jkyl+yVFJmakiZZWDsQZIyE0jKLKBzTZIygyEps+UvOSopszWkzDFAygwgKbOBpMyxvNUQAZgdwqvgyMDODcFwldgQPcOIdi0T2DaL/XINt38Hy7NoHN8Jkyd/yVeTbZ4m2ebTtaX7E2QeMLjzgXsh333B7Yl80x1APflLfZWU9TSkrG+gAwA8Ub6f4PWApKxvqC1FV3Cqt7uF/+MyTfAG8pczVII30BD8jNBB9/7D/cHSABgsZxDNQuhkUy+E2wtpvzOBeyX4+K0udAU8E9ji+/GeFSIEfFYIv+/ZQAeSOcrwbII+Q36IXzU6R/5yrlqNztFUo3MNtFuAvn1/BTkHSPpzDVWQoDiRFQRpv/NC2KA2VUGQuP14zw8RAj6foIJcYHkFEee+gKCCUGA9W2JFq64NQ9hzh8D4qsgqj7Kj2K+h4a4BbRPgc7yIDsS4CtlI/tJY7UAaaTqQxgcwD9vqkKDdTCNgAm5MRBR0N4h8agjZzVzIdB6+kKibuShECPgigm6mieXdjDh3E8OVDX0GQJIxPg83lb9crFajpppqdLGBebgxsII0BZL+Yibz8DnACoK0XzOm8zAStx/vJSFCwJcQVJDmllcQce7mBBWEAmsTiRU9D1/KYB5uAp6HL+XcNbg5hY3BPlNXwL21XcNl8pcWatdwWeiv72ttESLuGhQjBu0aLgMmuhYh2kQU8C2EucJuospT+iP8X1ZkD++fyC7k8pDdhUEktMsJCsMV4C7Gi+0rQrRvIRS+D4H2pXgL4ZVEdr0yZP4thE2BhRkRZ6ZH4Zbyl1ZqUWupGYVbheiFWSqHBC2QLYEB1ApMFIq3ELY03GGiEp5ciPd0IBsa4zcuV8lfrlYD+ypNYF99AIEdDrbIHBI0sK8C4roaSBSTIm6LEL/K1Vr+co1K8NYagl9DPY4pRgxKytZAUl5D5Fy0/bKBlR9pv2uBe5kUca8Ft+neahMiBNwmhN/3OqADqc59neF2C32Gq0P8Kkhb+UuBWkHaaipIgYEKcjWwgrQFkr7AUAUJihNZQZD2axfCBrWpCoLE7cfbPkQIuD1BBSm0vIKIcxcSVBAKrNdJrGjRoiiEPXcIjK+KrPIoO4r9igx3DYfe6H/ge3j/0JiRpJsplr90ULuZYk030+EAupmgHUgxMGl2AO5F/TWLiK9DFN/SFcKQZT/mikAbXg9Ott5CJ10kB28AJm/KMyO/0a4j7sxZulgJB1uu4OENBM1EJzC/0ecWfulEcO4bwR2/V29u9NUbdF4TxRroLzLbdiaybefQP1+bHyxfPAb8eloXkPuMN4E3yV9uVpvAmzRN4M0h+lu/jkBJ6yZgYbvZ0obSs79O3kEnTts+pMdbfkJ3kb90FfxFZ+Sb/ibTh4Mtl7p7QHQ3NxFMGJ2AQdXN8g5MELMbQZdwC1GXIPa9U+6LtkVXIlt0J7JFd0JbiKRKYYuccnbHQ3eic+eWszuXUuWBvOieu/0/4COL+Xzwub2FbmyB8egCOe4CeeMifZEgOaibTp1/6Zt/4qZ/T4q6j7KJv8nv4YslfFEiKqR+0P8Ss/tP/zsCcw+CBFPPkgTzbxrgoGfuGbIzwSB94edlT1+D91/98082R/qnl28vNzMzEhuFuW5xYXFmdm5+Rjs3JzMnpzirODcnL6uwODuroDC3yM0qyMzIL8oNF7t5RUW52Zntc3OK8wvbR/4/n03dwszMrML8du3d7IycgnbhvMLMgnBxVm5mRrigMDO3sDAzLyenIDOzMCevOC8/LyOjoDgzL5ydm5sfzsnIzM+g8k8v6R+Taodl0uD+5S+IveUvfbgUAyp8vQkS/61ERfBWymkyVJoMKFvcRmSL2whtsZhowqxv+WTdkWjSamD5ZE2VB86wfLKmivkzmUzWwHh0gRx3gbxxzzw0WavL7U00WfflOFn3JZ6s+xIkmLMOwsn69pCdCeYsosntdmaT9R3AyfpM4GRN5Z87fJP13xUFmyVRSpxUBaYfxwLTj7jA9CMoMGcTFZhEME5kArsTuFeepd3w2UTJ8M4DKFZBbdo/hCsKpaRbi4oVlX/6G/APMhYHAJs9S++PS/lHnLeGQf+Egy0ymwb+WiFDg1FQnAOBsVIfaD+kinMuUawMDP37p/DDwZZtX+q431+LgXt1BHJS4xKU/bL8/h4kf7mL42AgwFdzSr9TQBwkXjEc+sMvkIXgLiBp7sbhyvTb9G6fTUOKLQN9wm1xcYmCMiiELdJ+DqD2PRiKBFXsC/+GCGMwqD8GE+Wnwb6m9GC06z0h+7l5D4H4cy8Rn+49gMYNaiM3pwjtQ3UF3Fv71sL75C/3h5zSzcF90oD+1+4P/XVyBH/ceikjBn1r4X3AAL0f6FyTH+GGIKXpj3AbIn8ZqpJySOiv73cdSk1KxYhBSTkESMqhYOeisrv8ToZsYbchIdokEf4vK7KH90+kPx6wvIqLt3I+QFDFhxFV8WGEXWEnyU1UV+jFEfLtsg8S2fXBA+iOUNOrd5YhQCUAEWemi9pw+ctDalEbrilqD4XoNXoqhwQtkMOBAfSQpQXS/5794SEY8fYvkx0msjPWwCUJxhHyl5FqMI7QBONIAx3m/cAAGgEMoJFMx577Q/wqxMPyl1EqKR/WkHIUM1I+DCTlKKBzTZJyJENSjpa/PKKScrSGlI8YIOVIIClHA0n5CHGrEQ62SgJwdAh/24MMbKQ/HgW2t2IP1Jzo7Slav4dD2P0eDdG0qCCM/+pTqMPBFovHKML/bRn/AMLH5C9j1CLwmKYIjDmAIhA0cT8GTBRjgEGI/hTqv7NfONhy6wHP3ADoi8eBe5n8To3HgUnSj/eJECHgJ0L4fccCHUh17rG+1Aba1+gYgUhYpseIcfKXJ9UKMk5TQZ40MEaMAY4R44Ckf5LIuei2vwGwgiDt9xS4XTVVQZC4/XifDhECfpqggjxjeQUR536GoIJQYB0rsaJnwmdD2HOHwPg6ySqPsqPY71nDXQPaJsCn0xAdiPEZdrz85Tm1Axmv6UCeC9Hfv1I5JGg3Mx6YgJ8jIgq6G0TehSO7mQlM5+EJRN3MxBAh4IkE3cwky7sZce5Jhisb+gyAJGN8Hp4sf5miVqPJmmo0xcA8/BywgkwGkn4Kk3l4HLCCIO03lek8jMTtxzstRAh4GkEFed7yCiLO/TxBBaHAOkliRc/DLzCYhyeB5+EXOHcNbk7hc2CfqSvg3tqu4UX5y0tq1/Bi6K/v1nopRP5urUJk1/AiMNG9FKJNRAHfGJMr7CaqPKU/wv9lRfbw/onsQl4O2V0YREJ7maAwvALuYrzYfiVE+8YY4fsQaF+KN8a8SmTXV0Pm3xgzGViYEXFmehR+Tf7yulrUXtOMwq+H6IVZKocELZCvAQPodTBRKJ46fM1wh4lKeHK5wPdOuOiGRl0B99YG9nT5yww1sKdrAnvGAQR2ONgic0jQwJ4ODOwZITPBgu46Xgrxq1wz5S+zVILP1BB8FvU4BiblTCApZxE5F20/5PsPkPabDQ5qUyIuErcf7xshQsBvhPD7vgkkA9W53zTcbqHPMCPEr4LMkb+8pVaQOZoK8paBCjIDWEHmAEn/lqEKgnwHWzjYgtrvbaYVBInbj/edECHgdwgqyLuWVxBx7ncJKggF1jclVrRo8R54SA+B8XWSVR5lR7Hfe0Q+9xaFDVB7vQ+0JQXPq0TwXU3A87khGl+ji3Fn4Nt2bwbuNY9pMUbi9uOdHyIEPJ+gGC+wvBiLcy8wPM6hEzVV8IaDLDfcXnN01N6lRsOF8pdF6mi4UDMaij9KUUChr8Vsy6Z/fix+2F0IDMZFISxR0IFdkSiwdViD2lJgXRiisQHq3Car5+o4muq5OEQIeDGBA5dYXj3FuZcYrp7o4FvNsOItlb98oFa8pZqK94Gm4qHnh9XAKrUUSPoPGFQpigDSYUVUqaUMqtTfJQ70BUBnXJVykTMzMKHRfWOYktCWyV8+VBPaMk1C+1CT0BKR4Jg4N2iiXQZMtB/iEq3RVrMykVDzUYgQ8EcEWXi55a2mOPdyw63mQSLUuJqjk2T5FfKXj9Usv0KT5T8+iIWaFcBg/BiXmV2mc5kxgq+Uv6xSCb5SQ/BVzOaylUBSrgphnUsx64j2KIQkizLrBPYtsHWhsKFIYisJbIhMjp+EDnUSwE4iQ3N0kkS7Rv6yVk20azSJdu1B3EmsAQbLWlzSzmDaSRgj+Dr5y6cqwddpCP4ps05iHZCUn4awzkWTTwTgOoIqiAzsz4g7iXCw5YpO57MQ3jefW35uoXd8DueO2/5zIHe+sNyG4qxfEHDnS+C5/bn8S5nLdQUSZZuSNFxcVBJXnxDYBsAJ4x96ul7+skEtuOs1BVf8UQ1ip6AL+BfBg37/+1XWAxPIBiBZTAYNiIzG30i1Uf6ySSX6Rg3RNxkgOmg23k/OjUBybgrhHGzyHX5fhPgR8yv5y2aVmF9piLnZR0xvoS/4kRnzKyApNxM5F22/jSHcXkj7bQHuZfKuegu45fTW1hAh4K0h/L7bgA6kOvc2YIvgLZMVZEOIXwX5Wv6yXa0gX2sqyHYDFWQDsIJ8DST9dkMVJChOZAVB2m9HCBvUpioIErcf7zchQsDfEFSQby2vIOLc3xJUEAqs2yRWtIr0XQh77hAY3+eyyqPsKPb7jsjn3qKwAWqv74G2RPKcWi39AVxM/q5DRPve0mcQMjVHR+1dqtvcKX/5Ue02d2q6TfFHB+szCDuBSeLHEI4oTJ9BMEbwXfKXn1SC79IQ/KcQr2cQdgFJ+VMI61w0+UQAivOGkGQJYwN7N3EVRJ9ddD4bcJhd0f38AOz+vK7F0ayAe2u1l5/lL7+oyeJnTbL4JYS/VvLAeY5BB9Fl5ewewzwCoc/dAnxub4G6n/362M/AZPQLMLCBvHERvvASw6EkaV6g/lX+skdNkr9qkuSe0F8FanTQ/AoMmj0xHDTRuMNHJCHTBP9N/rJXJfhvGoLvDdHfwPwSwgXLb8Bg2UvkXPTI9SswqJH22wceF0zdwCBx+/H+HiIE/HsIv+8fQDJQnfsPYKsRJsT6q8SKbv1FVNh8bqHI7yY4dxz43CEwvpJuEYfRFX6O8yqHgz27t9A28J8/6F4hpC19C12M44E4beuwvXXoBiucpTk6au9S3XqCJGii1/14P8V/ULt18UcH6w1WAjDZJMbjiML0BssYwZMkwZNVgidpCJ4cz+sGKwlIyuR4rHPR5BMBKM6LFiiRgZ0ST1sF0WcXHRRS6BZdVDywi5RCNcVb7rXaVarEnqYmi1RNshB/VEP+H1IIf3Hx+CC60vIbLI9A6HO3ZHKDlQpMRmnAUQHIG7cl7gYr41CSNC/wp0vsZdQkma5JkmXi6W+w0oFBUyaGgyYaN1iIJGSa4GUlwcupBC+rIXi5ePobrLR4XLCUBQZLOSLnokeudGBQI+1XHjwumLrBQuL2460QTwi4Qjx+38OAZKA692FEqj4aa7rEim79D2dwg5VCcO4jLL/BEv4GYnQPl/tRcN1baBscAcwfRzK5wToqhjtsbx26wQpna46O2rtUt15REvRotVuvqOnWjz6Ib7AqApPN0bjLgmymN1jGCF5JEryySvBKGoJXZnaDVQlIysrxWOeiyScCsBLBDRYysI9hdoMlOiik0C26qKPwN1jG3oNVRWKvqiaLKppkUZXwBitNtuPoILra8hssj0Doc7dmcoNVBZiMqgIDG8gbtzWz92DZniRNC/zHSuzV1CR5rCZJVjNwg3UsMGiqxXDQROMGC5GETBO8uiR4DZXg1TUEr2HgBqsq8AarOjBYajC5wToWGNRI+9UEjwseJ9WFDmokbj/e4+IJAR9HcIN1vOU3WOLcxzO5wTpWYkW3/icwuME6huDcJ1p+gyX8DcToniD3o+C6t9A2OBGYP05icoNVK4Y7bG8dusEK52iOjtq7VLdeWxL0ZLVbr63p1k8+iG+wagOTzcm4y4IcpjdYxgheRxL8FJXgdTQEP4XZDVYdIClPicc6F00+EYB1CG6wkIF9KrMbLNFBIYVu0UXVwt9gGXsP1mkS++lqsjhNkyxOJ7zBqirbcXQQtbH8BssjEPrc1zG5wToNmIxOBwY2kDfudczeg2V7kjQt8NeV2MNqkqyrSZJhAzdYdYFBE47hoInGDRYiCZkmuCsJnqES3NUQPMPADdbpwBssFxgsGUxusOoCgxppv0zwuOBxUl3ooEbi9uPNiicEnEVwg5Vt+Q2WOHc2kxusuhIruvXPYXCDdSrBuXMtv8ES/gZidHPkfhRc9xbaBrnA/JHH5AYrP4Y7bG8dusEK52qOjtq7VLdeTxK0vtqt19N06/UP4husesBkUx93WZDL9AbLGMEbSIKfoRK8gYbgZzC7wWoAJOUZ8VjnosknArABwQ0WMrDPZHaDJToopNAtuqh8/A2WsfdgnSWxn60mi7M0yeJswhus02U7jg6idpbfYHkEQp+7PZMbrLOAyehsYGADeeO2Z/YeLNuTpGmB/xyJ/Vw1SZ6jSZLnGrjBOgcYNOfGcNBE4wYLkYRME/w8SfDzVYKfpyH4+QZusM4G3mCdBwyW85ncYJ0DDGqk/S4AjwseJ9WFDmokbj/ehvGEgBsS3GA1svwGS5y7EZMbrHMkVnTr35jBDdaZBOe+0PIbLOFvIEa3sdyPguveQtvgQmD+uIjJDVaTGO6wvXXoBiucpzk6au9S3XpTSdCL1W69qaZbv/ggvsFqCkw2F+MuC/KY3mAZI3gzSfBLVII30xD8EmY3WM2ApLwkHutcNPlEADYjuMFCBnZzZjdYJR0UsKMQXVQTxjdYl0rsl6nJ4lJNsriM8AbrbNmOo4Oo2PIbLI9A6HN3YHKDdSkwGV0GDGwgb9wOzG6wbE+SpgX+FhL75WqSbKFJkpcbuMFqAQyay2M4aKJxg4VIQqYJfoUk+JUqwa/QEPxKAzdYlwFvsK4ABsuVTG6wWgCDGmm/luBxweOkutBBjcTtx9sqnhBwK4IbrKssv8ES576KyQ1WC4kV3fpfzeAGqznBuVtbfoMl/A3E6F4t96PgurfQNmgNzB/XMLnBujaGO2xvHbrBCudrjo7au1S33kYS9Dq1W2+j6davO4hvsNoAk811uMuCfKY3WMYI3lYSvEAleFsNwQuY3WC1BZKyIB7rXDT5RAC2JbjBQgZ2O2Y3WKKDQgrdoou6Fn+DZexTBNtL7IVqsmivSRaFhDdYl8l2HB1EHS2/wfIIhD53JyY3WO2ByagQGNhA3ridmH2KoO1J0rTAXySxF6tJskiTJIsN3GAVAYOmOIaDJho3WIgkZJrgHSTBr1cJ3kFD8OsN3GAVAm+wOgCD5XomN1hFwKBG2u8G8LjgcVJd6KBG4vbj7RhPCLgjwQ1WJ8tvsMS5OzG5wSqSWNGt/40MbrDaEZy7s+U3WMLfQIzujXI/Cq57C377AMwfNzG5wbo5hjtsbx26wQoXaI6O2rtUt95FErSr2q130XTrXQ/iG6wuwGTTFXdZUMD0BssYwbtJgt+iErybhuC3MLvB6gYk5S3xWOeiyScCsBvBDRYysLszu8ESHRRS6BZd1M34Gyxj78HqIbH3VJNFD02y6El4g1Uo23F0EN1k+Q2WRyD0uW9mcoPVA5iMeiIDGzgq3MzsPVi2J0nTAn8vib23miR7aZJkbwM3WL2AQdM7hoMmGjdYiCRkmuB9JMFvVQneR0PwWw3cYPUE3mD1AQbLrUxusHoBgxppv9vA44LHSXWhgxqJ24+3bzwh4L4EN1i3W36DJc59O5MbrF4SK7r1v4PBDVZ3gnP3s/wGS/gbiNG9Q+5HwXVvoW3QD5g/7mRyg9U/hjtsbx26wQq30xwdtXepbn2AJOhAtVsfoOnWBx7EN1gDgMlmIO6yoB3TGyxjBB8kCX6XSvBBGoLfxewGaxCQlHfFY52LJp8IwEEEN1jIwL6b2Q2W6KCQQrfoovrjb7CMvQdrsMR+j5osBmuSxT2EN1g9ZTuODqJult9geQRCn/sWJjdYg4HJ6B5gYAN5497C7D1YtidJ0wL/vRL7fWqSvFeTJO8zcIN1LzBo7ovhoInGDRYiCZkm+P2S4ENUgt+vIfgQAzdY9wBvsO4HBssQJjdY9wKDGmm/oeBxweOkutBBjcTtx/tAPCHgBwhusIZZfoMlzj2MyQ3WvRIruvV/kMEN1t0E5x5u+Q2W8DcQo/ug3I+C695C22A4MH88xOQGa0QMd9jeEnug43lhhHxLQ/jxVuyLwjiSmf4p4g8pk4gYHIHXP409wf+wxD5KnXwe1kw+owj1z3tkMkcHUU/L9U+PQOhz92Kifz4MLIijgIEN5I3bi9kT/LYnSdPy0GiJ/RE1SY7WJMlHDOifo4FB80gMB0009E9EEjJN8EclwR9TCf6ohuCPGdA/RwH1z0eBwfIYE/1zNDCokfYbw1T/ROL24308nhDw4wT65xOW65/i3E8w0T9HS6zo1n8sA/1zJMG5x1mufwp/AzG6Y+V+FFz3FtoG44D540km+udTMdxhe+vfPMEfDrbcbnG4vbrH0cSNgz1zlt+uT0uCPqN26+I/VFNeE3+kOiWBiUOCPSxdXPg0MNk8w7RzfYaoc302nhDwswSd63jLO1dx7vFMOteKkYyyLITv4J4j7lyD4lsROfNKghu5lcAbuQnMbuRER4gU7kVX+BQ8jtxiR7MC7q3V4iZK7JPU6j5Ro8VNIryRGyXHC3QQ3Wr5jZxHIPS5b2NyIzcRWCgnAQMbyBsX5wu3+FCSNH9hMVlin6ImycmaJDnFwI3cZGDQTInhoInGjRwiCZkm+FRJ8GkqwadqCD7NwI3cJOCN3FRgsExjciM3GRjUSPs9z1TXQOL2430hnhDwCwS6xouW6xri3C8a0jUQQfpiPL59Q/roJctv94SGM4FgfHqZ+HYvHGyVdIBAjO5Lcj/b7eitECHOoHu9wuSm8NWYH5dp8vaaCPnWEeiy64C67GsM8vZrBPnmdcvPLe5cXofXfLf968D8Nd1yG4qzTifgzgxwk+8NJ2Jf8alfJqQ7UceQMqioZa8SzBHTifoCB4NTq5LMlAV4lqqSzNSoJLMI70omETVrd1h+V/J3ZAz8Qa9EdyWJ4PNPB6piM4EFYxYw4QA56PYjfuSMS/J2QDhNy9KzJfY31IQ7W5Nw3zBw7zIbGDRvxHDQROPeBdFRmCb4m5Lgc1SCv6kh+BwD9y7ICvMmMFjmGLp3CQdb0ASBtN9bTO9dkLj9eN+OJwT8NsG89I7l9y7i3O8AWw1vmawgsxhWkHelzd9TK8i7mgrynoEKMgtYQd4Fkv49Jjf3s4FtIdJ+7zOtIO8TVZC58YSA5xJUkHmWVxBx7nmGbu7DwVZJNZ5HIETNJ751RtyuvANMUGK/+UQ+9xaFDVB7LWByU7zwIBD4xB7oeN4ZId8ugpviXcCb4kXgwk4tkor4QwrOIgYXwnOQuXfwLJbYl6gTwGLNBLCE8FbKcww6iAZafivlEQh97kFM3sGzGFgQlwADG8gbdxCzd/DYniRNyyRLJfYP1CS5VJMkPzBwk7QUGDQfxHDQROMmCZGETBN8mST4hyrBl2kI/qEBHXAJUAdcBgyWD5nogEuBQY2030dMdUAkbj/e5fGEgJcT6IArLNcBxblXGNIBEUEqsKLbN6SPPo6ntWE42Cp5EnwRwfi0klhLDQdbJR0gEKP7sdzPdjt6K0SIM+heq5josqtjflymydsJEbslEeTtJCAHP2Gmy4r4Q8o3IgZX43XZIkezAu6tncjWSOxr1YlsjWYiW0uoyy4hKgyDLddlPQKhz30PE112DTAZrQUGNpA3Ls4XbtGhJGletlonsX+qJsl1miT5qQFddh0waD6N4aCJhi6LSEKmCf6ZJPjnKsE/0xD8cwO67FqgLvsZMFg+Z6LLrgMGNdJ+XzDVZZG4/Xi/jCcE/CWBLrvecl1WnHs9E112ncSKbt+QPtrAQJf9hGB82mi5Liu4A8TobpD72W5Hb4UIcQbdaxMTXfarmB+XafJ2xYjdKhHk7UpADm5mpsuK+EPKNyIGv8Lrssael90isW9VJ7ItmolsK6Euu5aoMNxvuS7rEQh97iFMdNktwGS0FRjYQN64Q5g9L2t7kjQtW22T2L9Wk+Q2TZL82oAuuw0YNF/HcNBEQ5dFJCHTBN8uCb5DJfh2DcF3GNBltwJ12e3AYNnBRJfdBgxqpP2+YarLInH78X4bTwj4WwJd9jvLdVlx7u+Y6LLbJFZ0+4b00fcMdNnNBOPTD5brsoI7QIzu93I/2+3orRAhzsDvc2eiy/4Y8+MyTd6uHbFbHYK8XQfIwV3MdFkRf0j5RsTgj3hd1tjzsj9J7LvViewnzUS2m1CX3UpUGIZZrst6BEKf+0EmuuxPwGS0GxjYQN64DzJ7Xtb2JGlatvpZYv9FTZI/a5LkLwZ02Z+BQfNLDAdNNHRZRBIyTfBfJcH3qAT/VUPwPQZ02d1AXfZXYLDsYaLL/gwMaqT9fmOqyyJx+/HujScEvJdAl91nuS4rzr2PiS77s8SKbt+QPvqdgS67i2B8+sNyXVZwB4jR/V3uZ7sdvRUixBk4ryXw0GXjgDjtHJdp8na9iCMaEOTtBkAOhhKwjRa15CDiDynfiBiMS/h/vJh9zT0vGy+xJyQ4pacv8R/UiUz8UQ35f0gxzlIUhhGW67IegdDnHslEl41PwJ05AVhogLxxRzJ7Xtb2JGlatkqU2JPUJJmoSZJJCfS6bCIwaJJiOGiiocsikpBpgidLgqaoBE/WEDwlgV6XTUjABUsyMFhSiJyLHrkSgUGNtF8qeFwwpcsicfvxpiUQAk5LwO+bDiQD1bnT4fMYzXyfKLGi2zekj8ok0NowHGyV6LIhgvGpLPjcaB8L7gAxumXkfrbb0VshQpxB9yrHRJctH/PjMk3ebhpxRDMCXbYZUJetwEyXFfGHlG9EDJZnrMseJrEfrk5kh2kmssMJddkEosIw2nJd1iMQ+tyPMNFlDwMWxMOBgQ3kjfsIM13W9iRpWrY6QmI/Uk2SR2iS5JEGdNkjgEFzZAwHTTR0WUQSMk3woyRBK6oEP0pD8IoGdNnDgbrsUcBgqchElz0CGNRI+x3NVJdF4vbjrZRACLgSgS5b2XJdVpy7MhNd9giJFd2+IX10DANdtgLB+FTFcl1WcAeI0T1G7me7Hb0VIsQZdK+qTHTZY2N+XKbJ220ijmhLoMu2Beqy1ZjpsiL+kPKNiMFj8bqssc8xqC6x11AnsuqaiawGoS57OFFhGGO5LusRCH3ux5nostWBBbEGMLCBvHEfZ/Y5BrYnSdOyVU2J/Tg1SdbUJMnjDOiyNYFBc1wMB000dFlEEjJN8OMlQU9QCX68huAnGNBlawB12eOBwXICE122JjCokfY7kakui8Ttx3tSAiHgkwh02VqW67Li3LWY6LI1JVZ0+4b0UW0Gumw1gvHpZMt1WcEdIEa3ttzPdjt6K0SIM+hedZjosqfE/LhMk7e7RBzRjUCX7QbUZU9lpsuK+EPKNyIGT2H8vOxpEvvp6kR2mmYiO51Ql61BVBjGWa7LegRCn/tJJrrsacCCeDowsIG8cZ9k9rys7UnStGxVV2IPq0myriZJhg3osnWBQROO4aCJhi6LSEKmCe5KgmaoBHc1BM8woMueDtRlXWCwZDDRZesCgxppv0ymuiwStx9vVgIh4CwCXTbbcl1WnDubiS5bV2JFt29IH+Uw0GVPJRifci3XZQV3gBjdHLmf7Xb0VogQZ9C98pjosvkxPy7T5O0BEUcMItBlBwF12XrMdFkRf0j5RsRgPuPnZetL7A3Uiay+ZiJrQKjLnk5UGJ6xXJf1CIQ+97NMdNn6wILYABjYQN64zzJ7Xtb2JGlatjpDYj9TTZJnaJLkmQZ02TOAQXNmDAdNNHRZRBIyTfCzJEHPVgl+lobgZxvQZRsAddmzgMFyNhNd9gxgUCPtdw5TXRaJ24/33ARCwOcS6LLnWa7LinOfx0SXPUNiRbdvSB+dz0CXrUcwPl1guS4ruAPE6J4v97Pdjt4KEeIMuldDJrpso5gfl2ny9sII+ZaG8DEt9kRhbMxMlxXxh5RvRAw2Yvy87IUS+0XqRHahZiK7iFCXbUBUGCZYrst6BEKfeyITXfZCYEG8CBjYQN64E5k9L2t7kjQtWzWR2JuqSbKJJkk2NaDLNgEGTdMYDppo6LKIJGSa4BdLgjZTCX6xhuDNDOiyFwF12YuBwdKMiS7bBBjUSPtdwlSXReL2422eQAi4OYEue6nluqw496VMdNkmEiu6fUP66DIGumxjgvGpheW6rOAOEKN7mdzPdjt6K0SIM+helzPRZa+I+XFZ3/mr01g42HI7RTafEcLt935kr7nA/QS3kdKI4PcVRDVWXQH31k47V0rsLdVp50rNtNOSUPP0iINOulMs1zw9gqPPPdXyc19EVGSnWX5uL2Ggz/08kcadhMG5X4G4EthctAQmcmCecIGx5wL57D5P3EygG3uqZsIB4TQtTbaSxfoqtVi30hTrqwxo762AwXxVDAfz/9Le0UFje4drOmiulthbq0FztSZoWhsImquBQdM6IXYrzYHcDYSDLWgCQ/r1GqZ3A0jcfrzXJhACvpbgbqCN5XcD4txtCHQLk7fLiPbfdDW6Ttq8rVqNrtNUo7YGbpdbAm+XrwOSvi2T2+VWwAqMtF8B0wpSQFRB2iUQAm5HUEHaW15BxLnbG7pdDgdbJdW4PYHoVkh8Mxr4K6BDf1Z5lB3FfoWGuwZ0wesQh9urYxzOVxvjcB2Hxowk3UyR5EKx2s0UabqZYk03k4gBtx8kB+cG7bKKgIWhOAFHjP8VxGiRi8rP4f+4TI8RHWTgXa8GXgdN4F1/AKJWONiyLfD2B0sHYLBcDxxJTM7JGxkS/AZJ0I4qwW/QELyjgTkZmcFvAJKyo6E5ORxslQrEcLAFtV8n4F4m5+RORHPyjQmEgG8kmJM7Wz4ni3N3Zq60FifwqyA3SZvfrFaQmzQV5GYDFaQYqLTeBCT9zUyUVmQFQdqvC1OltQtRBemaQAi4K0EF6WZ5BRHn7sZEae0ssaKV1lsYKK2dwUrrLYa7BrRIg3w8sxjsf3UF3FvbgXSX/uuhdiDdNR1IDwMiDZVDgnYz3YEJuAcRUdDdIPKuF9nN9GTazfQk6mZ6JRAC7kXQzfS2vJsR5+7NfB5GJBnT83AfafNb1WrUR1ONbjUwD/cAVpA+QNLfymQevg5YzZH2u41pBbmNqIL0TSAE3JeggtxueQUR576dyTzcW2JFz8N3MJiHe4Pn4TsOdQ37lwYurGj5bdFP2vxOtWvop+kaxB9VV0BZ2DVk5sq9+gET3Z0JBy0pM7x/OHhS7t/bb4v+kpQDVFL215BS/FFNx3pSul4r2x9IygFg54LJlyECUJwX3RojAxvpj4HAikjgj5IqO5BJZzU6suFjcfjOalCC3ed+IrLhIIKO8i7Lz/1UZMO7CM59t+XnHh/Z8G6Ccw+2/NyTIhsOJjj3PZafe1pkw3sIzn2v5efuE9mwL0E+v8/yc/eLbHgfgb/vt/zcAyMb3k9w7iGWn3twZMMhBOceavm5749sOJTg3A9Yfu5hkQ0fIDj3MOJzB8X3UmTDewnO/aDlM9SIyIbDCM49nEg9pFB+UXs9ZLmvBReHE/h6hCExEa2DdQO+C6x7HM6ee4LjMv7e2pFSh3lYFTlHakTOhw08PcbBuUH3mk70KZoggXP/8w4jgaLkw8AkC7BfqUBDJ2xRUEYQJOxRTIozkjejgbwxeeO1J47GVw4WZ5bfFo/IZP6oWgzEf6imvCb+SDUkutIjkm5RcckqfARIykeZPP6LLFqPAu33mOXTtEi0owkS+BjLzy38Mobg3I+DH3rzctDjsiH9N9NH0LN0A8ZU9zis7wLuZXz6eEIWnLFqwXlCM32MTfjnT/Y5GJwbtKt/ApjIxxKRLuGQX/81rnGWFxdRWJ4gKC5PWn5u4ZcnCc79FFFRfeoAiiqFjVBn0cAlmZaelknqGZ9v4YZ5ksjJT2smumd8z8h5Cz2RAM/jPgNMns/icGX6bfqsz6ZoW3qJJagNvAlZ7PV0AjYxP5Pw/1wCnZskSXtnDxHyPag9xxPlgvG+xvpgtOtzljcQ4qzPETQQE4j4NMF0A+HmFD1ndwOhnX4nytw4SZ1+J0oD+l+blED8XlnFiEGnzInAAJ1k6KIaHbgIUpp+A/dkScopKiknaySZKdSkVIwYlJSTgaScAnYuKruXdHOFGdnCbpMTaJNE+L+syB7eP5H+mMpA/phKUMWnEVXxaYRd4RjJTVRX6MXRGCCfniey6/MH0B2hL+QnA6fuqQyL2guyqL2oFrUXNEXtxQN4yslWhwQtkC8AA+hFSwuk/zL2BQJ54t90mBZ0xsYv/V6SNn9ZDcaXNMH48gF0mEgjBg2gl4AB9DLQuSbHnkkMK8QrkpSvqqR8RUPKVw2MPUhSvgIk5atA55ok5csMSfmaJOXrKilf05DydQOkfBlIyteApHzd8lZDBOBrBCo4MrCng+dn9Awj2rVXgG2z2G+64fbvYHkWjeM7YWZILsxUk+0MTbKdSdeW7k+QM4DBPROZKIDvvjDZASCeyDfdAcySpJytknKWhpSzDXQAgCfK9xN8FpCUs4naO7T9GoRweyHt9wZwrwTH3MepvgFWab31ZgIh4DcT8PvOATqQ6txzoqy2hYMtdybDGfItafO31QrylqaCvG2gggBakf0V5C0g6d82VEGC4pwFnIGQ9nsnARvUpirIO0QV5N0EQsDvElSQ9yyvIOLc7xFUEAqscyRWtJD0PgORZg5YpHnfcNeAtgnw0UREB2JcWJkr/TdP7UDmajqQeQYu36kcErSbmQtMwPOIiILuBidb2s3MZzoPzyfqZhYkEAJeQNDNLLS8mxHnXsh8HgYkGePz8CJp88VqNVqkqUaLDczD84AVZBGQ9IuZzMNvASsI0n5LmM7DS4gqyNIEQsBLCSrIB5ZXEHHuD5jMwwslVvQ8vIzBPLwQPA8v49w1uDmF88A+U1fAvbVdw4fS5h+pXcOHCX99q95H1F2DYsSgXcOHwET3UQJtIgr4rqhcYTdR5Sn9Ef4vK7KH909kF7I8we7CIBLacoLCsALcxXixvSKB9l1RixLsflfUx0R2/TjB/LuiFgELMyLOTI/CK2VRW6UWtZWaUXiVAWGWyiFBC+RKYACtAhOF4l1RK6N84xIOthCPqSMbGuM3Lqul/z5RA3u1JrA/OYDADgdbZA4JGtirgbg+ARLFpIj7EcPKtUYSdK1K8DUagq81IOIiSbkGSMq1hkTccLBV6s1A4WALar91TK8B1xGJuJ8mEAL+NAG/72eWi7ji3J9xFvQiZ/iEYQX5XNr8C7WCfK6pIF8YqCCfACvI50DSf8HkGhBZQZD2+5LpNeCXRBVkfQIh4PUEFWSD5RVEnHsDk2vAzyRWtGixkcE14Gfga8CNhruGQ+9dPvA9vH9ozEjSzWySXPhK7WY2abqZrw6gmwnagWwCJs2vgHtRf3Mc4hveRifgFdFRQBtuJrq/RyddJAe3AJM35ZmRX9K1FXfmLF2shIMtV/BwC0Ezsc3yK3Phl20E5/6a6Gr3a1+9Qec1UayB/iKz7XYi224/gGtz9C1tDDdu+/cC5D7jTeAO6ehv1CZwh6YJ/MbArd9WoKS1A1jYvrG0oVSVEf9CJ06qr9kOB1x+Qn8rDfKd4C86I+/4m0wfDrZc6u4B0d3sIJgwtgGD6nvLOzBBzO8JuoQfiLoEse+dcl+0Lb4jssVOIlvsJLSFSKoUtphXzu546E507vnl7M6lVHlgQXTP3f4f8JHF/ELwub2FbmyB8egCOe4CeeMifeENJLrp1PmXvvknbvr3pKj7KJv4m/wffbEEB/09USH1g/6XmN1/+t8RmH8kSDCLLEkw/6YBDnrmXQl2JhikL/y83OVr8P6rf/7J5kj//OTby83MjMRGYa5bXFicmZ2bn9HOzcnMySnOKs7NycsqLM7OKijMLXKzCjIz8otyw8VuXlFRbnZm+9yc4vzC9jnF/qTtFmZmZhXmt2vvZmfkFLQL5xVmFoSLs3IzM8IFhZm5hYWZeTk5BZmZhTl5xXn5eRkZBcWZeeHs3Nz8cE5GZn4GlX9+kv4xqXZYJg3uX/6CuFsa5GcuxYAK326CxP8LURH8hXCaFLb4mcAWvxLZ4ldCW+whmjAXWz5ZbyWatJZYPllT5YGllk/WVDH/AZPJGhiPLpDjLpA37geHJmt1ubuJJus9HCfrPcST9R6CBLPsIJysf0uwM8EsI5rcfmM2We8FTtYfACdrKv/s9U3Wf1cUbJZEKXFSFZh9HAvMPuICs4+gwHxIVGASwTiRCex34F4LLO2GPyRKhr8fQLEKatM/EnBFoZR0a1GxovLPHwb8g4xFkShQnLf0/riUf8R5axj0TzjYIrNp4A/gMzQYBcUZl0ijqlqkVLrLiWIlLvHfP4UfDrbIHuAN6q89wL22IvO3ZoHsl+X3d0g2lPGJDAcDAb6aU/qdAuIg8Yrh0B9+gSwE8cBEloAr+pl+myb4bKredQf6hNvi4hIFJZSILdJ+DqD2PRiKBFXsC/+GCPZF+SMxkSY/Jfqa0oPRrkmJ9nMzKREv/iQT8Sn5ABo3qI3cnCK0D9UVcG/tWwtTZFOTmuiUbg5SpAH9r6UmEn9almLEoG8tTAEWy1Sgc42RMmIDBClNf4RbmiRlukrKtMS/vt81nZqUihGDkjINSMp0sHNR2V1+J0O2sFtaIm2SCP+XFdnD+yfSH2Usr+LirZxlCKp4WaIqXpawKxS2SAN2hV4cId8uW47IruUOoDtCTa/eWdKAMnsZhkWtvCxqFdSiVl5T1CoY0OipHBK0QJYHJuQKlhZI/3v2PWIAiLd/mewwU8FFT10B99YG42HS5oerwXiYJhgPN9BhpgID6DBgAB3OdOxJZVghjpCkPFIl5REaUh7JjJRHAEl5JNC5Jkl5OENSHiVJWVEl5VEaUlY0QMrDgaQ8CkjKisStRjjYKgnAowhue5CBjfTH0cD2VuyBvj0Qrd8Ridj9jk6kaVFBGP/Vp1CHgy0Wj1GE/9sy/gGElWQRqKwWgUqaIlD5AIpA0MRdCZgoKgODEP0p1H9nv3Cw5TYI4faaBRS8jkE+4uGY+06NY8BCnbeqJBICrpKI37cq0IFU567KXHCpzHCMOFbavJpaQY7VVJBqBsaIysAx4lgg6asRORfd9iMrCNJ+1cGClakKUp2ogtRIJARcg6CC1LS8gohz1ySoIBRYq0qs6JnwOLDkj75rFDNrVfBsfZzhrgFtE+DTaYgOxPgMe7z03wlqB3K8pgM5wcD9K5VDgnYzxwMT8AlEREF3g8i7cGQ3cyLTefhEom7mpERCwCcRdDO1LO9mxLlrMZ+HAUnG+DxcW9r8ZLUa1dZUo5MNzMMnACtIbSDpT2YyDx8LrCBI+9VhOg/XIaogpyQSAj6FoIKcankFEec+lck8XEtiRc/DpzGYh2uB5+HTOHcNbk7hCWCfqSvg3tqu4XRp87pq13B64l/frVWXumtQjBi0azgdmOjqJtImooBvjMkVdqudSOuP8H9ZkT28fyK7kHCi3YVBJLQwQWFwwV2MF9tuIu0bY4TvQ6B9Kd4Yk0Fk14xE82+MqQ0szIg4Mz0KZ8qilqUWtUzNKJxlQJilckjQApkJTMhZxE+rIjrWzCjfuISDLRf43gm3LsNuNVv6L0cN7GxNYOccQGCHgy0yhwQN7GxgYOckmgkWdNdRl2HlypUEz1MJnqsheJ4BERdJylwgKfMMibjhYAv6fhCk/fKZirhI3H689RIJAdcjEHHrWy7iinPXZ34NmMOwgjSQNj9DrSANNBXkDAMVJAdYQRoASX8Gk2vAo4AtJtJ+ZzKtIGcSVZCzEgkBn0VQQc62vIKUOIrJNWB9iRUtWpzD4BqwPvga8Bwin3uLwgaovc4F2pKC52MiZ/2E4BtbzrP8NmdBhDSjEhwSXqJtuVBiRdtgVALPgp8Uoin45ycSAj6foOBfYHnBF+e+IMojY+BH8FFkc8PtNXBRe5caGRtKmzdSR8aGmpFR/FGKAgo98viNGOwj7sNuQyDpGyVinUuRoS8w1DEHtaXA2jDR/ir1d4kDLZN0jsPtdXOclQmN7ntVlITWWMbAhWpCa6xJaBdqElriQejcoIm2MTDRXohLtEZbzUeJvjn0okRCwBcRZOEmlrea4txNDrWa0hqlv68dahMlMzeVNr9YzcxNNZn5YmatZlMg6S9OxDqXon1rnIh/wmkUUExrRiwqBcW3IvQn79E2XBHCYbwk8aBPjhkauCTJsblMjpeqybG5Jjleyiw5Ngcmx0sTsc5Fk29N6E+foQN7DTCwL7NccRfJ+zKCG7UWlp9bdKUt4Nxx27cAxt/llttQnPVyAu5cQfQekStkLtcVSJRt/vzGz6KSuLqEwDYAThj/AJ8rZcFtqRbcKzUFtyXBG6RUp6AL+OXAZ6+uBCaQlkCymAwaEBmNPxTYSmK/SiV6Kw3RrzJA9BCG6PvJ2QpIzquADwaafFr18kR+xLxaErO1SsyrNcRs7SOmt9DXMMiMeTWQlK2ZvN+hFfABJqT9rgHuZfJG4Rpwy+mtaxMJAV9LcKPQxvIbBXHuNlG+UQgHW25LhhXkOmnztmoFuU5TQdoaqCAtgRXkOiDp2zJ5vwOygiDtVwBWwk1VkAKiCtIukRBwO4IK0t7yCiLO3d7Q01vhYKukGrcnUJEKwcpiCIyvhazyKDuK/QqJfO4tChug9iqy9P0O1Gpp8aFr1UwNXNTepTrEDjK+rlc7xA6aDvF6ZteqHYDBeH0i1rlo8u0M/ekz9LXqTuC16g3EgY0+u0jmLYFJWCT0YmBB8xKxo1kB99aOkx0l9k5qsuioSRadCJRyD5znGHQQbSiHIyjFuT0Coc+9EXxub4E+Km7/yN8RmNA7AQMbyBsX4QsvMRxKkuY1txsl9s5qkrxRkyQ7azQ3dNDcCAyazjEcNNG4lkQkIdMEv0kS/GaV4DdpCH6zAVG5E1BUvgkYLDczEZVvBAY10n5dmIrKSNx+vF0TCQF3JRCVu1kuKotzd2MiKt8osaJb/1sS7T63EBlvIDh3d8vFdOFvIEb3FrkfBde9hbZBd2D+6AEW072FLsY9Y7jD9hZTUT5LAxe1d6kOu5eM095qh91L02H3ZibK9wIGde9ErHPR5EuI/9NnaM1F7IvC2IeZKC+KAlK7E4WhJ16Up3hjpHYcv1Viv01NFrdqksVthKJ8J9lhoINos+WivEcg9Lm3MBHlbwUm9NuAgQ3kjbsFJ8pnHEqS5jXLvhL77WqS7KtJkrcbEOX7AoPm9hgOmmiI8ogkZJrgd0iC91MJfoeG4P0MiPK3AUX5O4DB0o+JKN8XGNRI+93JVJRH4vbj7Z9ICLg/gSg/wHJRXpx7ABNRvq/Eim79BzIQ5fsQnHuQ5aK88DcQoztQ7kfBdW+hbTAImD/uYiLK3x3DHba3mIry2Rq4qL1LddiDZZzeo3bYgzUd9j3MRPnBwKC+JxHrXDT5Ksb/6TO05lIRKMrfy0yUF0UBqd2JwnA3XpQ39qT8fRL7/WqyuE+TLO4nFOVvkx0GOoi+tlyU9wiEPvd2JqL8fcCEfj8wsIG8cbcze1Le9iRpWrMcIrEPVZPkEE2SHGpAlB8CDJqhMRw00RDlEUnINMEfkAQfphL8AQ3BhxkQ5e8HivIPAINlGBNRfggwqJH2e5CpKI/E7cc7PJEQ8HACUf4hy0V5ce6HmIjyQyRWdOs/goEofy/BuUdaLsoLfwMxuiPkfhRc9xbaBiOB+eNhJqL8qBjusL3FVJTP0cBF7V2qwx4t4/QRtcMeremwH2Emyo8GBvUjiVjnoslXO/5Pn6E1l9pAUf5RZqK8KApI7U4UhlF4Ud7Yk/KPSexj1GTxmCZZjCEU5e+XHQY6iL61XJT3CIQ+93dMRPnHgAl9DDCwgbxxv2P2pLztSdK0Zvm4xP6EmiQf1yTJJwyI8o8Dg+aJGA6aaIjyiCRkmuBjJcHHqQQfqyH4OAOi/BigKD8WGCzjmIjyjwODGmm/J5mK8kjcfrxPJRICfopAlH/aclFenPtpJqL84xIruvV/hoEo/yjBuZ+1XJQX/gZidJ+R+1Fw3VtoGzwLzB/jmYjyz8Vwh+0tpqJ8rgYuau9SHfYEGacT1Q57gqbDnshMlJ8ADOqJiVjnoslXL/5Pn6E1l3pAUX4SM1FeFAWkdicKw3N4Ud7Yk/KTJfYparKYrEkWUwhF+TGyw0AH0U7LRXmPQOhz/8hElJ8MTOhTgIEN5I37I7Mn5W1PkqY1y6kS+zQ1SU7VJMlpBkT5qcCgmRbDQRMNUR6RhEwT/HlJ8BdUgj+vIfgLBkT5KUBR/nlgsLzARJSfCgxqpP1eZCrKI3H78b6USAj4JQJR/mXLRXlx7peZiPJTJVZ06/8KA1F+EsG5X7VclBf+BmJ0X5H7UXDdW2gbvArMH68xEeVfj+EO21tMRfk8DVzU3qU67OkyTmeoHfZ0TYc9g5koPx0Y1DMSsc5Fk69p/J8+Q2suTYGi/ExmorwoCkjtThSG1xmL8rMk9tlqspilSRazCUX5KbLDQAfRbstFeY9A6HP/zESUnwVM6LOBgQ3kjfszM1He9iRpWrN8Q2J/U02Sb2iS5JsGRPk3gEHzZgwHTTREeUQSMk3wOZLgb6kEn6Mh+FsGRPnZQFF+DjBY3mIiyr8BDGqk/d5mKsojcfvxvpNICPgdAlH+XctFeXHud5mI8m9IrOjW/z0GovxMgnO/b7koL/wNxOi+J/ej4Lq30DZ4H5g/5jIR5efFcIftLaaifL4GLmrvUh32fBmnC9QOe76mw17ATJSfDwzqBYlY56LJ1yb+T5+hNZc2QFF+ITNRXhQFpHYnCsM8vChv7ONrFknsi9VksUiTLBYTivKzZYeBDqI9lovyHoHQ5/6NiSi/CJjQFwMDG8gb9zdmH19je5I0rVkukdiXqklyiSZJLjUgyi8BBs3SGA6aaIjyiCRkmuAfSIIvUwn+gYbgywyI8ouBovwHwGBZxkSUXwIMaqT9PmQqyiNx+/F+lEgI+CMCUX655aK8OPdyJqL8EokV3fqvYCDKLyQ498eWi/LC30CM7gq5HwXXvYW2wcfA/LGSiSi/KoY7bG8xFeULNHBRe5fqsFfLOP1E7bBXazrsT5iJ8quBQf1JIta5aPJ1if/TZ2jNpQtQlF/DTJQXRQGp3YnCsAovyht7Un6txL5OTRZrNcliHaEov1h2GOgg+t1yUd4jEPrcfzAR5dcCE/o6YGADeeP+wexJeduTpGnN8lOJ/TM1SX6qSZKfGRDlPwUGzWcxHDTREOURScg0wT+XBP9CJfjnGoJ/YUCUXwcU5T8HBssXTET5T4FBjbTfl0xFeSRuP971iYSA1xOI8hssF+XFuTcwEeU/lVjRrf9GBqL8GoJzb7JclBf+BmJ0N8r9KLjuLbQNNgHzx1dMRPnNMdxhe4upKN9OAxe1d6kOe4uM061qh71F02FvZSbKbwEG9dZErHPR5BsQ/6fP0JrLAKAov42ZKC+KAlK7E4VhM16UN/ak/NcS+3Y1WXytSRbbCUX5dbLDQAdRqLzdHapHIPS548Hn9hZaX/wamNC3AwMbyBsX4QuTT8rbniRNa5Y7JPZv1CS5Q5MkvzEgyu8ABs03MRw00RDlEUnINMG/lQT/TiX4txqCf2dAlN8OFOW/BQbLd0xE+R3AoEba73umojwStx/vD4mEgH8gEOV3Wi7Ki3PvZCLK75BY0a3/jwxE+W0E595luSgv/A3E6P4o96PgurfQNtgFzB8/MRHld8dwh+0tsQc6nhdGyNeQQP9cGMJh/JmZ/iniDymTiBjczfih5F8k9l/VyecXzeTzK6H+uV0mc/gNluX6p0cg9LmTmeifvwAL4q/AwAbyxk3G6Z/uoSRpXh7aI7H/pibJPZok+ZsB/XMPMGh+i+GgiYb+iUhCpgm+VxJ8n0rwvRqC7zOgf/4K1D/3AoNlHxP9cw8wqJH2+52p/onE7cf7RyIh4D8I9E8nyW79U5xbYHSw+5Jg3SOxolv/uCT79c+fKR51AZ8brf0JfwMxusLPISKuewttgxAwf8QDbek/M7oYJwBx2tZhe0vsgc4ToyIVvjFBnkgkzo+BP+kpEnRNCXTfpsBGLikJ28hRSxoi7yDlIZF7EuC51y12NCvg3tqJL1liT0lySk93yUl/nfjEH9WQ/4cU43KIoAlKszy5eQRCnzudie6bDGwEUoAFFsgbF+cLt/hQkjQvi6VK7GlqkkzVJMm0JHrdNxUYNGkxHDTR0H0RScg0wdMlwcuoBE/XELxMEr3um5KEC5Z0YLCUIXIuetRMBQY10n5lweOCKd0XiduPt1wSIeBySfh9y1uu+4pzlzek+yKCVGBFt29IH1WwXEMWGk4Swfh0GLGGHA62SjpAIEa3gtzPdjt6K0SIM+hehzPRo4+I+XGZJm+viZCvOYEu2xyoyx7JIG8fSZBvjrL83OMjQXwUvOa77Y8C5q+KlttQnLUiAXeOBjf53nAi9hWfLWNCuhN1DCmDilp2BMEcUZGoL3AwOLUqSSU5V1RWVZJKGpWkMuFdSQpRs1bO8ruSvyNj0HOXJ7orSQSfvyJQFasELBiVgQkHyEEX6VfOydsB4TQtSx8jsVdRE+4xmoRbxcC9yzHAoKkSw0ETjXsXREdhmuBVJcGPVQleVUPwYw3cuyArTFVgsBxr6N4lHGxBEwTSftWY3rsgcfvxVk8iBFydYF6qYfm9izh3DYJ7F5MVpDLDClJT2vw4tYLU1FSQ4wxUkMrAClITSPrjmNzcHwNsC5H2O55pBTmeqIKckEQI+ASCCnKi5RVEnPtEQzf34WCrpBqfSCBEnUR864y4XakBTFBiv5OIfO4tChug9qrF5Ka49kEg8Ik90PG8M0K+DgQ3xR2AN8Ungws7tUgq4g8pOIsYrA3PQebewVNHYj9FnQDqaCaAUwhvpTzHoIPoCMtvpTwCoc99JJN38NQBFsRTgIEN5I17JLN38NieJE3LJKdK7KepSfJUTZI8zcBN0qnAoDkthoMmGjdJiCRkmuCnS4LXVQl+uobgdQ3ogKcAdcDTgcFSl4kOeCowqJH2CzPVAZG4/XjdJELALoEOmGG5DijOnWFIB0QEaUYSvn1D+igzidaG4WCr5EnwkwnGpyxiLTUcbJV0gECMbqbcz3Y7eitEiDPoXtlMdNmcmB+XafJ2QsQRvQh02V5AXTaXmS4r4g8p34gYzMHrskWOZgXcWzuR5Uns+epElqeZyPIJddlTiArD0Zbrsh6B0OeuxESXzQMWxHxgYAN54+J84RYdSpLmZat6Ent9NUnW0yTJ+gZ02XrAoKkfw0ETDV0WkYRME7yBJPgZKsEbaAh+hgFdNh+oyzYABssZTHTZesCgRtrvTKa6LBK3H+9ZSYSAzyLQZc+2XJctcRQTXbaexIpu35A+OoeBLptLMD6da7kuK7gDxOieI/ez3Y7eChHiDLrXeUx02fNjflymydsVI44YTKDLDgbqshcw02VF/CHlGxGD5zN+XrahxN5IncgaaiayRoS6bD5RYahiuS7rEQh97qpMdNmGwILYCBjYQN64VZk9L2t7kjQtWzWW2C9Uk2RjTZK80IAu2xgYNBfGcNBEQ5dFJCHTBL9IEryJSvCLNARvYkCXbQTUZS8CBksTJrpsY2BQI+3XlKkui8Ttx3txEiHgiwl02WaW67Li3M2Y6LKNJVZ0+4b00SUMdNkLCMan5pbrsoI7QIzuJXI/2+3orRAhzqB7XcpEl70s5sdlmrxdO+KI0QS67GigLtuCmS4r4g8p34gYvIzx87KXS+xXqBPZ5ZqJ7ApCXbYRUWGobrku6xEIfe4aTHTZy4EF8QpgYAN549Zg9rys7UnStGx1pcTeUk2SV2qSZEsDuuyVwKBpGcNBEw1dFpGETBO8lST4VSrBW2kIfpUBXfYKoC7bChgsVzHRZa8EBjXSflcz1WWRuP14WycRAm5NoMteY7kuK859DRNd9kqJFd2+IX10LQNdtgXB+NTGcl1WcAeI0b1W7me7Hb0VIsQZdK/rmOiybWN+XCZ6n0PEERMIdNkJQF22gJkuK+IPKd+IGGzL+HnZdhJ7e3Uia6eZyNoT6rJXEBWG4y3XZT0Coc99AhNdth2wILYHBjaQN+4JzJ6XtT1JmpatCiX2IjVJFmqSZJEBXbYQGDRFMRw00dBlEUnINMGLJcE7qAQv1hC8gwFdtj1Qly0GBksHJrpsITCokfa7nqkui8Ttx3tDEiHgGwh02Y6W67Li3B2Z6LKFEiu6fUP6qBMDXbaAYHy60XJdVnAHiNHtJPez3Y7eChHiDLpXZya67E0xPy7T5O2mEUdMJ9BlpwN12ZuZ6bIi/pDyjYjBmxjrsl0k9q7qRNZFM5F1JdRl2xMVhlqW67IegeAP2zPRZbsAC2JXYGADeePWZqbL2p4kTctW3ST2W9Qk2U2TJG8xoMt2AwbNLTEcNNHQZRFJyDTBu0uC91AJ3l1D8B4GdNmuQF22OzBYejDRZbsBgxppv55MdVkkbj/eXkmEgHsR6LK9Lddlxbl7M9Flu0ms6PYN6aM+DHTZmwnGp1st12UFd4AY3T5yP9vt6K0QIc6ge93GRJftG/PjMk3ebhNxxHwCXXY+UJe9nZkuK+IPKd+IGOyL12WNfY7BHRJ7P3Uiu0MzkfUj1GW7EhWGUyzXZT0Coc99KhNd9g5gQewHDGwgb9xTmX2Oge1J0rRsdafE3l9NkndqkmR/A7rsncCg6R/DQRMNXRaRhEwTfIAk+ECV4AM0BB9oQJftB9RlBwCDZSATXfZOYFAj7TeIqS6LxO3He1cSIeC7CHTZuy3XZcW572aiy94psaLbN6SPBjPQZW8nGJ/usVyXFdwBYnQHy/1st6O3QoQ4g+51LxNd9r6YH5dp8naXiCNWE+iyq4G67P3MdFkRf0j5RsTgfYyflx0isQ9VJ7IhmolsKKEu24+oMNS1XJf1CIQ+d5iJLjsEWBCHAgMbyBs3zOx5WduTpGnZ6gGJfZiaJB/QJMlhBnTZB4BBMyyGgyYauiwiCZkm+IOS4MNVgj+oIfhwA7rsUKAu+yAwWIYz0WUfAAY10n4PMdVlkbj9eEckEQIeQaDLjrRclxXnHslEl31AYg1Z7KOHGeiy9xOMT6Ms12UFd4AY3Yflfrbb0VshQpxB9xrNRJd9JObHZZq8PSDiiC0EuuwWoC77KDNdVsQfUr4RMfgI4+dlH5PYx6gT2WOaiWwMoS47lKgwZFquy3oEQp87i4ku+xiwII4BBjaQN24Ws+dlbU+SpmWrxyX2J9Qk+bgmST5hQJd9HBg0T8Rw0ERDl0UkIdMEHysJPk4l+FgNwccZ0GXHAHXZscBgGcdEl30cGNRI+z3JVJdF4vbjfSqJEPBTBLrs05brsuLcTzPRZR+XWNHtG9JHzzDQZR8lGJ+etVyXFdwBYnSfkfvZbkdvhQhxBt1rPBNd9rmYH5dp8vbCCPkaEuiyDYG67ARmuqyIP6R8I2LwOcbPy06U2CepE9lEzUQ2iVCXHUNUGHIt12U9AqHPncdEl50ILIiTgIEN5I2bx+x5WduTpGnZarLEPkVNkpM1SXKKAV12MjBopsRw0ERDl0UkIdMEnyoJPk0l+FQNwacZ0GUnAXXZqcBgmcZEl50MDGqk/Z5nqssicfvxvpBECPgFAl32Rct1WXHuF5nospMlVnT7hvTRSwx02QkE49PLluuygjtAjO5Lcj/b7eitECHOoHu9wkSXfTXmx2V9569OY+Fgy90W2TAnEbffuZG9zgPuJ7iNlEYEv18lqrHqCri3dtp5TWJ/XZ12XtNMO68Tap4ecdBJt77lmqdHcPS5G1h+7klERfYMy8/tJQz0uc8k0riTMDj3KxCvAZuL14GJHJgnXGDsuUA+u2cSNxPoxp6qmXBAOE1Lk9NlMM5Qi/V0TbGeYUB7nw4M5hkxHMz/S3tHB43tHa7poJkpsc9Sg2amJmhmGQiamcCgmZUUu5XmQO4GwsEWNIEh/Tqb6d0AErcf7xtJhIDfILgbeNPyuwFx7jcJdAuTt8uI9t90NZojbf6WWo3maKrRWwZul18H3i7PAZL+LSa3y9OBFRhpv7eZVpC3iSrIO0mEgN8hqCDvWl5BxLnfNXS7HA62SqrxuwSi23vEN6OBP/km4c8qj7Kj2O89w10DuuB1iMPt1TEO56vDQ7iOQ2NGkm7mfcmFuWo3876mm5mr6WYSMeD2g+Tg3KBd1vvAwjA3CUcMk60/IFiMt/7zZLDMV4NlniZY5hto/ZGknAck5XxDrX842HI7JOD2QtpvAXAvk63/AqLWf2ESIeCFBK3/Istbf3HuRczFo7lJ/CrIYmnzJWoFWaypIEsMVJC5QPFoMZD0S5iIR8gKgrTfUqbi0VKiCvJBEiHgDwgqyDLLK4g49zIm4tEiiRUtHn3IQDxaBBaPPjTcNaAfrkA+cTYX7H91Bdxb24F8JP23XO1APtJ0IMsP4GGKcLBF5pCg3cxHwAS8nIgo6G4QeX2F7GZWMO1mVhB1Mx8nEQL+mKCbWWl5NyPOvZL5PIxIMqbn4VXS5qvVarRKU41WG5iHlwMryCog6VczmYfnAKs50n6fMK0gnxBVkDVJhIDXEFSQtZZXEHHutUzm4ZUSK3oeXsdgHl4JnofXHeoa9i8NXFjR8tviU2nzz9Su4VNN1yD+qLoCysKuITNX7vUpMNF9lhQdUlowL2d4/3DwpNy/t98Wn0tSfqGS8nMNKcUf1XT+NymRRvyPe7leK/s5kJRfgJ0LzogZIgDFedH+QAY20h9fAisigT9KquyXzFXnxcAn0fYEf0LO+GOG66X/NqjJcb0mOW4woDpTOSSoZrAeGNgbkrBEQVf5hyJOHZGAD7aHEnAYNxK1x+jRBsmbTeCC4C10170HGMOPAjnzFZgz6IIqOL2JYPzfbPm5hV82E5x7C1ij8+rgFlkH/02jEvjWLg5r74B7GW9UtspGZZvaqGzVNCrbDqBRsdUhQRuVrcCCs42IKOgJzjJf7Mf1teWJVyTdrQSJd7vl5xZ+2U5w7h1EBWfHARQcChuhzqKBi9o7y2+Lb2SR+NbnW7hhthM5WYCv5pQuZN/65C5vobt14Hncb4HJ8zscrky/Tb/z2RRtSy+xBLVBUXHJKhR7fZOETczfMrkM9c4eItgXZc/viXLB974G9mC06w+WNxDirD8QNBA7ifi003QD4eYU/WB3A6GdMn+UuXGXOmX+KA3of21XEvFjb4oRg06GPwIDdFeULrDDwZaLIKXpZzF/kqTcrZLyJ430sZualIoRg5LyJyApd4Odi8ruJd1cYUa2sNtPSbRJIvxfVmQP759If/zMQP74maCK/0JUxX8h7Ao3S26iukIvjjYD+fQrkV1/jYKe/xNw6v6ZYVHbI4vab2pR26Mpar8Z0POpHBK0QO4BBtBvlhZI/0XlHgJ5wuQjkoDO2Pjl2l5p831qMO7VBOO+A+gwkUYMGkB7gQG0D+hck2PPLoYV4ndJyj9UUv6uIeUfBsYeJCl/B5LyD6BzTZJyH0NSOsnSFskKAcV/UEkp/qiGAgpNyn1AUoozBNxrPynjku1uNUqySzJeBUcGdigZhovkbVuiXfsd2DaL/ULJ/x8rqLNzfU6L4wPl8dJ/CWqCjNckyIRkXs9pIR8ojwcm24RkGqKgi1W9EG6vWcAHgxORvnDMvQk9EVgg/HiTkgkBJyXj900GOpDq3MmGKxv6DAngjk5dAffWVqMUafNUtRqlaKpRqoF2PSEZV0FSgKRPJXIuWhiaBfxYT6T90pKxQW2qgqQRVZD0ZELA6QQVpIzlFUScuwxBBaHAmiyxomf2sgzm4WQcxpJ5uCzzeRj4FJhLNeaA7KvtQMpJ/5VXO5Bymg6kvIF5mMohQbuZcsAEXJ7JPIy8c0Z2MxWYzsMViLqZw5IJAR9G0M0cbnk3I859OPN5uDzRyASyibYaHSFtfqRajY7QVKMjDczD5YEV5Agg6Y9kMg+nANtNpP2OYjoPH0VUQSomEwKuSFBBjra8gohzH81kHj5cYkXPw5UYzMOHg+fhSpy7BjensDzYZ+oKuLe2a6gsbX6M2jVUTv7ru6KOoe4aFCMG7RoqAxPdMcm0iSjgG1Byhd1Elaf0R/i/rMge3j+RXUiVZLsLg0hoVQgKQ1VwF+PFdtVk2jegHJFs9xtQjiWy67HJ5t+AcgSwMCPizPQoXE0WtepqUaumGYWrGxBmqRwStEBWAybk6pY/FSqSRbUo37iEgy3EE8HIhsb4jUsN6b+aamDX0AR2zQMI7HCwReaQoIFdAxjYNYFEMSniHsOwch0nCX68SvDjNAQ/3oCIiyTlcUBSHm9IxA0HW6XedxEOtqD2O4HpNeAJRCLuicmEgE8kEHFPslzEFec+ifk1YE2GFaSWtHlttYLU0lSQ2gYqSE1gBakFJH1tJteAyAqCtN/JTK8BTyaqIHWSCQHXIaggp1heQcS5T2FyDXiSxIoWLU5lcA14Evga8FTmj8Ue7G8TPU3673S1AzlN04GcbkB9tfVtoqcBE/DpYDUPnci87z9BK6IbgQJcXaL7e3SCQfImDEzelGdGfleQiztzli5WwsGWK3gYJmgmMiy/Mhd+ySA4dybR1W6mr3ah85qoM0B/kdk2i8i2WQdwbW7zV83sicP6LuBexpvAbNkE5qhNYLamCczRNIGJB6FzgzaU2cDGIAd86+c4ZuQdoJ9LETpXEjpP8BedRbP/JjuHgy2XuuIjOpLsZHz1zAAGQr7lXZMgZj5BZa9HVNnFvnfKfdG2yCOyRX0iW9QntIVIhBS2uKK83TmFKh6ujO652/8DPjLutwSf21voe0YgL12gr12k/RIkb3TTkPMv7flPfPLvSVGzUDbxN5UNfPyHg84nKgJ+0P8Ss/tP/zsCcwOCpNCKKCn82+cz/03zFvTMZyTbmWCQvvDz8gxfc/Jf/fNPNkf650zfXm5mZiQ2CnPd4sLizOzc/Ix2bk5mTk5xVnFuTl5WYXF2VkFhbpGbVZCZkV+UGy5284qKcrMz2+fmFOcXts8p9idttzAzM6swv117Nzsjp6BdOK8wsyBcnJWbmREuKMzMLSzMzMvJKcjMLMzJK87Lz8vIKCjOzAtn5+bmh3MyMvMzqPxzpvTP/5quKWRJ1F5AGb7UpH6WnNTP5lIMqPCdRZD4zyEqgucQTkIlviKwxblEtjiX0BYigCmmhKvK2x0PLtF0dLXl0zBVHmht+TRMFfPXWNL4/sNygfHoAjnuAnnjXnNoslaXexbRZH0ex8n6POLJ+jyCBHPtQThZn59sZ4K5lmhyO5/ZZH0BcLK+BjhZU/nnAt9k/XdFAZ0Dc5Np4p5LgWnIscA0JC4wDQkKTBuiAoN+YAeZwBoB97rS0m64DVEybHQAxSqoTRsn44pCKenWomJF5Z/GBp4hCFkc2xcS5fYLDbwzBViXSt1/I9W8oHu1NfT8QFCcFwE5iVRM2hLljYv+wxPW4WCr1MOZQW28B7iXC/S9xowo+2X5fdREXnM15dg4C/DVnNJPgYuDxDu0BEQm3KZA0lyMw5Xpt+nFPpuiinjJJ44WF5coDE3AD9o2JWg2bE3GVPHahOCBamTD1owopzTzNWwHo10vYfBIwiUEgkZzIj41P4AGCWojN6cI7UN1Bdxb+1avS2Ujcpn6Vq9LpQH9r12WTPyJQ4oRg76l6lJggF4GdK7Jj8FCkNL0x2C1kKS8XCVli+S/vv/wcmpSKkYMSsoWQFJeDnYuKrvLz7XPFnZrkUybJML/ZUX28P6J9McVlldx8da6Kwiq+JVEVfxKwq4wQ3IT1RV6cYR8+2JLIru2PIDuCD3JtUDKpQyLWitZ1K5Si1orTVG7yoB+TeWQoAWyFTCArrK0QPrfQ+0RA0C8/ctkh3kZuOipK+De2mC8Wtq8tRqMV2uCsbWBDvMyYABdDQyg1kzHnssYVohrJCmvVUl5jYaU1zIj5TVAUl4LdK5JUrZmSMo2kpTXqaRsoyHldQZI2RpIyjZAUl5H3GqEg62SAGyTjL96RwY20h9tge2t2AN9eyBav2uSsfu1TaZpUUEYjX7dEtXjCuH/tox/iFuBTNzt1MRdoEnc7Q5g3gwHW7Y9P7K/CBQAk067ZBqioItovRBur1nAT3dtD/SFye8laA8W6rxVmEwIuDAZv28R0IFU5y5iLri0A3ea6gq4t7YaFUubd1CrUbGmGnUwMEa0A44RxUDSdyByLrrtR1YQpP2uB7erpirI9UQV5IZkQsA3EFSQjpZXEHHujgQVhAJrkcSKngk7gSV/9F1jhqzyKDuK/ToZ7hrQNgE+neZSjTkg+2o7kBul/zqrHciNmg6ks4H7VyqHBO1mbgQm4M5M5mHkXTiym7mJ6Tx8E1E3c3MyIeCbCbqZLpZ3M+LcXZjPw4AkY3we7ipt3k2tRl011aibgXm4M7CCdAWSvhuTebgYWEGQ9ruF6Tx8C1EF6Z5MCLg7QQXpYXkFEefuwWQe7iKxoufhngzm4S7gebgn567BzSnsDPaZugLure0aekmb91a7hl7Jf323Vm/qrkExYtCuoRcw0fVOpk1EAd8Ykyvs1jWZ1h/h/7Iie3j/RHYhfZLtLgwiofUhKAy3grsYL7ZvTaZ9Y4zwPeqBHIo3xtxGZNfbks2/MaYrsDAj4sz0KNxXFrXb1aLWVzMK325AmKVySNAC2RcYQLeDiULx1GHfKN+4hIMtF/jeCRfd0Kgr4N7awL5D+q+fGth3aAK7n4EnEKkcEjSw7wAGdr9kM8GC7jp6M6xcd0qC91cJfqeG4P0NiLhIUt4JJGV/QyJuONiCvh8Eab8BTEVcJG4/3oHJhIAHEoi4gywXccW5B3EW9CJn6MewgtwlbX63WkHu0lSQuw1UkH7ACnIXkPR3M7kGbANsMZH2G8y0ggwmqiD3JBMCvoeggtxreQUR576XyTXgIIkVLVrcx+AacBD4GvA+Ip97i8IGqL3uB9qSguebkxynJgHPh1h+m7MkQpqNSQ4JL9G2XCqxom0g9rTZRxck8vFRw0T7fWRS2F4NfCd3Ugh1+0346f1u6altqKx5D6hT21DN1Cb+KEUBhRa2qRwS7FPmw+5QYLF9IBlLFHSSEME8NBkfbP4kERTjMEsfi/HwrYwYr2ki3oYrQziMD1puw3WRszYnsOE6oA2HW95AijgZTtA4P2T5uZtEePMQPIe57R8C1oERlttQnHUEAXdGEj3yNFL2J7oGEmWbP790pqgkrh4ksA2AE8bfj/qwbCJHqU3kw5omchTB836qU9BS+AjgVcLDwAQyCkgWk0EDIqPxO67REvsjKtFHa4j+iAGigyTF/eQcDSTnI8B7LpOXryOS+RHzUUnMx1RiPqoh5mMGLl+RGfNRICkfY/L4zmigHo+03xjgXiYvX8cQXb4+nkwI+HGCy9cnLL98Fed+guAizmQFGcWwgoyVNh+nVpCxmgoyzkAFGQWsIGOBpB/H5PEdZAVB2u9Jpo/vPElUQZ5KJgT8FEEFedryCiLO/TSTx3eekFjRKtIzlj++85Cs8ig7iv2eYfb4DlJJftbSx3eo1dLxlt9g7YqQpgPBDdYu4A3Wc+CCrHbZ6LOLuBkF5LuInfHA3OFx3tGsgHtrO/cJEvtEtXOfoOncJxKIkh44zzHoILrJ8i+79wiEPvfN5WkKGehN5vunqwnAQjYRGNhA3rgIX3iJ4VCSNC9vTJLYJ6tJcpImSU5OJvtkhv1BMwkYNJNjOGiicQOESEKmCT5FEnyqSvApGoJPNaDfTQTqd1OAwTKViX43CRjUSPtNY6rfIXH78T6fTAj4eQL97gXL9Ttx7heY6HeTJFZ06/9ist3nFnrOcwTnfsly3VL4G4jRfVHuR8F1b6Ft8BIwf7wM1i29hS7Gr8Rwh+0tsQc6npMijuhFoH+KfVEYX2Wmf4r4Q8okIgZfweufGY5mBdxbO/m8JrG/rk4+r2kmn9cJ9c+JMpmjg6ib5fqnRyD0uW9hon++BiyIrwMDG8gb9xac/plxKEmal4emS+wz1CQ5XZMkZxjQP6cDg2ZGDAdNNPRPRBIyTfCZkuCzVILP1BB8lgH983Wg/jkTGCyzmOif04FBjbTfbKb6JxK3H+8byYSA3yDQP9+0XP8U536Tif45XWJFt/5zGOifrxKc+y3L9U/hbyBGd47cj4Lr3kLb4C1g/nibif75Tgx32N4Se6DjuVLEEYMJ9M9KQP3zXWb6p4g/pEwiYvAdxs9/viexv69OPu9pJp/3CfXP12UyRwdRT8v1T49A6HP3YqJ/vgcsiO8DAxvIG7cXs+c/bU+SpuWhuRL7PDVJztUkyXkG9M+5wKCZF8NBEw39E5GETBN8viT4ApXg8zUEX2BA/3wfqH/OBwbLAib651xgUCPtt5Cp/onE7ce7KJkQ8CIC/XOx5fqnOPdiJvrnXIkV3fovYaB/vktw7qWW65/C30CM7hK5HwXXvYW2wVJg/viAif65LIY7bG+JPdDxXCfiiNEE+mcdoP75ITP9U8QfUiYRMbiM8fOfH0nsy9XJ5yPN5LOcUP98XyZzdBDdarn+6REIfe7bmOifHwEL4nJgYAN5497G7PlP25OkaXlohcT+sZokV2iS5McG9M8VwKD5OIaDJhr6JyIJmSb4SknwVSrBV2oIvsqA/rkcqH+uBAbLKib65wpgUCPtt5qp/onE7cf7STIh4E8I9M81luuf4txrmOifKyRWdOu/loH++SHBuddZrn8KfwMxumvlfhRc9xbaBuuA+eNTJvrnZzHcYXtL7IGO5wYRR0wg0D8bAPXPz5npnyL+kDKJiMHPGD//+YXE/qU6+XyhmXy+JNQ/l8tkjg6iOyzXPz0Coc/dj4n++QWwIH4JDGwgb9x+zJ7/tD1JmpaH1kvsG9QkuV6TJDcY0D/XA4NmQwwHTTT0T0QSMk3wjZLgm1SCb9QQfJMB/fNLoP65ERgsm5jon+uBQY2031dM9U8kbj/ezcmEgDcT6J9bLNc/xbm3MNE/10us6NZ/KwP983OCc2+zXP8U/gZidLfK/Si47i20DbYB88fXTPTP7THcYXtL7IGO52YRR0wn0D+bAfXPHcz0TxF/SJlExOB2xvrnNxL7t+rk841m8vmWUP/8UiZzdBANsFz/9AiEPvdAJvrnN8CC+C0wsIG8cQcy0z9tT5Km5aHvJPbv1ST5nSZJfm9A//wOGDTfx3DQREP/RCQh0wT/QRJ8p0rwHzQE32lA//wWqH/+AAyWnUz0z++AQY20349M9U8kbj/eXcmEgHcR6J8/Wa5/inP/xET//E5iRbf+uxnonzsIzv2z5fqn8DcQo7tb7kfBdW+hbfAzMH/8wkT//DWGO2xviT3Q8dw24oj5BPpnW6D+uYeZ/iniDymTiBj8Fa9/Gnv/+28S+1518vlNM/nsJdQ/v5XJHB1Ed1uuf3oEQp97MBP98zdgQdwLDGwgb9zBzN7/bnuSNC0P7ZPYf1eT5D5NkvzdgP65Dxg0v8dw0ERD/0QkIdME/8MLzhSnNJn/0BBc/FENBRRa/9wL1D//QEo2KTz0z33AoEbaLy4Fhsuo/onE7ccbSiEELDZH7xufYrf+Kc4dn/L/BgbtS4JVBGl8Cr71T0ix+9xC/9xDMPIkgs+N1v6Ev4EYXeHnRCKuewttg0Rg/kgC2tJ/ZnQxTgbitK3D9pbYAx3P3SKOWE2gf3YD6p8p4IaGerQX8YeUSUQMJgNzkOnnP1Ml9jR18klN+evkk5ZCp3/ulcUBHUT3Wa5/egRCn/t+JvpnKrAgpgELDZA37v3Mnv+0PUmalofSJfYyapJM1yTJMin0+mc6MGjKxHDQREP/RCQh0wQvKwleTiV4WQ3ByxnQP9NScMFSFhgs5Zjon+nAoEbarzxT/ROJ24+3Qgoh4AoE+udhluuf4tyHMdE/0yVWdOt/OAP9M4Xg3EdYrn8KfwMxuofL/Si47i20DY4A5o8jmeifR8Vwh+0tsQc6ngdFHLGFQP8cBNQ/KzLTP0X8IWUSEYNH4fVPY89/Hi2xV1Inn6M1k08lQv0zTSZzdBA9YLn+6REIfe5hTPTPo4EFsRIwsIG8cYcxe/7T9iRpWh6qLLEfoybJypokeYwB/bMyMGiOieGgiYb+iUhCpgleRRK8qkrwKhqCVzWgf1YC6p9VgMFSlYn+WRkY1Ej7HctU/0Ti9uOtlkIIuBqB/lndcv1TnLs6E/2zssSKbv1rMNA/KxKcu6bl+qfwNxCjW0PuR8F1b6FtUBOYP45jon8eH8MdtrfEHuh4XhohX0MC/VPsi8J4AjP9U8QfUiYRMXg84+c/T5TYT1InnxM1k89JhPpnJZnM0UH0kOX6p0cg9LlHMNE/TwQWxJOAgQ3kjTuC2fOftidJ0/JQLYm9tpoka2mSZG0D+mctYNDUjuGgiYb+iUhCpgl+siR4HZXgJ2sIXseA/nkSUP88GRgsdZjon7WAQY203ylM9U8kbj/eU1MIAZ9KoH+eZrn+Kc59GhP9s5bEim79T2egf55AcO66luufwt9AjO7pcj8KrnsLbYO6wPwRZqJ/ujHcYXtL7IHOExuTHGcowedkZBDnx6D4VkaCrimB7iv2RGHMZKb7iryDlIdE7nHhudctdjQr4N7aiS9LYs9WJ74szcSXTaj7niSLGDqIRlme3DwCoc89monumwVsBLKBgQ3kjYvzhVt8KEmal8VyJPZcNUnmaJJkrgHdNwcYNLkxHDTR0H0RScg0wfMkwfNVgudpCJ5vQPfNBuq+ecBgyWei++YAgxppv3pMdV8kbj/e+imEgOsT6L4NLNd9xbkbGNJ9EUEqsKLbN6SPzrBcQxYaTibB+HQmsYYcDrZKOkAgRvcMuZ/tdvRWiBBn0L3OYqJHnx3z4zJN3l4XIV9zAl22OVCXPYdB3j6HIN+ca/m5l0dIcy685rvtzwXmr/Mst6E463kE3Dkf3OR7w4nYV7SkJqQ7UceQMmhJLSOYI84j6gscDE6tSnKBnCsaqirJBRqVpCHhXUk2UbP2mOV3JX9HxqDnHkN0V5IIPv95QFXsAmDBaAhMOEAOuki/ck7eDginaVm6kcTeWE24jTQJt7GBe5dGwKBpHMNBE417F0RHYZrgF0qCX6QS/EINwS8ycO+CrDAXAoPlIkP3LuFgC5ogkPZrwvTeBYnbj7dpCiHgpgTz0sWW37uIc19McO9isoI0ZFhBmkmbX6JWkGaaCnKJgQrSEFhBmgFJfwmTm/tGwLYQab/mTCtIc6IKcmkKIeBLCSrIZZZXEHHuywzd3IeDrZJqfBmBENWC+NYZcbtyMTBBif1aEPncWxQ2QO11OZOb4isOAoFP7IGO510R8nUguCnuALwpvhJc2KlFUhF/SMFZxOAV8Bxk7h08LSX2VuoE0FIzAbQivJXyHIMOonGW30p5BEKf+0km7+BpCSyIrYCBDeSN+ySzd/DYniRNyyRXSexXq0nyKk2SvNrATdJVwKC5OoaDJho3SYgkZJrgrSXBr1EJ3lpD8GsM6ICtgDpga2CwXMNEB7wKGNRI+13LVAdE4vbjbZNCCLgNgQ54neU6oDj3dYZ0QESQXpeCb9+QPmqbQmvDcLBV8iT4lQTjUwGxlhoOtko6QCBGt63cz3Y7eitEiDPoXu2Y6LLtY35cpsnbSRFH9CLQZXsBddlCZrqsiD+kfCNisD1ely1yNCvg3tqJrEhiL1YnsiLNRFZMqMu2IioMz1iuy3oEQp/7WSa6bBGwIBYDAxvIGxfnC7foUJI0L1t1kNivV5NkB02SvN6ALtsBGDTXx3DQREOXRSQh0wS/QRK8o0rwGzQE72hAly0G6rI3AIOlIxNdtgMwqJH268RUl0Xi9uO9MYUQ8I0Eumxny3VZce7OTHTZDhIrun1D+ugmBrpsIcH4dLPluqzgDhCje5Pcz3Y7eitEiDPoXl2Y6LJdY35cpsnblSKOGEygyw4G6rLdmOmyIv6Q8o2Iwa6Mn5e9RWLvrk5kt2gmsu6EumwxUWGYYLku6xEIfe6JTHTZW4AFsTswsIG8cScye17W9iRpWrbqIbH3VJNkD02S7GlAl+0BDJqeMRw00dBlEUnINMF7SYL3VgneS0Pw3gZ02e5AXbYXMFh6M9FlewCDGmm/Pkx1WSRuP95bUwgB30qgy95muS4rzn0bE122h8SKbt+QPurLQJftRjA+3W65Liu4A8To9pX72W5Hb4UIcQbd6w4mumy/mB+XafJ2nYgjRhPosqOBuuydzHRZEX9I+UbEYD/Gz8v2l9gHqBNZf81ENoBQl+1OVBimWK7LegRCn3sqE122P7AgDgAGNpA37lRmz8vaniRNy1YDJfZBapIcqEmSgwzosgOBQTMohoMmGrosIgmZJvhdkuB3qwS/S0Pwuw3osgOAuuxdwGC5m4kuOxAY1Ej7DWaqyyJx+/Hek0II+B4CXfZey3VZce57meiyAyVWdPuG9NF9DHTZOwnGp/st12UFd4AY3fvkfrbb0VshQpxB9xrCRJcdGvPjMk3ebhBxxAQCXXYCUJd9gJkuK+IPKd+IGBzK+HnZYRL7g+pENkwzkT1IqMsOICoML1iuy3oEQp/7RSa67DBgQXwQGNhA3rgvMnte1vYkaVq2Gi6xP6QmyeGaJPmQAV12ODBoHorhoImGLotIQqYJPkISfKRK8BEago80oMs+CNRlRwCDZSQTXXY4MKiR9nuYqS6LxO3HOyqFEPAoAl12tOW6rDj3aCa67HCJFd2+IX30CANd9gGC8elRy3VZwR0gRvcRuZ/tdvRWiBBn0L0eY6LLjon5cZkmbzeLOGI6gS47HajLPs5MlxXxh5RvRAyOYazLPiGxj1Unsic0E9lYQl32QaLC8IrluqxHIPS5X2Wiyz4BLIhjgYEN5I37KjNd1vYkaVq2GiexP6kmyXGaJPmkAV12HDBonozhoImGLotIQqYJ/pQk+NMqwZ/SEPxpA7rsWKAu+xQwWJ5mosuOAwY10n7PMNVlkbj9eJ9NIQT8LIEuO95yXVacezwTXXacxIpu35A+eo6BLvs4wfg0wXJdVnAHiNF9Tu5nux29FSLEGfgjBJnospNiflymydttI46YT6DLzgfqspOZ6bIi/pDyjYjBSXhd1tjnGEyR2KeqE9kUzUQ2lVCXHUtUGKZbrst6BEKfewYTXXYKsCBOBQY2kDfuDGafY2B7kjQtW02T2J9Xk+Q0TZJ83oAuOw0YNM/HcNBEQ5dFJCHTBH9BEvxFleAvaAj+ogFddipQl30BGCwvMtFlpyEfhQHa7yWmuiwStx/vyymEgF8m0GVfsVyXFed+hYkuO01iRbdvSB+9ykCXnUwwPr1muS4ruAPE6L4q97Pdjt4KEeIMutfrTHTZ6TE/LtPk7W4RR6wm0GVXA3XZGcx0WRF/SPlGxOB0xs/LzpTYZ6kT2UzNRDaLUJedSlQYZluuy3oEQp/7DSa67ExgQZwFDGwgb9w3mD0va3uSNC1bzZbY31CT5GxNknzDgC47Gxg0b8Rw0ERDl0UkIdMEf1MSfI5K8Dc1BJ9jQJedBdRl3wQGyxwmuuxsYFAj7fcWU10WiduP9+0UQsBvE+iy71iuy4pzv8NEl50tsaLbN6SP3mWgy84gGJ/es1yXFdwBYnTflfvZbkdvhQhxBt3rfSa67NyYH5dp8vagiCO2EOiyW4C67DxmuqyIP6R8I2JwLuPnZedL7AvUiWy+ZiJbQKjLziIqDG9Zrst6BEKf+20muux8YEFcAAxsIG/ct5k9L2t7kjQtWy2U2BepSXKhJkkuMqDLLgQGzaIYDppo6LKIJGSa4IslwZeoBF+sIfgSA7rsAqAuuxgYLEuY6LILgUGNtN9SprosErcf7wcphIA/INBll1muy4pzL2Oiyy6UWNHtG9JHHzLQZecRjE8fWa7LCu4AMbofyv1st6O3QoQ4g+61nIkuuyLmx2WavL00Qr6GBLpsQ6Au+zEzXVbEH1K+ETG4gvHzsisl9lXqRLZSM5GtItRlFxAVhvcs12U9AqHP/T4TXXYlsCCuAgY2kDfu+8yel7U9SZqWrVZL7J+oSXK1Jkl+YkCXXQ0Mmk9iOGiiocsikpBpgq+RBF+rEnyNhuBrDeiyq4C67BpgsKxlosuuBgY10n7rmOqySNx+vJ+mEAL+lECX/cxyXVac+zMmuuxqiRXdviF99DkDXfZjgvHpC8t1WcEdIEb3c7mf7Xb0VogQZ9C9vmSiy66P+XFZ3/mr01g42HIzkh2nXzJuv/sjew0B7ie4jZRGBL/XE9VYdQXcWzvtbJDYN6rTzgbNtLORUPP0iINOuvMt1zw9gqPPvcDyc68iKrILLT+3lzDQ515EpHEnYXDuVyA2AJuLjcBEDswTLjD2XCCf3UXEzQS6sadqJhwQTtPS5CZZrL9Si/UmTbH+yoD2vgkYzF/FcDD/L+0dHTS2d7img2azxL5FDZrNmqDZYiBoNgODZktK7FaaA7kbCAdb0ASG9OtWpncDSNx+vNtSCAFvI7gb+NryuwFx7q8JdAuTt8uI9t90Ndoubb5DrUbbNdVoh4Hb5Y3A2+XtQNLvYHK7vAlYgZH2+4ZpBfmGqIJ8m0II+FuCCvKd5RVEnPs7Q7fL4WCrpBp/RyC6fU98MxpYIEv6s8qj7Cj2+95w14CejzfG4ex7eAjXJWiOTtKB/CD9t1PtQH7QdCA7D2AeDgdbZA4J2s38AEzAO1NoiILuBm9IwO01Lwlnvx+BvjDZzfxI1M3sSiEEvIugm/nJ8m5GnPsn5vPwTqKRCWQTbTXaLW3+s1qNdmuq0c8G5uGdwHl4N5D0PzOZh5EVBGm/X5jOw78QVZBfUwgB/0pQQfZYXkHEufcwmYd/kljR8/BvDObhn8Dz8G/c5+EUuzoQb2mOTtKB7JX+26d2IHs1Hcg+E/MwkUOCdjN7gQl4HxFR0N0gUpFHdjO/M+1mfifqZv5IIQT8B0E346Ta3c2IcwuMDnZfo/PwPqKRCWQTbTWKkzYPpTqlK4/4D2o1En9UQwGFzoD7gBUkDkj6UCqPeXg7sJoj7Ref6rCsIEjcfrwJqYSAE1Lx+yZaXkHEuRMJKggFVkdiRc/DSanYc1PMww4OY8k8nHSoa9i/NHBhRctvi2Rp8xS1a0jWdA3ij6oroCzsGjJz5V7JwESXkhodUlowL2d4/3DwpNy/t98WqZKUaSopUzWkFH9U0/nfpEQa8T/u5XqtbCqQlGmpWOeCM2KGCEBxXrQ/kIGN9Ec6sCIS+KOkyqYTdVZ/F3vhYMtdDHzIp3IIt1cZcIeG9vXRkbMKf6MLSlnLzy38UpagIy8HHh+9+lVOSjH/qylA589uwJjqHof1XcC9jD8VWV7m0wpqs1Je06xU0OhuiQehc4PqgeWBRbsCEelA7/48GPy6H9dhlhcXUVjKExSXwy0/t/DL4QTnPoKoqB5xAEWVwkaos2jgovbO8tviSFm8jvL5Fm6Yw4mcLMBXc0oX2KN806a30BMJ8DzuUcDkWRGHK9Nv04o+m6Jt6SWWoDYoKi5ZhWKvI1OxifkoJncR3tlDhHwPas+jiXLB0b7G+mC0ayXLGwhx1koEDURlIj5VNt1AuDlFlexuILTT7zEyN1ZRp99jpAH9r1WhfupEMWLQKfMYYIBWidL9UTjYchGkNP0oVFVJymNVUlbVSDLHUpNSMWJQUlYFkvJYsHNR2b2kmyvMyBZ2q5pKmyTC/2VF9vD+ifRHNQbyRzWCKl6dqIpXJ+wKy0puorpCL47KAvlUg8iuNQ6gOwqBOVIVOHVXY1jUasqidpxa1Gpqitpxqf/8bhNbHRK0QNYEBtBxlhZI/2VsTQJ5wuQTSoDO2Pil3/HS5ieowXi8JhhPOIAOE2nEoAF0PDCATgA61+TYU4VhhThRkvIklZQnakh5koGxB0nKE4GkPAnoXJOkPIEhKWtJUtZWSVlLQ8raBkh5ApCUtYCkrG15qyECsBaBCo4M7JPB8zN6hhHt2onAtlnsdzKT26mzI8a8IITnZR3LfS7OXRbs8zqGW350zOeHrLr5Mj4+nCL9d6paFE/RFMVTD2CWDwdbZA4JWmBPARaHU4mIgm5Qzgnh9kKK06cB9zL5vt/TwCKot05PJQR8eip+37pAB1Kdu26UxaxwsOWeCu7i1RVwb201Ckubu2o1CmuqkWtgRDsVWEHCQNK7RM5Fi4HICoK0Xwb4GQhTFSSDqIJkphICziSoIFmWVxBx7iwm83BdiRU9D2cz0EDqgufhbM5dg5tTeCrYZ+oKuLe2a8iRNs9Vu4ac1L8++ZdL3TUoRgzaNeQAE10u8UM9AR+yyhV2C6fS+iP8X1Zkj/3/Bvojj8FDVnkEhSGf6GGgfOKHrMKWP2RVj8iu9aLwkFUYWJgRcWZ6FK4vi1oDtajV14zCDQw8ZEXlkKAFsj4wgBoweMiqPvMblxPsamiM37icIf13phrYZ2gC+0wDNy5UDgka2GcAcZ3J9OGvXIaV6yxJ8LNVgp+lIfjZBkRcJCnPApLybEMibjjYKvVsUTjYgtrvHKbXgOcQibjnphICPpdAxD3PchFXnPs8zoJe5AxnMqwg50ubX6BWkPM1FeQCAxXkTGAFOR9I+guYXAMiKwjSfg2ZXgM2JKogjVIJATciqCCNLa8g4tyNmVwDniexokWLCxlcA54Hvga80JDPA38ITujPj2ZFizwbgd+bfBHRlSSaR8iP9G2CO3OWjjfhYMu9IXLWiwhyRVPLb8SEX5oSnPtiopubi33NMTrGxcdhA/1FZttmRLZtdgC3YgfLJ68ujsPyIOBexkX9S2S9b65OrJdoJtbmBkT9JsCJ9RJgk90cuFetclhR33H00xs6cXYDBgswiEsR+lJJ6MsEf9EZ+ZK/yfThYMul7h4Q3c0lqXhCNQUGVQvLOzBBzBYEXcLlRF2C2PdOuS/aFpcR2eIKIltcQWgLkVQpbPFlebvjoTvRudeXtzuXUuWBDdE9d/t/wEcW8xvB5/YWurEFxqML5LgL5I2L9EWC5KBuOnX+pW/+iZv+PSnqPsom/ib/Sl8swUG3ICqkftD/ErP7T/87AvOVBAlmkyUJ5t80wEHP3DLVzgSD9IWfly19Dd5/9c8/2Rzpn1a+vdzMzEhsFOa6xYXFmdm5+Rnt3JzMnJzirOLcnLyswuLsrILC3CI3qyAzI78oN1zs5hUV5WZnts/NKc4vbJ9T7E/abmFmZlZhfrv2bnZGTkG7cF5hZkG4OCs3MyNcUJiZW1iYmZeTU5CZWZiTV5yXn5eRUVCcmRfOzs3ND+dkZOZnUPmnlfSPSbXDMmlw//IXxKuk2nE1l2JAhe8qgsTfmqgItiacJoUtriawxTVEtriG0BaLiSbMryyfrJsQTVqbLZ+sqfLAFssna6qY38pksgbGowvkuAvkjbv10GStLvcqosn6Wo6T9bXEk/W1BAlm20E4WbdJtTPBbCOa3Nowm6yvA07WW4GTNZV/rvNN1n9XFGyWRClxUhWYthwLTFviAtOWoMB8TVRg0N83j0xgBcC9NljaDX9NlAwLDqBYBbVpu1RcUSgl3VpUrKj8086Af5Cx2B7Y7Fl6f1zKP+0P4AFRi57zIrNp0DPuMDQYBcVZCIyVr4D2Q6o4O4hipfA/PIUfDrbIHuAN6q/FwL2aADmpcQnKfll+fxfJa7xijoOBAF/NKf1OAXGQeMVw6Pe2IwtBMZA0HXC4Mv027eCzqXrXHegDLIuLSxSUIvDD2H4OoPY9GIoEVewXETzAj2yWryfKT9f7mtKD0a43MHh84wYC8acjEZ86HkDjBrWRm1OE9qG6Au6tfWthJ9nU3Ki+tbCTNKD/tRtTiT8MRzFi0LcWdgIG6I1A55r8hCYEKU1/QlNnScqbVFJ2Tv3r+11voialYsSgpOwMJOVNYOeisrv8yPVsYbfOqbRJIvxfVmQP759If9xseRUXb+W8maCKdyGq4l0Iu8KmkpuortCLI+TbZbsS2bXrAXRHqOnVO0tnoBJwM8Oi1k0WtVvUotZNU9RuMaDRUzkkaIHsBgygWywtkP737HvEABBv/zLZYd4ILnrqCri3Nhi7S5v3UIOxuyYYexjoMG8EBlB3YAD1YDr23MiwQvSUpOylkrKnhpS9mJGyJ5CUvYDONUnKHgxJ2VuSso9Kyt4aUvYxQMoeQFL2BpKyD3GrEQ62SgKwN8FtDzKwkf64Fdjeij3Qtwei9euZit3v1lSaFhWEkYTXYyOOeSaEP/dt4HOj52lx7qZg/txmeBRBx9SYkFU3csY/KLKv9N/tarHuqynWtx+AxhAOtsgcErTw9wUWmtuJiIJunMaFcHshRfM7gHuZ/JqEO8DirLf6pRIC7peK3/dOoAOpzn0nc5HtdvB0oa6Ae2urUX9p8wFqNeqvqUYDDIyOtwMrSH8g6QcQORc96iErCNJ+A8EipakKMpCoggxKJQQ8iKCC3GV5BRHnvougglBgvVNiRc/Dd1s+DzeVVR5lR7Hf3Zy7Bjen8Hawz9QVcG9t1zBY2vwetWsYnPrXJxLvoe4aFCMG7RoGAxPdPcTCXMCHv3KF3fqn0voj/F9WZA/vn8gu5F7LhVKR0O4lKAz3ET2kdB/xw1/9LX/4634iu94fhYe/+gMLMyLOTI/CQ2RRG6oWtSGaUXiogYe/qBwStEAOAQbQUAYPfw1hfuMCfD7IRTc06gq4tzawH5D+G6YG9gOawB5m4MaFyiFBA/sBYGAPY/pQ2j0MK9eDkuDDVYI/qCH4cAMiLpKUDwJJOdyQiBsOtqDPPCHt9xBTEReJ2493RCoh4BEEIu5Iy0Vcce6RnAW9yBmGMawgD0ubj1IryMOaCjLKQAUZBqwgDwNJP4rJNWBvYIuJtN9ophVkNFEFeSSVEPAjBBXkUcsriDj3o0yuAUdKrGjR4jEG14AjwdeAjxH53FsUNkDtNQZoSwqel43gO5OA549bfpuzIEKajUkOCS/RtlwosaJtIPa0+dzL5LlDhOcOivEJS2+RPXwrIsZbGcLbUOyLwjjWchuuiZx1HYEN1wBtOM7yfCviZBxBnXnS8nMvj/j4yVQ0d9z2TwJ7lKcst6E461ME3Hma6AkBsW+Ko39CAGWbPz/TtKgkrsYS2AbACeNv33pGzhnPqkrZMxql7FmCx2NUp6CVo6eAytszwATyLJAsJoMGREbjkvB4if05lejjNUR/zgDRQRP4fnKOB5LzOaAsbPKu4qlUfsScIIk5USXmBA0xJxq4q0BmzAlAUk5kcts9HihfIe03CbiXybuKSUR3FZNTCQFPJrirmGL5XYU49xTmt93PMqwgU6XNp6kVZKqmgkwzUEGeBVaQqUDST2Ny242sIEj7Pc/0tvt5ogryQioh4BcIKsiLllcQce4Xmdx2T5FY0SrSS5bfdj8pqzzKjmK/l5jddiOV5Jctve2mVktfsfwGa2eENLsIbrB2Am+wXgUXZLXLRp9dxM2zQL6L2HkFmDs8zjuaFXBvbef+msT+utq5v6bp3F8nECU9cJ5j0EH0m+Xff+YRCH3uvXZ/Uev+6eo1YCF7HRjYQN64CF94ieFQkjQvb0yX2GeoSXK6JknOSCV7I/P+oJkODJoZMRw00bgBQiQh0wSfKQk+SyX4TA3BZxnQ714H6nczgcEyi4l+Nx0Y1Ej7zWaq3yFx+/G+kUoI+A0C/e5Ny/U7ce43meh30yVWdOs/J9Xucws951WCc79luW4p/A3E6M6R+1Fw3VtoG7wFzB9vg3VLb6GL8Tsx3GF7S+yBjueEiCOS4vHjrdgXhfFdZvqniD+kTCJi8B28/pnhaFbAvbWTz3sS+/vq5POeZvJ5n1D/fF0mc3QQ/WG5/ukRCH1upwIP/fM9YEF8HxjYQN64CF94ieFQkjQvD82V2OepSXKuJknOM6B/zgUGzbwYDppo6J+IJGSa4PMlwReoBJ+vIfgCA/rn+0D9cz4wWBYw0T/nAoMaab+FTPVPJG4/3kWphIAXEeifiy3XP8W5FzPRP+dKrOjWfwkD/fNdgnMvtVz/FP4GYnSXyP0ouO4ttA2WAvPHB0z0z2Ux3GF7S+yBjueKEUdUItA/KwL1zw+Z6Z8i/pAyiYjBZYyf//xIYl+uTj4faSaf5YT65/symaODKJ44yMPB1n4CwS9PmOifHwEL4nJgYAN54ybg9E/3UJI0Lw+tkNg/VpPkCk2S/NiA/rkCGDQfx3DQREP/RCQh0wRfKQm+SiX4Sg3BVxnQP5cD9c+VwGBZxUT/XAEMaqT9VjPVP5G4/Xg/SSUE/AmB/rnGcv1TnHsNE/1zhcSKbv3XMtA/PyQ49zrL9U/hbyBGd63cj4Lr3kLbYB0wf3zKRP/8LIY7bG+JPdDxXDviiDoE+mdtoP75OTP9U8QfUiYRMfgZ4+c/v5DYv1Qnny80k8+XhPrncpnM0UGUbLn+6REIfe4UJvrnF8CC+CUwsIG8cVNw+mfGoSRpXh5aL7FvUJPkek2S3GBA/1wPDJoNMRw00dA/EUnINME3SoJvUgm+UUPwTQb0zy+B+udGYLBsYqJ/rgcGNdJ+XzHVP5G4/Xg3pxIC3kygf26xXP8U597CRP9cL7GiW/+tDPTPzwnOvc1y/VP4G4jR3Sr3o+C6t9A22AbMH18z0T+3x3CH7S2xBzqe60Uc0YBA/6wH1D93MNM/RfwhZRIRg9sZP//5jcT+rTr5fKOZfL4l1D+/lMkcHUTpluufHoHQ5y7DRP/8BlgQvwUGNpA3bhmc/ukeSpLm5aHvJPbv1ST5nSZJfm9A//wOGDTfx3DQREP/RCQh0wT/QRJ8p0rwHzQE32lA//wWqH/+AAyWnUz0z++AQY20349M9U8kbj/eXamEgHcR6J8/Wa5/inP/xET//E5iRbf+uxnonzsIzv2z5fqn8DcQo7tb7kfBdW+hbfAzMH/8wkT//DWGO2xviT3Q8dw04ohmBPpnU6D+uYeZ/iniDymTiBj8lbH++ZvEvledfH7TTD57CfXPb2UyRwdRecv1T49A6HNXYKJ//gYsiHuBgQ3kjVuBmf5pe5I0LQ/tk9h/V5PkPk2S/N2A/rkPGDS/x3DQREP/RCQh0wT/wwvONKc0mf/QEFz8UQ0FFFr/3AvUP/9ASjZpPPTPfcCgRtovLg2Gy6j+icTtxxtKIwQsNkfvG59mt/4pzh2f9v8GBu1LglUEaXwawUdfpdl9bqF/7iEYeRLB50Zrf8LfQIyu8HMiEde9hbZBIjB/JAFt6T8zuhgnA3Ha1mF7S+yBjuc2EUe0JdA/2wD1zxRwQ0M92ov4Q8okIgaTgTnI9PvfUyX2NHXySU376+STlkanf+6VxQEdREdYrn96BEKf+0gm+mcqsCCmAQsNkDfukTj9M+NQkjQvD6VL7GXUJJmuSZJl0uj1z3Rg0JSJ4aCJhv6JSEKmCV5WErycSvCyGoKXM6B/pqXhgqUsMFjKMdE/04FBjbRfeab6JxK3H2+FNELAFQj0z8Ms1z/FuQ9jon+mS6zo1v9wBvpnCsWoZ7n+KfwNxOgeLvej4Lq30DY4Apg/jmSifx4Vwx22t8Qe6HjuEnFENwL9swtQ/6zITP8U8YeUSUQMHoXXP409/3m0xF5JnXyO1kw+lQj1zzSZzNFBdLTl+qdHIPS5KzHRP48GFsRKwMAG8sathNM/3UNJ0rw8VFliP0ZNkpU1SfIYA/pnZWDQHBPDQRMN/RORhEwTvIokeFWV4FU0BK9qQP+sBNQ/qwCDpSoT/bMyMKiR9juWqf6JxO3HWy2NEHA1Av2zuuX6pzh3dSb6Z2WJFd3612Cgf1YkOHdNy/VP4W8gRreG3I+C695C26AmMH8cx0T/PD6GO2xviT3Q8Twg4ohBBPrnAKD+eQIz/VPEH1ImETF4POPnP0+U2E9SJ58TNZPPSYT6ZyWZzNFBVMVy/dMjEPrcVZnonycCC+JJyKkPWGiq4vTPjENJ0rw8VEtir60myVqaJFnbgP5ZCxg0tWM4aKKhfyKSkGmCnywJXkcl+MkagtcxoH+eBNQ/TwYGSx0m+mctYFAj7XcKU/0TiduP99Q0QsCnEuifp1muf4pzn8ZE/6wlsaJb/9MZ6J8nEJy7ruX6p/A3EKN7utyPguveQtugLjB/hJnon24Md9jeEnug43lhhHxLQ/jxVuyLwpjBTP8U8YeUSUQMuoyf/8yU2LPUySdTM/lkEeqfJ8lkjg6i6pbrnx6B4JfATPTPTGBBzAIGNpA3bg2c/ukeSpLm5aFsiT1HTZLZmiSZY0D/zAYGTU4MB0009E9EEjJN8FxJ8DyV4LkagucZ0D+zgPpnLjBY8pjon9nAoEbaL5+p/onE7cdbL40QcD0C/bO+5fqnOHd9JvpntsSKbv0bMNA/MwjOfYbl+qfwNxCj20DuR8F1b6FtcAYwf5zJRP88K4Y7bG+JPdB5YlmEfBuT8HnibOL8GBTfisi5VxLoviuBuu85zHRfkXeQ8pDIPWfBc69b7GhWwL21E9+5Evt56sR3rmbiO49Q982SRQwdRMdbntw8AqHPfQIT3fdcYCNwHjCwgbxxcb5wiw8lSfOy2PkS+wVqkjxfkyQvMKD7ng8MmgtiOGiiofsikpBpgjeUBG+kEryhhuCNDOi+5wF134bAYGnERPc9HxjUSPs1Zqr7InH78V6YRgj4QgLd9yLLdV9x7osM6b6IIBVY0e0b0kdNLNeQhYZzDsH41JRYQw4HWyUdIBCj20TuZ7sdvRUixBl0r4uZ6NHNYn5cpsnbayLkW0egy64D6rKXMMjblxDkm+aWn3t8JIibw2u+2745MH9darkNxVkvJeDOZeAm3xtOxL4pzp8qELV0J+oYUgYVtawZwRxxKVFf4GBwalWSFnKuuFxVSVpoVJLLCe9KziNq1mpZflfyd2QM/NZ/oruSRPD5LwWqYi2ABeNyYMIBctBF+pVz8nZAOE3L0ldI7FeqCfcKTcK90sC9yxXAoLkyhoMmGvcuiI7CNMFbSoK3UgneUkPwVgbuXZAVpiUwWFoZuncJB1vQBIG031VM712QuP14r04jBHw1wbzU2vJ7F3Hu1gT3LiYryOUMK8g10ubXqhXkGk0FudZABbkcWEGuAZL+WiY391cA20Kk/dowrSBtiCrIdWmEgK8jqCBtLa8g4txtDd3ch4OtkmrclkCIKiC+dUbcrrQGJiixXwGRz71FYQPUXu2Y3BS3PwgEPrEHOp53Rsi3i+CmeBfwprgQXNipRVIRf0jBWcRge3gOMvcOniKJvVidAIo0E0Ax4a2U5xh0EJ1q+a2URyD0uU9j8g6eImBBLAYGNpA3Ls4XZt7BY3uSNC2TdJDYr1eTZAdNkrzewE1SB2DQXB/DQRONmyREEjJN8BskwTuqBL9BQ/COBnTAYqAOeAMwWDoy0QE7AIMaab9OTHVAJG4/3hvTCAHfSKADdrZcBxTn7mxIB0QEaec0fPuG9NFNabQ2DAdbJU+CFxKMTzcTa6nhYKukAwRidG+S+9luR2+FCHEG3asLE122a8yPyzR5OyHiiCSCbxRNAn6jaDdmuqyIP6R8I2KwK16XLXI0K+De2onsFom9uzqR3aKZyLoT6rLFRIUhbLku6xEIfW6XiS57C7AgdgcGNpA3Ls4XbtGhJGletuohsfdUk2QPTZLsaUCX7QEMmp4xHDTR0GURScg0wXtJgvdWCd5LQ/DeBnTZ7kBdthcwWHoz0WV7AIMaab8+THVZJG4/3lvTCAHfSqDL3ma5LivOfRsTXbaHxIpu35A+6stAl+1GMD7dbrkuK7gDxOj2lfvZbkdvhQhxBt3rDia6bL+YH5dp8nbFiCMqEeiylYC67J3MdFkRf0j5RsRgP8bPy/aX2AeoE1l/zUQ2gFCX7U5UGLIs12U9AqHPnc1El+0PLIgDgIEN5I2L84WZ52VtT5KmZauBEvsgNUkO1CTJQQZ02YHAoBkUw0ETDV0WkYRME/wuSfC7VYLfpSH43QZ02QFAXfYuYLDczUSXHQgMaqT9BjPVZZG4/XjvSSMEfA+BLnuv5bqsOPe9THTZgRIrun1D+ug+BrrsnQTj0/2W67KCO0CM7n1yP9vt6K0QIc6gew1hossOjflxmSZv1444og6BLlsHqMs+wEyXFfGHlG9EDA5l/LzsMIn9QXUiG6aZyB4k1GUHEBWGPMt1WY9A6HPnM9FlhwEL4oPAwAbyxsX5wszzsrYnSdOy1XCJ/SE1SQ7XJMmHDOiyw4FB81AMB000dFlEEjJN8BGS4CNVgo/QEHykAV32QaAuOwIYLCOZ6LLDgUGNtN/DTHVZJG4/3lFphIBHEeiyoy3XZcW5RzPRZYdLrOj2DemjRxjosg8QjE+PWq7LCu4AMbqPyP1st6O3QoQ4g+71GBNddkzMj8s0ebtexBENCHTZBkBd9nFmuqyIP6R8I2JwDOPnZZ+Q2MeqE9kTmolsLKEu+yBRYWhguS7rEQh97jOY6LJPAAviWGBgA3nj4nxh5nlZ25OkadlqnMT+pJokx2mS5JMGdNlxwKB5MoaDJhq6LCIJmSb4U5LgT6sEf0pD8KcN6LJjgbrsU8BgeZqJLjsOGNRI+z3DVJdF4vbjfTaNEPCzBLrseMt1WXHu8Ux02XESK7p9Q/roOQa67OME49MEy3VZwR0gRvc5uZ/tdvRWiBBn0L0mMtFlJ8X8uEyTt5tGHNGMQJdtBtRlJzPTZUX8IeUbEYOTGOuyUyT2qepENkUzkU0l1GXHEhWGsy3XZT0Coc99DhNddgqwIE4FBjaQN+45zHRZ25OkadlqmsT+vJokp2mS5PMGdNlpwKB5PoaDJhq6LCIJmSb4C5LgL6oEf0FD8BcN6LJTgbrsC8BgeZGJLjsNGNRI+73EVJdF4vbjfTmNEPDLBLrsK5brsuLcrzDRZadJrOj2DemjVxnospMJxqfXLNdlBXeAGN1X5X6229FbIUKcQfd6nYkuOz3mx2WavN0m4oi2BLpsW6AuO4OZLiviDynfiBicjtdljX2OwUyJfZY6kc3UTGSzCHXZqUSF4XzLdVmPQOhzX8BEl50JLIizgIEN5I2L84WZzzGwPUmalq1mS+xvqElytiZJvmFAl50NDJo3YjhooqHLIpKQaYK/KQk+RyX4mxqCzzGgy84C6rJvAoNlDhNddjYwqJH2e4upLovE7cf7dhoh4LcJdNl3LNdlxbnfYaLLzpZY0e0b0kfvMtBlZxCMT+9ZrssK7gAxuu/K/Wy3o7dChDiD7vU+E112bsyPyzR5u0vEEd0IdNluQF12HjNdVsQfUr4RMTiX8fOy8yX2BepENl8zkS0g1GVnERWGxpbrsh6B0Oe+kIkuOx9YEBcAAxvIGxfnCzPPy9qeJE3LVgsl9kVqklyoSZKLDOiyC4FBsyiGgyYauiwiCZkm+GJJ8CUqwRdrCL7EgC67AKjLLgYGyxImuuxCYFAj7beUqS6LxO3H+0EaIeAPCHTZZZbrsuLcy5josgslVnT7hvTRhwx02XkE49NHluuygjtAjO6Hcj/b7eitECHOoHstZ6LLroj5cZkmbw+IOGIQgS47CKjLfsxMlxXxh5RvRAyuYPy87EqJfZU6ka3UTGSrCHXZBUSFoanluqxHIPS5L2aiy64EFsRVwMAG8sbF+cLM87K2J0nTstVqif0TNUmu1iTJTwzosquBQfNJDAdNNHRZRBIyTfA1kuBrVYKv0RB8rQFddhVQl10DDJa1THTZ1cCgRtpvHVNdFonbj/fTNELAnxLosp9ZrsuKc3/GRJddLbGi2zekjz5noMt+TDA+fWG5Liu4A8Tofi73s92O3goR4gy615dMdNn1MT8uE92nRci3NISPabEnCuMGZrqsiD+kfCNicD3j52U3Suyb1Ilso2Yi20Soy64iKgzNLddlPQKhz30pE112I7AgbgIGNpA3Ls4XZp6XtT1JmpatvpLYN6tJ8itNktxsQJf9Chg0m2M4aKKhyyKSkGmCb5EE36oSfIuG4FsN6LKbgLrsFmCwbGWiy34FDGqk/bYx1WWRuP14v04jBPw1gS673XJdVpx7OxNd9iuJFd2+IX20g4Euu4FgfPrGcl1WcAeI0d0h97Pdjt4KEeIMute3THTZ72J+XNZ3/uo0Fg623KapjjMsFbffmMhejwP3E9xGSiOC398R1Vh1BdxbO+18L7H/oE4732umnR8INU+POOike7nlmqdHcPS5r7D83JuIiuyVlp/bSxjoc7ck0riTMDj3KxDfA5uLH4CJHJgnXGDsuUA+uy2Jmwl0Y0/VTDggnKalyZ2yWP+oFuudmmL9owHtfScwmH+M4WD+X9o7Omhs73BNB80uif0nNWh2aYLmJwNBswsYND+lxW6lOZC7gXCwBU1gSL/uZno3gMTtx/tzGiHgnwnuBn6x/G5AnPsXAt3C5O0yov03XY1+lTbfo1ajXzXVaI+B2+UfgLfLvwJJv4fJ7fJOYAVG2u83phXkN6IKsjeNEPBeggqyz/IKIs69z9DtcjjYKqnG+whEt9+Jb0aD4tuY9GeVR9lR7Pc7E593jmStbgl4n/9huc/FuYWfkD7/w3CniNZExJPCqL1+APtfXQH31nadTvqfP+LET3+HKf6D2nWKP6qhgEJfE1M5JGgHK+wRcK/9gRiXTkMUdAd7E9AXyA42lI5NNqY6WCRuP974dELA8en4fROAwUR17oT0/zcwaF+jGggiyZjWQBKlzZPUapSoqUZJ6fQaSFw6roIkAkmfRORcdAX5FThiIO2XzLSCJBNVkJR0QsApBBUk1fIKIs6dSlBBKLAmSKzoeTgN3OZSaCAJOIwl83Daoa5h/9LAhRUtvy3Spc3LqF1DuqZrEH9UXQFlYdeQmSv3SgcmujLpBy0pM7x/OHhS7t/bb4uykpTlVFKW1ZBS/FFNx3pSul4rWxZIynJg54LJlyECUJwX3RojAxvpj/LAikjgj5IqW56os6KKvT1xOP88moDbqwK42qN9PVreWKA708MsP7fwy2EEHfnh4PHRq1+HSynmfzUF6PzZDRhT3eOwvgu4135tTGNGEt3tCJlPj1SblSM0zcqRGt0t8SB0blA98Ahg0T6SiHSgJ5wPBr/ux3WU5cVFFJYjCIpLRcvPLfxSkeDcRxMV1aMPoKhS2Ah1Fg1c1N5ZfltUksWrss+3cMNUJHKyAF/NKV1gK/umTW+hJxLgedzKwOR5DA5Xpt+mx/hsirall1iC2qCouGQVir0qpWMTc2UmdxHe2UOEfA9qzypEuaBKOt2HKHCwa1XLGwhx1qoEDcSxRHw61nQD4eYUVbW7gdBOv9VkbqyuTr/VpAH9r1WnfupEMWLQKbMaMECrM70/QpDS9KNQNSQpa6qkrKGRZGpSk1IxYlBS1gCSsibYuajsXtLNFWZkC7vVSKdNEuH/siJ7eP9E+uM4BvLHcQRV/HiiKn48YVd4mOQmqiv04ugwIJ9OILLrCQfQHYXAHKkBnLqPY1jUTpRF7SS1qJ2oKWonpZN94ga5Q4IWyBOBAXSSpQXSfxl7IoE88W86TAs6Y+OXfrWkzWurwVhLE4y1D6DDRBoxaADVAgZQbaBzTY491RlWiJMlKeuopDxZQ8o6BsYeJClPBpKyDtC5JklZmyEpT5GkPFUl5SkaUp5qgJS1gaQ8BUjKUy1vNUQAnkKggiMD+zTw/IyeYUS7djKwbRb7ncbkdmpOJFO+R/DJEadb7nNx7sPAPj/dcMuPjvmZwOdwqwI7TM3RSYpiXem/sFoU62qKYvgAZvlwsEXmkKAFti6wOISJiIJuUN4CfnIEUpx2gXuZfN+vCxZBvZWRTgg4Ix2/bybQgVTnzoyymBUOttwwuItXV8C9tdUoS9o8W61GWZpqlG1gRAsDK0gWkPTZRM5Fi4HICoK0Xw74GQhTFSSHqILkphMCziWoIHmWVxBx7jwm83CmxIqeh/MZaCCZ4Hk4n3PX4OYUhsE+U1fAvbVdQz1p8/pq11Av/a9P/tWn7hoUIwbtGuoBE1194od6Aj5klSvslpVO64/wf1liD7mQXUgDBg9ZNSAoDGcQPQx0BvFDVlmWP2R1JpFdz4zCQ1ZZwMKMiDPTo/BZsqidrRa1szSj8NkGHrKickjQAnkWMIDOZvCQ1VnMb1xq29XQGL9xOUf671w1sM/RBPa5Bm5cqBwSNLDPAeI6l+nDX/UZVq7zJMHPVwl+nobg5xsQcZGkPA9IyvMNibjhYKvUs0XhYAtqvwuYXgNeQCTiNkwnBNyQQMRtZLmIK87diLOgFznDuQwrSGNp8wvVCtJYU0EuNFBBzgVWkMZA0l/I5BoQWUGQ9ruI6TXgRUQVpEk6IeAmBBWkqeUVRJy7KZNrwEYSK1q0uJjBNWAj8DXgxYZ8HvTs3kezokUe/xfUBcXYjOhKEs0j5Ef6XoI7c5aON+Fgy90SOWszglzR3PIbMeGX5gTnvpTo5uZSX3OMjnHxcdhAf5HZ9jIi2152ALdiB8snr+6Jw/Ig4F7GRf0Wst5frk6sLTQT6+UGRP1LgBNrC2CTfTlwr+nlsKK+4+inN3Ti7AYMFmAQlyL0FZLQVwr+ojNyi7/J9OFgy6XuHhDdTYt0PKGaA4OqpeUdmCBmS4IuoRVRlyD2vVPui7bFlUS2uIrIFlcR2kIkVQpbdK5gdzx0Jzr3TRXszqVUeeDm6J67/T/gI4v5LuBzewvd2ALj0QVy3AXyxkX6IkFyUDedOv/SN//ETf+eFHUfZRN/k3+1L5bgoFsSFVI/6H+J2f2n/x2B+WqCBNPVkgTzbxrgoGdunW5ngkH6ws/L1r4G77/6559sjvTPNb693MzMSGwU5rrFhcWZ2bn5Ge3cnMycnOKs4tycvKzC4uysgsLcIjerIDMjvyg3XOzmFRXlZme2z80pzi9sn1PsT9puYWZmVmF+u/ZudkZOQbtwXmFmQbg4KzczI1xQmJlbWJiZl5NTkJlZmJNXnJefl5FRUJyZF87Ozc0P52Rk5mdQ+eca6R+Taodl0uD+5S+I10q1ow2XYkCF71qCxH8dURG8jnCaFLZoQ2CLtkS2aEtoiz1EE2Y3yyfrS4gmrVssn6yp8kB3yydrqpjvwWSyBsajC+S4C+SN2+PQZK0u91qiybqA42RdQDxZFxAkmJ4H4WTdLt3OBNOTaHJrx2yybg+crHsAJ2sq/7T3TdZ/VxRslkQpcVIVmEKOBaaQuMAUEhSYXkQFBv1988gEVgTc62ZLu+FeRMmw6ACKVVCbFqfjikIp6daiYkXln2ID/kHGYgdgs2fp/XEp/3Q4gAdELXrOi8ymQc/Yx9BgFBTn9cBY6Qa0H1LF6UMUK9f/h6fww8EW2QO8Qf21B7jXJUBOalyCsl+W3983yGu8jhwHAwG+mlP6nQLiIPGK4dDvbUcWgo5A0nTC4cr027STz6bqXXegD7AsLi5RUG4AP4zt5wBq34OhSFDF/g0ED/Ajm+UbifLTjb6m9GC0a2cGj290pngQnIhPNx1A4wa1kZtThPahugLurX1r4c2yqemivrXwZmlA/2td0ok/DEcxYtC3Ft4MDNAuQOea/IQmBClNf0JTV0nKbiopu6b/9f2u3ahJqRgxKCm7IsdxsHNR2V1+5Hq2sFvXdNokEf4vK7KH90+kP26xvIqLt3LeQvHwFVEV707YFTaX3ER1hV4cId8u24PIrj0OoDtCTa/736EBVAJuYVjUesqi1kstaj01Ra2XAY2eyiFBC2RPYAD1srRA+t+z7xEDQLz9y2SH2QVc9NQVcG9tMPaWNu+jBmNvTTD2MdBhdgEGUG9gAPVhOvZ0YVghbpWkvE0l5a0aUt7GjJS3Akl5G9C5JknZhyEp+0pS3q6Ssq+GlLcbIGUfICn7Akl5O3GrEQ62SgKwL8FtDzKwkf64A9jeij3Qtwei9bs1HbvfHek0LSoIIwmvqyY6Ts1E/Ln7gc+NnqfFuZuD+dPP8CiCjqnKiVbdyBn/oMg7pf/6q8X6Tk2x7n8AGkM42CJzSNDCfyew0PQnIgq6cTo2EbcXUjQfANzL5NckDACLs94amE4IeGA6ft9BQAdSnXsQc5GtP3i6UFfAvbXV6C5p87vVanSXphrdbWB07A+sIHcBSX83kXPRox6ygiDtNxgsUpqqIIOJKsg96YSA7yGoIPdaXkHEue8lqCAUWAdJrOh5+D7L5+Hmssqj7Cj2u49z1+DmFPYH+0xdAffWdg33S5sPUbuG+9P/+kTiEOquQTFi0K7hfmCiG0IszAV8+CtX2O2udFp/hP/Liuzh/RPZhQy1XCgVCW0oQWF4gOghpQeIH/66y/KHv4YR2XVYFB7+ugtYmBFxZnoUflAWteFqUXtQMwoPN/DwF5VDghbIB4EBNJzBw18PMr9xAT4f5KIbGnUF3Fsb2A9J/41QA/shTWCPMHDjQuWQoIH9EDCwRzB9KG0Iw8o1UhL8YZXgIzUEf9iAiIsk5UggKR82JOKGgy3oM09I+41iKuIicfvxjk4nBDyaQMR9xHIRV5z7Ec6CXuQMIxhWkEelzR9TK8ijmgrymIEKMgJYQR4Fkv4xJteAfYEtJtJ+Y5hWkDFEFeTxdELAjxNUkCcsryDi3E8wuQZ8RGJFixZjGVwDPgK+BhxL5HNvUdgAtdc4oC0peH5YBN+5BDx/0tLbNQ9f40TH2ZiEF/TEniiMT1luwxUR4zVNxNtQ7IvC+LTlNlwTOWtzAhuuAdrwGctvZkWcPEOQw561/NxNIrx5Nh3NHbf9s8D6N95yG4qzjifgznNEt89i3xRHf/uMss2fn5dZVBJXTxPYBsAJ428NmiB72ImqCjNBo8JMJHj0QnUKWpUYD1R1JgATyEQgWUwGDYiMxuXGSRL7ZJXokzREn2yA6KDpbj85JwHJORkoOZrUwcen8yPmFEnMqSoxp2iIOdWADo7MmFOApJzK5CZ1ElAaQdpvGnAvkzr4NCId/Pl0QsDPE+jgL1iug4tzv8D8JnUiwwryorT5S2oFeVFTQV4yUEEmAivIi0DSv8TkJhVZQZD2e5npTerLRBXklXRCwK8QVJBXLa8g4tyvMrlJfUFiRatIr1l+k/qsrPIoO4r9XmN2k4pUkl+39CaVWi2dbvkN1s4IaToQ3GDtBN5gzQAXZLXLRp9dxM1EIN9F7EwH5g6P845mBdxb27nPlNhnqZ37TE3nPotAlPTAeY5BB9E9Fewu4h6B0Oe+1+4vAd0/Xc0EFrJZwMAG8sZF+MJLDIeSpHl5Y7bE/oaaJGdrkuQb6WRvkt0fNLOBQfNGDAdNNG6AEEnINMHflASfoxL8TQ3B5xjQ72YB9bs3gcEyh4l+NxsY1Ej7vcVUv0Pi9uN9O50Q8NsE+t07lut34tzvMNHvZkus6Nb/3XS7zy30nBkE537Pct1S+BuI0X1X7kfBdW+hbfAeMH+8D9YtvYUuxnNjuMP2ltgDHc8JEUf0ItA/xb4ojPOY6Z8i/pAyiYjBuXj9M8PRrIB7ayef+RL7AnXyma+ZfBYQ6p+zZDJHB9EQy/VPj0Docw9lon/OBxbEBcDABvLGHYrTPzMOJUnz8tBCiX2RmiQXapLkIgP650Jg0CyK4aCJhv6JSEKmCb5YEnyJSvDFGoIvMaB/LgDqn4uBwbKEif65EBjUSPstZap/InH78X6QTgj4AwL9c5nl+qc49zIm+udCiRXd+n/IQP+cR3DujyzXP4W/gRjdD+V+FFz3FtoGHwHzx3Im+ueKGO6wvSX2QMdzxYgjBhPonxWB+ufHzPRPEX9ImUTE4ArGz3+ulNhXqZPPSs3ks4pQ/1wgkzk6iB60XP/0CIQ+93Am+udKYEFcBQxsIG/c4Tj90z2UJM3LQ6sl9k/UJLlakyQ/MaB/rgYGzScxHDTR0D8RScg0wddIgq9VCb5GQ/C1BvTPVUD9cw0wWNYy0T9XA4Maab91TPVPJG4/3k/TCQF/SqB/fma5/inO/RkT/XO1xIpu/T9noH9+THDuLyzXP4W/gRjdz+V+FFz3FtoGXwDzx5dM9M/1Mdxhe0vsgY7n2hFHjCbQP2sD9c8NzPRPEX9ImUTE4HrGz39ulNg3qZPPRs3ks4lQ/1wlkzk6iEZarn96BEKf+2Em+udGYEHcBAxsIG/ch3H6Z8ahJGleHvpKYt+sJsmvNElyswH98ytg0GyO4aCJhv6JSEKmCb5FEnyrSvAtGoJvNaB/bgLqn1uAwbKVif75FTCokfbbxlT/ROL24/06nRDw1wT653bL9U9x7u1M9M+vJFZ067+Dgf65geDc31iufwp/AzG6O+R+FFz3FtoG3wDzx7dM9M/vYrjD9pbYAx3P9SKOmECgf9YD6p/fM9M/RfwhZRIRg98xfv7zB4l9pzr5/KCZfHYS6p+bZDJHB9EjluufHoHQ536Uif75A7Ag7gQGNpA37qM4/dM9lCTNy0M/Suy71CT5oyZJ7jKgf/4IDJpdMRw00dA/EUnINMF/kgTfrRL8Jw3BdxvQP3cC9c+fgMGym4n++SMwqJH2+5mp/onE7cf7Szoh4F8I9M9fLdc/xbl/ZaJ//iixolv/PQz0z+8Jzv2b5fqn8DcQo7tH7kfBdW+hbfAbMH/sZaJ/7ovhDttbYg90PDeNOGI6gf7ZFKh//s5M/xTxh5RJRAzuY6x//uFhL+OUnnL+0Ew+4o9qyL+nGBt/IyiKj1uuf3oEQp/7CSb65x/IhroMzi9A3rhPMNM/bU+SpuWhuDLSzmqSFP9BTZKhMvT6Z1wZXNCEYjhooqF/IpKQaYLHS4InqASP1xA8oQy9/umUwQVLPDBYEoicix654oBBjbRfIg6XUf0TiduPN6kMIeCkMvh9k4FkoDp3cpn/NzBoXxKscRIruvVPKWP3uYX++TvByJMKPjda+xP+BmJ0U+R+FFz3FtoGqcD8kQa0pf/M6GKcHsMdtrfEHuh4bhNxxHwC/bMNUP8sA25oqEf7knwB5KOIwXRgDjL9/veyEns5dfIpq5l8yhHqn45M5uggetJy/dMjEPrcTzHRP8sCC2I5YGADeeM+hdM/Mw4lSfPyUHmJvYKaJMtrkmQFA/pneWDQVIjhoImG/olIQqYJfpgk+OEqwQ/TEPxwA/pnOaD+eRgwWA5non+WBwY10n5HMNU/kbj9eI8sQwj4SAL98yjL9U9x7qOY6J/lJVZ061+Rgf5ZhuDcR1uufwp/AzG6FeV+FFz3FtoGRwPzRyUm+mflGO6wvSX2QMdzl4gjVhPon12A+ucxzPRPEX9ImUTEYGW8/mns+c8qEntVdfKpopl8qhLqn+VkMkcH0bOW658egdDnHs9E/6wCLIhVgYEN5I07Hqd/uoeSpHl56FiJvZqaJI/VJMlqBvTPY4FBUy2GgyYa+iciCZkmeHVJ8BoqwatrCF7DgP5ZFah/VgcGSw0m+uexwKBG2q8mU/0TiduP97gyhICPI9A/j7dc/xTnPp6J/nmsxIpu/U9goH8eQ3DuEy3XP4W/gRjdE+R+FFz3FtoGJwLzx0lM9M9aMdxhe0vsgY7nARFHbCHQPwcA9c/azPRPEX9ImUTEYC3Gz3+eLLHXUSefkzWTTx1C/bOqTOboIJpouf7pEQh97klM9M+TgQWxDjCwgbxxJ+H0z4xDSdK8PHSKxH6qmiRP0STJUw3on6cAg+bUGA6aaOifiCRkmuCnSYKfrhL8NA3BTzegf9YB6p+nAYPldCb65ynAoEbary5T/ROJ2483XIYQcJhA/3Qt1z/FuV0m+ucpEiu69c9goH/WJjh3puX6p/A3EKObIfej4Lq30DbIBOaPLCb6Z3YMd9jeEnug43lhhHwNCfRPsS8KYw4z/VPEH1ImETGYzfj5z1yJPU+dfHI1k08eof5ZRyZzdBBNtVz/9AiEPvc0JvpnLrAg5gEDG8gbdxpO/3QPJUnz8lC+xF5PTZL5miRZz4D+mQ8MmnoxHDTR0D8RScg0wetLgjdQCV5fQ/AGBvTPPKD+WR8YLA2Y6J/5wKBG2u8MpvonErcf75llCAGfSaB/nmW5/inOfRYT/TNfYkW3/mcz0D9zCM59juX6p/A3EKN7ttyPguveQtvgHGD+OJeJ/nleDHfY3hJ7oPNE44j2uTEJnyfOJ86PQfGtiARdU4rvfUrEYbyAme4r8g5SHhK55zx47nWLHc0KuLd24msosTdSJ76GmomvEaHumyeLGDqIXrQ8uXkEQp/7JSa6b0NgI9AIGNhA3rg4X7jFh5KkeVmsscR+oZokG2uS5IUGdN/GwKC5MIaDJhq6LyIJmSb4RZLgTVSCX6QheBMDum8joO57ETBYmjDRfRsDgxppv6ZMdV8kbj/ei8sQAr6YQPdtZrnuK87dzJDuiwhSgRXdviF9dInlGrLQcC4gGJ+aE2vI4WCrpAMEYnQvkfvZbkdvhQhxBt3rUiZ69GUxPy7T5O01EfI1J9BlmwN12RYM8nYLgnxzueXnHh8J4svhNd9tfzkwf11huQ3FWa8g4M6V4CbfG07EvinOnyoQtXQn6hhSBhW17DKCOeIKor7AweDUqiQt5VzRSlVJWmpUklaEdyWNiJq1Vy2/K/k7MgY992tEdyWJ4PNfAVTFWgILRitgwgFy0EX6lXPydkA4TcvSV0nsV6sJ9ypNwr3awL3LVcCguTqGgyYa9y6IjsI0wVtLgl+jEry1huDXGLh3QVaY1sBgucbQvUs42IImCKT9rmV674LE7cfbpgwh4DYE89J1lt+7iHNfR3DvYrKCtGJYQdpKmxeoFaStpoIUGKggrYAVpC2Q9AVMbu6vAraFSPu1Y1pB2hFVkPZlCAG3J6gghZZXEHHuQkM39+Fgq6QaFxIIUUXEt86I25XrgAlK7FdE5HNvUdgAtVcxk5viDgeBwCf2QMfzzgj5OhDcFHcA3hRfDy7s1CKpiD+k4CxisAM8B5l7B88NEntHdQK4QTMBdCS8lfIcgw6imZbfSnkEQp97FpN38NwALIgdgYEN5I2L84WZd/DYniRNyySdJPYb1STZSZMkbzRwk9QJGDQ3xnDQROMmCZGETBO8syT4TSrBO2sIfpMBHbAjUAfsDAyWm5jogJ2AQY20381MdUAkbj/eLmUIAXch0AG7Wq4DinN3NaQDIoK0axl8+4b0UbcytDYMB1slT4JfTzA+3UKspYaDrZIOEIjR7Sb3s92O3goR4gy6V3cmumyPmB+XafJ2QsQRvQh02V5AXbYnM11WxB9SvhEx2AOvyxY5mhVwb+1E1kti761OZL00E1lvQl22I1FheNNyXdYjEPrcc5josr2ABbE3MLCBvHFxvnCLDiVJ87JVH4n9VjVJ9tEkyVsN6LJ9gEFzawwHTTR0WUQSMk3w2yTB+6oEv01D8L4GdNneQF32NmCw9GWiy/YBBjXSfrcz1WWRuP147yhDCPgOAl22n+W6rDh3Pya6bB+JFd2+IX10JwNdtifB+NTfcl1WcAeI0b1T7me7Hb0VIsQZdK8BTHTZgTE/LtPk7YoRRwwm0GUHA3XZQcx0WRF/SPlGxOBAxs/L3iWx361OZHdpJrK7CXXZ3kSF4R3LdVmPQOhzv8tEl70LWBDvBgY2kDcuzhdmnpe1PUmalq0GS+z3qElysCZJ3mNAlx0MDJp7YjhooqHLIpKQaYLfKwl+n0rwezUEv8+ALns3UJe9Fxgs9zHRZQcDgxppv/uZ6rJI3H68Q8oQAh5CoMsOtVyXFeceykSXHSyxots3pI8eYKDLDiIYn4ZZrssK7gAxug/I/Wy3o7dChDiD7vUgE112eMyPyzR5u3bEEaMJdNnRQF32IWa6rIg/pHwjYnA44+dlR0jsI9WJbIRmIhtJqMveTVQY5lquy3oEQp97HhNddgSwII4EBjaQNy7OF2ael7U9SZqWrR6W2EepSfJhTZIcZUCXfRgYNKNiOGiiocsikpBpgo+WBH9EJfhoDcEfMaDLjgTqsqOBwfIIE132YWBQI+33KFNdFonbj/exMoSAHyPQZcdYrsuKc49hoss+LLGi2zekjx5noMs+RDA+PWG5Liu4A8ToPi73s92O3goR4gy611gmuuy4mB+XafJ2vYgjJhDoshOAuuyTzHRZEX9I+UbE4DjGz8s+JbE/rU5kT2kmsqcJddmRRIVhoeW6rEcg9LkXMdFlnwIWxKeBgQ3kjYvzhZnnZW1PkqZlq2ck9mfVJPmMJkk+a0CXfQYYNM/GcNBEQ5dFJCHTBB8vCf6cSvDxGoI/Z0CXfRqoy44HBstzTHTZZ4BBjbTfBKa6LBK3H+/EMoSAJxLospMs12XFuScx0WWfkVjR7RvSR5MZ6LJPEoxPUyzXZQV3gBjdyXI/2+3orRAhzqB7TWWiy06L+XGZJm83jThiOoEuOx2oyz7PTJcV8YeUb0QMTmOsy74gsb+oTmQvaCayFwl12aeJCsNSy3VZj0Doc3/ARJd9AVgQXwQGNpA37gfMdFnbk6Rp2eolif1lNUm+pEmSLxvQZV8CBs3LMRw00dBlEUnINMFfkQR/VSX4KxqCv2pAl30RqMu+AgyWV5nosi8Bgxppv9eY6rJI3H68r5chBPw6gS473XJdVpx7OhNd9iWJFT7fA300g4Eu+zzB+DTTcl1WcAeI0Z0h97Pdjt4KEeIM/JXbTHTZ2TE/LtPk7TYRR8wn0GXnA3XZN5jpsiL+kPKNiMHZeF3W2OcYvCmxz1Ensjc1E9kcQl32RaLC8JHluqxHIPS5lzPRZd8EFsQ5wMAG8sbF+cLM5xjYniRNy1ZvSexvq0nyLU2SfNuALvsWMGjejuGgiYYui0hCpgn+jiT4uyrB39EQ/F0DuuwcoC77DjBY3mWiy74FDGqk/d5jqssicfvxvl+GEPD7BLrsXMt1WXHuuUx02bckVnT7hvTRPAa67BsE49N8y3VZwR0gRnee3M92O3orRIgz6F4LmOiyC2N+XKbJ210ijlhNoMuuBuqyi5jpsiL+kPKNiMGFjJ+XXSyxL1EnssWaiWwJoS47h6gwrLRcl/UIhD73Kia67GJgQVwCDGwgb1ycL8w8L2t7kjQtWy2V2D9Qk+RSTZL8wIAuuxQYNB/EcNBEQ5dFJCHTBF8mCf6hSvBlGoJ/aECXXQLUZZcBg+VDJrrsUmBQI+33EVNdFonbj3d5GULAywl02RWW67Li3CuY6LJLJVZ0+4b00ccMdNlFFGOj5bqs4A4Qo/ux3M92O3orRIgz8OjNRJddHfPjMk3eHhBxxBYCXXYLUJf9hJkuK+IPKd+IGFzN+HnZNRL7WnUiW6OZyNYS6rJLiArDGst1WY9A6HOvZaLLrgEWxLXAwAbyxsX5wszzsrYnSdOy1TqJ/VM1Sa7TJMlPDeiy64BB82kMB000dFlEEjJN8M8kwT9XCf6ZhuCfG9Bl1wJ12c+AwfI5E112HTCokfb7gqkui8Ttx/tlGULAXxLosust12XFudcz0WXXSazo9g3pow0MdNlPCManjZbrsoI7QIzuBrmf7Xb0VogQZ9C9NjHRZb+K+XGZJm8vjJCvIYEu2xCoy25mpsuK+EPKNyIGv2L8vOwWiX2rOpFt0UxkWwl12bVEheEzy3VZj0Doc3/ORJfdAiyIW5HTKLDQ4Hxh5nlZ25Okadlqm8T+tZokt2mS5NcGdNltwKD5OoaDJhq6LCIJmSb4dknwHSrBt2sIvsOALrsVqMtuBwbLDia67DZgUCPt9w1TXRaJ24/32zKEgL8l0GW/s1yXFef+jokuu01iRbdvSB99z0CX3UwwPv1guS4ruAPE6H4v97Pdjt4KEeIMutdOJrrsjzE/Lus7f3UaCwdbbvN0xxmRjttvXGSvJ4H7CW4jpRHB7x+Jaqy6Au6tnXZ2Sew/qdPOLs208xOh5ukRB51011uueXoER597g+Xn3kpUZDdafm4vYaDPvYlI407C4NyvQOwCNhc/ARM5ME+4wNhzgXx2NxE3E+jGnqqZcEA4TUuTu2Wx/lkt1rs1xfpnA9r7bmAw/xzDwfy/tHd00Nje4ZoOml8k9l/VoPlFEzS/GgiaX4BB82uZ2K00B3I3EA62oAkM6dc9TO8GkLj9eH8rQwj4N4K7gb2W3w2Ic+8l0C1M3i4j2n/T1WiftPnvajXap6lGvxu4Xf4JeLu8D0j635ncLu8GVmCk/f5gWkH+IKogTllCwGJz9L5xZe2uIOLccWX/376gfUmw7pVY0aJbqCztzWhgMTTpzyqPsqPYL8TE54siWJcl4X0eb7nPxbmFn5A+jyfw+f/qFNGayNwkmoYpHHBpjk7SdSZI/yWKn/4OM6HsX7tO8Uc1FFDoa2IqhwTtYBOARTexLA1R0B3sYqAvkB1sUllssjHVwSJx+/EmlyUEnEzQwaZY3sGKc6cYrmzoMyCSjGkNJFXaPE2tRqmaapRWll4DSSyLqyCpQNKnETkXXUH2AUcMpP3SmVaQdKIKUqYsIeAyBBWkrOUVRJy7LJN5OEViRc/D5RhoICk4jCXzcLlDXcP+pYELK1p+W5SXNq+gdg3lNV2D+KPqCigLu4bMXLlXeWCiq1A2OqS0YF7O8P7xf+2dB3RVxRaGbxokQIBAqKF3lJJGkWboXYiAIUhJSOgQikiHFxUVEQEFFFGKiBQBQQRFBFFKRFC6WCiiotI0KqCg7/neHjyXbMZz/rcW7HPemrXeXWuv7Llf5p85e+b+N7nlHJ/8pryhzWsRYW3KQvqmjLDZlOqXyvvwppQs4i1qxfj/lI0Q3JSFhBdX2BFj1QNQHa/0ekg+sCXXo7DgM6IL63H9WbawS39Z+W/SBhZ5yzWtG6Pfc90vfDkvvPq95E9fjqf482CWqzn8yfoVoXZRimIUxcNz7vffxJ8UBbWKCO73Eh69GBt9e7eYXIJaRQXrV9KQ+uUW1ComWL8o4X/pdW8oEZ7jASVZHsXy4po3lKJ2aYoy6o9lD7whVFCrlODalDNkb4cJapUWrF95Q+qXR1CrjGD9KrjsDeWYB5RneQWWl9W8oSK1K1FUpqjigTfkFdSqKLg2VQ3Z2/kEtSoJ1q+aIfULF9SqLFi/6i57Q1XmAdVYXp3lVTRvuIPad1LUoKjpgTfkF9S6Q3BtahmytwsIat0pWL/ahtSvoKBWDcH6RbvsDbWYB9RmeTTLa2reoIw0liKOIt4Db4gQ1IoRXJs6huztQoJasYL1q2tI/QoLasUJ1q+ey95Qh3lAXZbXY3m85g31qX0XRQOKhh54Q6SgVn3BtWlkyN4uIqh1l2D9GhtSv6KCWg0E69fEZW9oxDygMcubsLyh5g13qzlRNKVo5oE3FBPUultwbZobsreLC2olCNavhSH1KyGo1VSwfi1d9obmzANasLwly5tp3tCK2q0p2lC09cAbSgpqtRJcm3aG7O0oQa3WgvVrb0j9SglqtRGsXweXvaEd84D2LO/A8raaN3Sk9j0UnSg6e+ANpQW1OgquTaIhe7uMoNY9gvW715D6lRXU6iRYvy4ue0Mi84B7Wd6F5Z01b+hK7W4U91EkeeAN5QS1ugquTXdD9nZ5Qa1ugvVLNqR+FQS17hOsXw+XvaE784BklvdgeZLmDfdTuydFL4reHnhDRUGt+wXXpo8he7uSoFZPwfqlGFK/yoJavQTrl+qyN/RhHpDC8lSW99a8oS+10yjSKfp54A1VBLX6Cq5Nf0P2dlVBrTTB+g0wpH7VBLXSBes30GVv6M88YADLB7K8n+YNg6g9mGIIxVAPvKG6oNYgwbUZZsjevkNQa7Bg/TIMqd+dglpDBOs33GVvGMY8IIPlw1k+VPOGEdQeSTGK4gEPvKGGoNYIwbUZbcjerimoNVKwfg8aUr9aglqjBOs3xmVvGM084EGWj2H5A5o3jKX2OIrxFBM88IbaglpjBddmoiF7O1pQa5xg/SYZUr8YQa3xgvWb7LI3TGQeMInlk1k+QfOGKdT+B0UmxUMeeEOsoNYUwbV52JC9HSeo9Q/B+j1iSP3iBbUyBes31WVveJh5wCMsn8ryhzRveJTaj1E8TjHNA2+oI6j1qODaPGHI3q4rqPWYYP2mG1K/eoJajwvW70mXveEJ5gHTWf4ky6dp3jCD2k9RzKSY5YE31BfUmiG4NrMN2dt3CWo9JVi/pw2pXwNBrZmC9XvGZW+YzTzgaZY/w/JZmjfMofZcinkUz3rgDQ0FteYIrs1zhuztRoJacwXrN9+Q+jUW1JonWL/nXfaG55gHzGf58yx/VvOGBdR+geJFioUeeEMTQa0FgmuzyJC9fbeg1guC9VtsSP0SBLVeFKzfEpe9YRHzgMUsX8LyhZo3vETtpRQvUyzzwBuaCmq9JLg2rxiyt5sJai0VrN9yQ+rXXFDrZcH6rXDZG15hHrCc5StYvkzzhpXUXkXxKsVqD7yhhaDWSsG1WWPI3m4pqLVKsH5rDalfK0GtVwXr95rL3rCGecBalr/G8tWaN6yj9nqK1yk2eOANrQW11gmuzRuG7O02glrrBeu30ZD6tRXUel2wfptc9oY3mAdsZPkmlm/QvOFNar9FsZnibQ+8oZ2g1puCa7PFkL3dXlDrLcH6vWNI/ToIam0WrN9Wl71hC/OAd1i+leVva96wjdrvUmyneM8Db+goqLVNcG3eN2Rv3yOo9a5g/XYYUr9OglrbBeu302VveJ95wA6W72T5e5o37KL2boosig888IbOglq7BNdmjyF7O1FQa7dg/T40pH73CmplCdZvr8vesId5wIcs38vyDzRv2Eftjyg+ptjvgTd0EdTaJ7g2BwzZ210FtT4SrN9BQ+rXTVDrY8H6HXLZGw4wDzjI8kMs3695w2FqH6E4SvGJB95wn6DWYcG1OWbI3k4S1DoiWL9PDalfd0Gto4L1+8xlbzjGPOBTln/G8k80b/ic2l9QHKc44YE3JAtqfS64NicN2ds9BLW+EKzfKUPqd7+g1nHB+n3psjecZB5wiuVfsvyE5g2nqf0VxdcU33jgDT0FtU4Lrs0ZQ/Z2L0GtrwTr960h9estqPW1YP2+c9kbzjAP+Jbl37H8G80bvqf2WYpzFOc98IY+glrfC67NBUP2doqg1lnB+l00pH6pglrnBOv3g8vecIF5wEWW/8Dy85o3/EjtbIqfKH72wBsCBbV+FFybX1xem1/YGmSz/CeW/6ytzSVqX6a4QvGrzdoECq8N17rdel5yySsCtGO+3Xn+duvzjNPvsFt3tUY3zp3C8oks/01b96vUvkbxO8UfHqz7JMF6XhV+HPmPPVWraZDFQihyUeSmCKVQ15lX10pX1+RW15Wm6fjUNXjVdWQLUkRYa6SufaiusaeuE6eudaauqaWuC6WubaSuoaOuA6OuZaKumVGGQl27oBxFeYoKFBUpKlGocxOrc+Cq87iqc5Gqc16q8zaqcw+qc9zVpFDnGlPntFIbWT3I1Dls1HlY1LlE1Dkr1HkX1LkD1HfU1fes1XeF1XdS1fcq1XcDm1D4v0fVlKIZhfrsv/qMufqctPqsr/pMqfpcpPpsn/oMmfoclPosT0cK9bkH9d69eo9Yvc+p3qtT7wmp9zXUa/PqNWD1OqZ6LU695qNet1D/e6v/8dT/KepvbfU3XYq1DlG+nFtfijSKdIp+FP0pBlAMpBhEMZhiCMVQimEUGRTDKUZQjKQYRfEAxWiKBynGUIylGEcx3vfXY0Y9VvyPe7VXPwzIGT/T+tn8Xydar3/msWo+dpsO2FzAFgG2xPpZ5EzTEiP3rmjJ2VLAlgH2GhhvM2BbrJ/75h7IWjktNZ2zrWC8LKB5ELDDYLyjYLxjgJ0CmqfBXM6CfudBv19Av8ugX/4A52MoDli5AOfxKgQ4jxcL+sWDfp0B6wlYb3AMg0G/MYCNA8cwCYw3DWjOBexZMN4CMN5yoLkBsI1Acytg28E8dwC2C2juAWwf0NwP2EGgeQT0Owb6fQ76HQf9ToF+p0G/i2D9rgL2O9DMFejcrxBgkYHOx1A00Hm8CkCzFmDRYLw4MF49oNkQsMZAsyVgbcA82wPWEWgmAtYVaCYBlgw0e4F+KYD1BZr9QL+BgA0GmsNAvxGAjQKa+8Ce+ASwLwE7B9gFMJcfAMsG7BoYLyjImYVYzK5muYOcx4sAmlGAlQbjlQXjVQeacYA1Bqw1YG3BXNoD1hGwJDBeKmBpoGb9wHjDgeZ4wCaC8SaD8Z4CmvMAWwg0l4C5rAZsLdDcANh7YJ5fAHYRsEtgnlfAXH4HrGCw83glASsV7KxZyWKLV5XZFHUmsAdnVQCLBiwWsDqA1QOsKWDNAWsDWDvAOoB6dgIsCdS6h8VsH9OADQCaQwGbANgMcAyLAHsFzHMFGG8NYDsAuwJYgRDnedYGrBNgwwGbBdg6wA4Alg1YgVzg+ABrDdgAi9nVMwOw6YAtBWwLYIcBOw9YYG5nVhKwWMDaAdYXsAmALQBso8Xs1igL9MsG/X4D7N9AMzD0r592j+lwwAqEOmtGAlYh1Hme9QFrB1gimGcXMJfugGWA8cYBNgFoPmwxu+ecqYDNBGw2YHMAmwfYYsBeAmw5YCsBexXUcy1gm0CtN4M9sROw3UBzL2CfAXYeHMM/AQsKc55nSJjzeHkAKwdYc8B6hTnPczxg8wB7HbCPATsHWEgeZ1YesMaAJQM2ErDpFrOr59OArQVsN2AnAbsCWHheZ1YZsMaAdQNsGGCPArYQsG2AHbGY3Rp9C/pdA/0C8jmzsHzOmvksZveYLgZYCaBZBrAaYJ5NAOsMWBKYZzKYS2/ARoPxpgCWCTSnWczuOWc6YHMAmwfYfMAWALYMsOWArQZsLWDrQD03ALYF1Hob2BN7ANsLNA8AdhKwbHAMAeHOLDTceZ55wp3HKwBYZcDqAtYZzHMgYJmAzQdsPWB7ADsN2FXACuZ3ZtUASwAs2WJ29UwBbBJgcwFbA9guwE4AdhmwfAWcWSXAGgHWFbChgM0AbJHFbPcZ6Pcu6JcF2H6gechido/pE4CdAprfAPYzmOclwEIKOrN8BZ3nmb+g81wKA1YdjFcLsGigWd9ids85DQBrAVgrwNoC1h6wboAlAdYTsN6ApYB6pgE2BNQ6A+yJ8YBNBJqZgM0EbDY4hqWArQLzXA3GWw9YFmCHALsA5hkU4cyiAIsDrD1gaYBNBGwOYKsB2wnYccAuW8yunn8AVqyQM6sNWGvA+gA2FrBZgK0AbDtgnwKWDVjuws6sKmDVLWb7+RfQry3olwhYMtDsaTHb97IAGwQ0MwCbBOY5BbDZgD0H5vk8mMsiwDaC8d4G7B2gudNids85uwE7ANghwI4Cdgyw04B9Ddj3gJ0D7AKo54+A/QpqfQ3sieBIZ5Yr0lkzL2AlAIuKdD6GmoDFg3nWBeM1BCwRsB6AjQbznAHYMsC2AnYUsIuABRdxZqUAiwesA2DpgE22mF09pwK2BLDNgB0E7Cxg17+g4sCKAxYNWBvAUgAbB9hswNYDtsFidmu0y6Gf9VGG69/HUTfrLYwb341SH99VH/9JsNrRt3eLCWO60vr1o+PrhvluvgnPPy7Ml/PdKbfq49d0QT/aesvd1zwzR18/FnULt9rsK0I3+oRa3Md+tmB6ARpraTOWm8dJ+yDerx/sgj7dYgvbzN8/lqqP/7tdQTa/F6D1CfI5r4PP5r4AGx29rnzdEm7tmGP0O/TjRMfmZyHasdodN+8f4vv7cYdo+vqa+mzGCHLoa6cbCI7jv/XltQ/3/X0d/fNRb9n5vSk48+b5J1j3R9/GrV79v77nef3YLf0Q39/3ER8/RPv9clY7D5s/P46EW5xn/3qpMf3jUvun1klNT49PSy2k6ftYzVSdylr5/5+L4C3O5eeKWJc91Pa5yM5P0XOR/phTtxYWs3ue4s9Ffj03n9NpH9RxeZ1iCvucnz9UDUrklOamuob4nJ9HQrTftf4Vuf4d8QgHvVxAL9znvL6qXzErD7PR8AnWym4eATbzCLeZh7+PCV5exmr/r7081MrDbOYj7VX+MV3Qv+FV/JaH5Xk15q9BsE2/AId2oPYT/a5+P78v3Ib5Na2Xi26ar/84wrSfRZiuG8+7ke7o265VEZZHasfJ650gNAe/nv8xG2Izp0CNcc/m8xP4W16/xehzCbIZy3/z75lIdp+/nv8BAhubDuyaEwA=","debug_symbols":"7b3dbjQ5lmX5LnmdF2bkIXlYrzIYNLKrshsJJDIL9TPAoFDvPoqMcJMizIa7FcZPOtzbbhqILk/pLLo+56KZtOy//vAvf/6f//m//8df/va//v7vf/in/+u//vDXv//zn/7jL3//29t//dcf9r3/4//z3//1T3/76b///T/+9G//8Yd/8rr98Q9//tu//OGf+lb++49/+F9/+euf//BPNf33H08v3S37L6/drfn7i+vFi9PeXl84pc3eX9yuvnLLry/s+eNL/+8//mFP26Jz74vOneLO7fX1hXs9zZ0XndsWnbus8PN9MXdddO4Wdu60veZOezrN7YvO/bX7Zcr1mLttNz6/87bo3Puic6e4c48+v3NedG5bdO6yws/3xdx10blb2LmH+072Ref+2v0yb/trlpzLjc9v2xade1907hR37tHnt+VF57ZF5y4r/HxfzF0XnbuFnXu475gvOvcX75e1vWaxbb/x+V22RefeF507xZ179Pld8qJz26JzlxV+vi/mrovO3cLOPdx3ii8699ful5b8mLv33w5Tt0jD7N81TLHtNEyKNEz+tmFaOw1jkYb52t2i7sddmWp37k7XuujcbdG5Pe7cIxuqfc2527bo3PsKP98Xc6dF585h5x5aXLNF5/7i/bId1tz2O1cPWl107rbo3B537uHnd19zbt8WnXtf4ef7Yu606Nw57NzDfcdt0bm/dr9s2Y65i52GqZGGad82TDttV+6RhvnaPci3YxjPfmPP79uic++Lzp3izj3a83tedG5bdO6yws/3xdx10blb2LmHrtJ90bm/eL+s/TVL3/Lv//xO27bo3Puic6e4cw8+v99+9hed2xadu6zw830xd1107hZ27tG+kzZfdO6v3S97Ovb5bqdh9i3SMPu3DVP6aZgUaZipe5CDYby3128Xe3c/DWORhrm9W5RUXsMUA8OU/RimvF1COw1TIw3TIg3jkYbpgYa5HxaZOcz+pcOknF7DpHI6MNxPgMwcJn/tMGkbDWORhvnaT+C3f73HMHU7DVMjDdMiDeORhumBhslbpGG+9hM4H7+eW7KdtDOnSMN88SdwT6NhLNIwX/wJ3A+FyKWchqmRhmmRhvFIw/RAw9gWaZiv/QS2cmwHv7pK8MswKdIwX/sJnPtwGIs0zNd+Apd3hXgb7DRMjTRMizSMRxrmaz+B7f0H+Dd/onZ1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","file_map":{"6":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n","path":"std/cmp.nr"},"18":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        /*@safety: borrow is enforced to be boolean due to its type.\n            if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n            if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n        */\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            /*@safety: decomposition is properly checked below*/\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            unsafe {\n                //@safety: already unconstrained\n                field_less_than(b, a)\n            },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            //@safety: unsafe in unconstrained\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        unsafe {\n            //@safety: Take a hint of the comparison and verify it\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"19":{"source":"pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            //@safety : unconstrained context\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"26":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"62":{"source":"use commitment::nullify;\nuse compare_date_lib::{compare_date, get_expiry_date};\n\nfn main(\n    comm_in: pub Field,\n    salt: Field,\n    private_nullifier: Field,\n    dg1: [u8; 95],\n    // The current date is public so verifiers can check the date\n    // provided to the proof is correct\n    current_date: pub str<8>,\n    // The minimum date required is public so verifiers can check\n    // the date provided to the proof is correct\n    // If the minimum date is a string of 1 (i.e. \"11111111\") it is not checked\n    min_date: pub str<8>,\n    // The maximum date required is public so verifiers can check\n    // the date provided to the proof is correct\n    // If the maximum date is a string of 1 (i.e. \"11111111\") it is not checked\n    max_date: pub str<8>,\n    service_scope: pub Field,\n    service_subscope: pub Field,\n) -> pub Field {\n    let expiry_date = get_expiry_date(dg1, current_date.as_bytes());\n    // Verify the expiry date of the ID holder\n    compare_date(expiry_date, min_date.as_bytes(), max_date.as_bytes());\n    let nullifier = nullify(\n        comm_in,\n        salt,\n        dg1,\n        private_nullifier,\n        service_scope,\n        service_subscope,\n    );\n    nullifier\n}\n","path":"/Users/madztheo/Documents/Wagmi/Studio/RnD/Docaproof/Circuits/zk_id_check_circuits/src/noir/bin/compare/expiry/src/main.nr"},"63":{"source":"use common::{calculate_scoped_nullifier, hash_salt_dg1_private_nullifier};\n\n/*\n############################################################\n# Circuit D\n############################################################\n# Generates a scoped nullifier that is scoped by service\n# Allows selective disclosure of dg1 via a reveal bitmask\n############################################################\n\n# Inputs/Outputs\n############################################################\ncomm_in             `assert comm_in == H(salt, dg1, private_nullifier)`\nsalt\ndg1\nprivate_nullifier\nservice_scope       `H(<domain_name>)`\nservice_subscope    `H(<purpose>)` (Service-specific subscope)\nscoped_nullifier    `H(private_nullifier, service_scope, service_subscope)`\n\n# Checks\n############################################################\n- Checks that dg1_reveal is the correct reveal of dg1 for the given dg1_mask\n- Constrains scoped_nullifier to be `H(private_nullifier, service_scope, service_subscope)`\n*/\npub fn nullify(\n    comm_in: Field,\n    salt: Field,\n    dg1: [u8; 95],\n    private_nullifier: Field,\n    service_scope: Field,\n    service_subscope: Field,\n) -> Field {\n    assert(comm_in == hash_salt_dg1_private_nullifier(salt, dg1, private_nullifier));\n    // println(f\"comm_in: {comm_in}\");\n    let scoped_nullifier =\n        calculate_scoped_nullifier(private_nullifier, service_scope, service_subscope);\n    // println(f\"scoped_nullifier: {scoped_nullifier}\");\n    scoped_nullifier\n}\n\n","path":"/Users/madztheo/Documents/Wagmi/Studio/RnD/Docaproof/Circuits/zk_id_check_circuits/src/noir/lib/commitment/scoped-nullifier/src/lib.nr"},"64":{"source":"//use std::hash::pedersen_hash;\nuse std::hash::poseidon2::Poseidon2;\nuse utils::PASSPORT_MRZ_COUNTRY_INDEX;\n\npub global CSC_CERT_TYPE: Field = 1;\npub global DSC_CERT_TYPE: Field = 2;\n\npub fn calculate_scoped_nullifier(\n    private_nullifier: Field,\n    service_scope: Field,\n    service_subscope: Field,\n) -> Field {\n    Poseidon2::hash([private_nullifier, service_scope, service_subscope], 3)\n}\n\npub fn calculate_certificate_registry_leaf<let N: u32>(\n    registry_id: Field,\n    cert_type: Field,\n    country: str<3>,\n    csc_pubkey: [u8; N],\n) -> Field {\n    let country_bytes: [u8; 3] = country.as_bytes();\n    let mut result: [Field; N + 5] = [0; N + 5];\n    result[0] = registry_id as Field;\n    result[1] = cert_type as Field;\n    result[2] = country_bytes[0] as Field;\n    result[3] = country_bytes[1] as Field;\n    result[4] = country_bytes[2] as Field;\n    for i in 0..N {\n        result[i + 5] = csc_pubkey[i] as Field;\n    }\n    Poseidon2::hash(result, N + 5)\n}\n\npub fn get_country_from_dg1(dg1: [u8; 95]) -> str<3> {\n    // There 5 padding bytes in the dg1 before the actual MRZ\n    let country_offset = 5 + PASSPORT_MRZ_COUNTRY_INDEX;\n    let mut country_bytes: [u8; 3] = [0; 3];\n    for i in 0..3 {\n        country_bytes[i] = dg1[country_offset + i];\n    }\n    country_bytes.as_str_unchecked()\n}\n\npub fn hash_salt_country_tbs<let TBS_MAX_SIZE: u32>(\n    salt: Field,\n    country: str<3>,\n    tbs: [u8; TBS_MAX_SIZE],\n) -> Field {\n    let country_bytes: [u8; 3] = country.as_bytes();\n    let mut result: [Field; TBS_MAX_SIZE + 4] = [0; TBS_MAX_SIZE + 4];\n    result[0] = salt as Field;\n    result[1] = country_bytes[0] as Field;\n    result[2] = country_bytes[1] as Field;\n    result[3] = country_bytes[2] as Field;\n    for i in 0..TBS_MAX_SIZE {\n        result[4 + i] = tbs[i] as Field;\n    }\n    Poseidon2::hash(result, TBS_MAX_SIZE + 4)\n}\n\npub fn hash_salt_dg1_private_nullifier<let N: u32>(\n    salt: Field,\n    dg1: [u8; N],\n    private_nullifier: Field,\n) -> Field {\n    let mut result: [Field; N + 2] = [0; N + 2];\n    result[0] = salt as Field;\n    for i in 0..N {\n        result[1 + i] = dg1[i] as Field;\n    }\n    result[1 + N] = private_nullifier;\n    Poseidon2::hash(result, N + 2)\n}\n\npub fn calculate_private_nullifier<let DG1: u32, let SIG: u32>(\n    dg1: [u8; DG1],\n    sod_sig: [u8; SIG],\n) -> Field {\n    let mut result: [Field; DG1 + SIG] = [0; DG1 + SIG];\n    for i in 0..DG1 {\n        result[i] = dg1[i] as Field;\n    }\n    for i in 0..SIG {\n        result[DG1 + i] = sod_sig[i] as Field;\n    }\n    Poseidon2::hash(result, DG1 + SIG)\n}\n\npub fn hash_salt_country_signed_attr_dg1_private_nullifier<let SA: u32>(\n    salt: Field,\n    country: str<3>,\n    signed_attr: [u8; SA],\n    signed_attr_size: Field,\n    dg1: [u8; 95],\n    private_nullifier: Field,\n) -> Field {\n    let country_bytes: [u8; 3] = country.as_bytes();\n    let mut result: [Field; SA + 101] = [0; SA + 101];\n    result[0] = salt as Field;\n    result[1] = country_bytes[0] as Field;\n    result[2] = country_bytes[1] as Field;\n    result[3] = country_bytes[2] as Field;\n    for i in 0..SA {\n        result[4 + i] = signed_attr[i] as Field;\n    }\n    result[4 + SA] = signed_attr_size;\n    for i in 0..95 {\n        result[4 + SA + 1 + i] = dg1[i] as Field;\n    }\n    result[4 + SA + 1 + 95] = private_nullifier;\n    Poseidon2::hash(result, SA + 101)\n}\n","path":"/Users/madztheo/Documents/Wagmi/Studio/RnD/Docaproof/Circuits/zk_id_check_circuits/src/noir/lib/commitment/common/src/lib.nr"},"65":{"source":"/**\n* The standards for passports and any other travel documents, electronic or not,\n* are defined in the ICAO (International Civil Aviation Organization) 9303 document available here:\n* https://www.icao.int/publications/pages/publication.aspx?docnum=9303\n*/\n\n/**\n* The structure of the MRZ is well defined and standardized by the ICAO\n* so the index will always be the same for every passport\n* c.f. ICAO 9303-4, Appendix B\n*/\n\n// The following constants define the indices of the information\n// we need to generate various proofs of identity from the MRZ\n// The structure of the MRZ is slightly different between passports\n// and ID cards so we need to define indices for both types\n\n// Index for the country of issuance of the passport\npub global PASSPORT_MRZ_COUNTRY_INDEX: u32 = 2;\n// Index for the three letter code of the country of citizenship\n// Note that the first three letter code (index 2) in the MRZ is the country of issuance\n// not citizenship. It is important to keep in mind for residence permits\n// where the issuing country differs from the citizenship country\npub global PASSPORT_MRZ_NATIONALITY_INDEX: u32 = 54;\n// Index for the gender of the passport holder (M, F or < if unspecified)\npub global PASSPORT_MRZ_GENDER_INDEX: u32 = 64;\n// Index for the date of expiry (YYMMDD)\npub global PASSPORT_MRZ_EXPIRY_DATE_INDEX: u32 = 65;\n// Index for the date of birth (YYMMDD) in TD1 (i.e. passport) MRZ\npub global PASSPORT_MRZ_BIRTHDATE_INDEX: u32 = 57;\n// Index for the document number in the MRZ\npub global PASSPORT_MRZ_DOCUMENT_NUMBER_INDEX: u32 = 44;\n// Index for the document type in the MRZ\npub global PASSPORT_MRZ_DOCUMENT_TYPE_INDEX: u32 = 0;\n// Index for the name of the passport holder\npub global PASSPORT_MRZ_NAME_INDEX: u32 = 5;\n// Length of the MRZ on a passport\npub global PASSPORT_MRZ_LENGTH: u32 = 88;\n\n// Index for the country of issuance of the ID card\npub global ID_CARD_MRZ_COUNTRY_INDEX: u32 = 2;\n// Note that the first three letter code (index 2) in the MRZ is the country of issuance\n// not citizenship. It is important to keep in mind for residence permits\n// where the issuing country differs from the citizenship country\npub global ID_CARD_MRZ_NATIONALITY_INDEX: u32 = 45;\n// Index for the gender of the passport holder (M, F or < if unspecified)\npub global ID_CARD_MRZ_GENDER_INDEX: u32 = 37;\n// Index for the date of expiry (YYMMDD)\npub global ID_CARD_MRZ_EXPIRY_DATE_INDEX: u32 = 38;\n// Index for the date of birth (YYMMDD) in TD3 (i.e. ID cards) MRZ\npub global ID_CARD_MRZ_BIRTHDATE_INDEX: u32 = 30;\n// Index for the document number in the MRZ\npub global ID_CARD_MRZ_DOCUMENT_NUMBER_INDEX: u32 = 5;\n// Index for the document type in the MRZ\npub global ID_CARD_MRZ_DOCUMENT_TYPE_INDEX: u32 = 0;\n// Index for the name of the passport holder\npub global ID_CARD_MRZ_NAME_INDEX: u32 = 60;\n// Length of the MRZ on an ID card\npub global ID_CARD_MRZ_LENGTH: u32 = 90;\n\n// ECDSA curves mapping\npub global ECDSA_CURVE_P256: u32 = 0;\npub global ECDSA_CURVE_P384: u32 = 1;\npub global ECDSA_CURVE_P521: u32 = 2;\npub global ECDSA_CURVE_BRAINPOOL_B256R1: u32 = 3;\npub global ECDSA_CURVE_BRAINPOOL_B256T1: u32 = 4;\npub global ECDSA_CURVE_BRAINPOOL_B384R1: u32 = 5;\npub global ECDSA_CURVE_BRAINPOOL_B384T1: u32 = 6;\npub global ECDSA_CURVE_BRAINPOOL_B512R1: u32 = 7;\npub global ECDSA_CURVE_BRAINPOOL_B512T1: u32 = 8;\n\npub struct IDData {\n    // Regroups the hashes of all the data groups plus some padding\n    // at the start and in between each data group hashes\n    pub e_content: [u8; 700],\n    pub e_content_size: u32,\n    // Where we can find e_content in the signed_attributes\n    // It varies from document to document according to the length\n    // of the padding at the start\n    pub dg1_offset_in_e_content: u32,\n    // Last 32 bytes: result of the hash of all the hashes of the data groups\n    // Rest of the bytes: information about the signature algorithm, date, etc.\n    pub signed_attributes: [u8; 200],\n    pub signed_attributes_size: u32,\n    // The DG1 contains the Machine Readable Zone (MRZ) of the document\n    // The two lines at the bottom of the passport data page\n    // or the three bottom lines on the rear of an ID card\n    // 95 bytes for passports, 93 bytes for ID cards\n    // Including 88 bytes of MRZ and 5 bytes of padding for passports\n    // and 90 bytes of MRZ and 5 bytes of padding for ID cards\n    pub dg1: [u8; 95],\n    // The signature over the data groups\n    pub sod_signature: [u8; 512],\n    pub sod_signature_size: u32,\n}\n\npub struct DSCData {\n    // The TBS certificate of the DSC\n    // TBS stands for To Be Signed\n    pub tbs_certificate: [u8; 1500],\n    pub tbs_certificate_size: u32,\n    // The public key of the DSC (up to 512 bytes to account for RSA-4096)\n    pub pubkey: [u8; 512],\n    // The actual size of the public key\n    pub pubkey_size: u32,\n    // The index of the public key in the TBS certificate\n    pub pubkey_index: u32,\n    // Data used to verify the signature\n    // Generated by the pre-compute function in Rust\n    // c.f. main.rs\n    pub pubkey_redc_param: [u8; 513],\n    // The signature over the TBS certificate\n    pub signature: [u8; 512],\n    pub signature_size: u32,\n    // The exponent of the public key\n    // Only useful for RSA, can be ignored for ECDSA\n    pub exponent: u32,\n}\n\npub struct CSCData {\n    // The public key of the CSC (up to 512 bytes to account for RSA-4096)\n    pub pubkey: [u8; 512],\n    // The actual size of the public key\n    pub pubkey_size: u32,\n    // Data used to verify the signature\n    // Generated by the pre-compute function in Rust\n    // c.f. main.rs\n    pub pubkey_redc_param: [u8; 513],\n    // Only useful for RSA, can be ignored for ECDSA\n    pub exponent: u32,\n}\n\npub struct DiscloseFlags {\n    pub issuing_country: bool,\n    pub nationality: bool,\n    pub document_type: bool,\n    pub document_number: bool,\n    pub date_of_expiry: bool,\n    pub date_of_birth: bool,\n    pub gender: bool,\n    pub name: bool,\n}\n\npub struct DisclosedData {\n    pub issuing_country: [u8; 3],\n    pub nationality: [u8; 3],\n    pub document_type: [u8; 2],\n    pub document_number: [u8; 9],\n    pub date_of_expiry: [u8; 6],\n    pub date_of_birth: [u8; 6],\n    pub name: [u8; 39],\n    pub gender: [u8; 1],\n}\n\npub fn get_array_slice<let N: u32, let M: u32>(arr: [u8; N], start: u32, end: u32) -> [u8; M] {\n    let mut slice = [0 as u8; M];\n    for i in start..end {\n        slice[i - start] = arr[i];\n    }\n    slice\n}\n\npub fn get_array_slice_constant<let N: u32, let M: u32>(arr: [u8; N]) -> [u8; M] {\n    let mut slice = [0 as u8; M];\n    for i in 0..M {\n        slice[i] = arr[i];\n    }\n    slice\n}\n\n// Reverse the bytes of an array so you can switch from\n// big endian to little endian order and vice versa\npub fn reverse_bytes_array<let N: u32>(arr: [u8; N]) -> [u8; N] {\n    let mut reversed_arr = [0 as u8; N];\n    for i in 0..N {\n        // Reverse\n        reversed_arr[i] = arr[N - 1 - i];\n    }\n    reversed_arr\n}\n\npub fn insert_into_array<let N: u32, let M: u32>(\n    mut arr: [u8; N],\n    sub_arr: [u8; M],\n    index: u32,\n) -> [u8; N] {\n    for i in index..index + M {\n        arr[i] = sub_arr[i - index];\n    }\n    arr\n}\n\npub fn dynamic_insert_into_array<let N: u32, let M: u32>(\n    mut arr: [u8; N],\n    sub_arr: [u8; M],\n    index: u32,\n    max_size: u32,\n) -> [u8; N] {\n    for i in index..index + max_size {\n        if i - index < M {\n            arr[i] = sub_arr[i - index];\n        }\n    }\n    arr\n}\n\npub fn is_id_card(dg1: [u8; 95]) -> bool {\n    // For passport, the last two bytes are 0\n    // since the real length is 93 for passports\n    // while it is 95 for ID cards\n    (dg1[93] != 0) & (dg1[94] != 0)\n}\n\npub fn from_byte_be_to_fields<let NBytes: u32, let N: u32>(x: [u8; NBytes]) -> [Field; N] {\n    let mut result = [0 as Field; N];\n\n    let mut limb: Field = 0;\n    let mut k = 0;\n    for _j in 0..(15 - (N * 15 - NBytes)) {\n        limb *= 256;\n        limb += x[k] as Field;\n        k += 1;\n    }\n    std::as_witness(limb);\n\n    result[N - 1] = limb;\n\n    for i in 1..N {\n        let mut limb: Field = 0;\n        for _j in 0..15 {\n            limb *= 256;\n            limb += x[k] as Field;\n            k += 1;\n        }\n        std::as_witness(limb);\n        result[N - i - 1] = limb;\n    }\n\n    result\n}\n\npub unconstrained fn __from_byte_be_to_fields<let NBytes: u32, let N: u32>(\n    x: [u8; NBytes],\n) -> [Field; N] {\n    from_byte_be_to_fields(x)\n}\n\npub fn get_mrz_from_dg1(dg1: [u8; 95]) -> [u8; 90] {\n    let mut mrz = [0 as u8; 90];\n    for i in 0..90 {\n        mrz[i] = dg1[i + 5];\n    }\n    mrz\n}\n\npub fn split_array<let N: u32>(array: [u8; N * 2]) -> ([u8; N], [u8; N]) {\n    let mut array_x = [0 as u8; N];\n    let mut array_y = [0 as u8; N];\n    for i in 0..N {\n        array_x[i] = array[i];\n        array_y[i] = array[i + N];\n    }\n    (array_x, array_y)\n}\n\npub fn concat_array<let N: u32>(array_x: [u8; N], array_y: [u8; N]) -> [u8; N * 2] {\n    let mut array = [0 as u8; N * 2];\n    for i in 0..N {\n        array[i] = array_x[i];\n        array[i + N] = array_y[i];\n    }\n    array\n}\n\npub fn check_zero_padding<let N: u32, T>(padded_array: [T; N], len: u32)\nwhere\n    T: Eq,\n    T: Default,\n{\n    for i in 0..N {\n        if i >= len {\n            assert_eq(padded_array[i], T::default());\n        }\n    }\n}\n\npub fn get_nationality_from_mrz(dg1: [u8; 95]) -> [u8; 3] {\n    let mrz = get_mrz_from_dg1(dg1);\n\n    let mut country_bytes: [u8; 3] = [0; 3];\n\n    if is_id_card(dg1) {\n        country_bytes = get_array_slice(\n            mrz,\n            ID_CARD_MRZ_NATIONALITY_INDEX,\n            ID_CARD_MRZ_NATIONALITY_INDEX + 3,\n        );\n    } else {\n        country_bytes = get_array_slice(\n            mrz,\n            PASSPORT_MRZ_NATIONALITY_INDEX,\n            PASSPORT_MRZ_NATIONALITY_INDEX + 3,\n        );\n    }\n\n    country_bytes\n}\n","path":"/Users/madztheo/Documents/Wagmi/Studio/RnD/Docaproof/Circuits/zk_id_check_circuits/src/noir/lib/utils/src/lib.nr"},"66":{"source":"use date::Date;\nuse utils::{\n    get_array_slice, get_mrz_from_dg1, ID_CARD_MRZ_BIRTHDATE_INDEX, ID_CARD_MRZ_EXPIRY_DATE_INDEX,\n    is_id_card, PASSPORT_MRZ_BIRTHDATE_INDEX, PASSPORT_MRZ_EXPIRY_DATE_INDEX,\n};\n\nfn get_date<let INDEX: u32>(dg1: [u8; 95], threshold_year_bytes: [u8; 8]) -> Date {\n    let mrz = get_mrz_from_dg1(dg1);\n\n    let date_bytes = get_array_slice(mrz, INDEX, INDEX + 6);\n\n    // Create a Date object from the date using the current date as\n    // the pivot year to differentiate between 20th and 21st centuries\n    // as the format is \"YYMMDD\"\n    Date::from_bytes_short_year(\n        date_bytes,\n        [threshold_year_bytes[2], threshold_year_bytes[3]],\n    )\n}\n\npub fn get_birthdate(dg1: [u8; 95], current_date: [u8; 8]) -> Date {\n    let mut birthdate = Date::new(1, 1, 1);\n\n    // Get the slice of the MRZ representing the birthdate\n    if is_id_card(dg1) {\n        birthdate = get_date::<ID_CARD_MRZ_BIRTHDATE_INDEX>(dg1, current_date);\n    } else {\n        birthdate = get_date::<PASSPORT_MRZ_BIRTHDATE_INDEX>(dg1, current_date);\n    }\n\n    birthdate\n}\n\npub fn get_expiry_date(dg1: [u8; 95], current_date: [u8; 8]) -> Date {\n    let mut expiry_date = Date::new(1, 1, 1);\n\n    // We base the threshold year for the expiry date on the current date plus 20 years\n    // As most documents will have a 10 year validity (and some maybe 15 years?)\n    // So with 20 years we should be safe\n    let threshold_year = Date::from_bytes_long_year(current_date).add_years(20);\n    let threshold_year_bytes = threshold_year.to_bytes();\n\n    // Get the slice of the MRZ representing the expiry date\n    if is_id_card(dg1) {\n        expiry_date = get_date::<ID_CARD_MRZ_EXPIRY_DATE_INDEX>(dg1, threshold_year_bytes);\n    } else {\n        expiry_date = get_date::<PASSPORT_MRZ_EXPIRY_DATE_INDEX>(dg1, threshold_year_bytes);\n    }\n\n    expiry_date\n}\n\npub fn compare_date(date_to_compare: Date, min_date_bytes: [u8; 8], max_date_bytes: [u8; 8]) {\n    assert((min_date_bytes != [49; 8]) | (max_date_bytes != [49; 8]));\n\n    let min_date = Date::from_bytes_long_year(min_date_bytes);\n    let max_date = Date::from_bytes_long_year(max_date_bytes);\n\n    if (min_date_bytes != [49; 8]) & (max_date_bytes == [49; 8]) {\n        // The minimum date is more likely to be inclusive, so we use gte\n        assert(date_to_compare.gte(min_date));\n    } else if (max_date_bytes != [49; 8]) & (min_date_bytes == [49; 8]) {\n        // The maximum date is more likely to be inclusive, so we use lte\n        assert(date_to_compare.lte(max_date));\n    } else {\n        assert(min_date.lte(max_date));\n\n        // Check if birthdate is within the range\n        assert(date_to_compare.gte(min_date));\n        assert(date_to_compare.lte(max_date));\n    }\n}\n","path":"/Users/madztheo/Documents/Wagmi/Studio/RnD/Docaproof/Circuits/zk_id_check_circuits/src/noir/lib/compare/date/src/lib.nr"},"67":{"source":"use dep::std::{field::bn254::assert_gt, println};\n\npub struct Date {\n    day: u8,\n    month: u8,\n    year: u32,\n}\n\nfn get_number_from_utf8_code(code: u8) -> u8 {\n    assert(code >= 48 & code <= 57);\n    code - 48\n}\n\nfn number_to_utf8_code(number: u8) -> u8 {\n    assert(number >= 0 & number <= 9);\n    number + 48\n}\n\nimpl Date {\n    pub fn new(year: u32, month: u8, day: u8) -> Self {\n        assert(month >= 1 & month <= 12);\n        assert(day >= 1 & day <= 31);\n        let date = Self { day: day, month: month, year: year };\n        assert(day <= date.get_days_in_month(month));\n        date\n    }\n\n    pub fn from_bytes_short_year(date: [u8; 6], threshold_year: [u8; 2]) -> Self {\n        let firstYearDigit = get_number_from_utf8_code(date[0]);\n        let secondYearDigit = get_number_from_utf8_code(date[1]);\n\n        let mut year: u32 = firstYearDigit as u32 * 10 + secondYearDigit as u32;\n\n        let firstMonthDigit = get_number_from_utf8_code(date[2]);\n        let secondMonthDigit = get_number_from_utf8_code(date[3]);\n\n        let month = firstMonthDigit * 10 + secondMonthDigit;\n\n        let firstDayDigit = get_number_from_utf8_code(date[4]);\n        let secondDayDigit = get_number_from_utf8_code(date[5]);\n\n        let day = firstDayDigit * 10 + secondDayDigit;\n\n        let currentYearFirstDigit = get_number_from_utf8_code(threshold_year[0]);\n        let currentYearSecondDigit = get_number_from_utf8_code(threshold_year[1]);\n\n        let mut currentYear: u32 =\n            currentYearFirstDigit as u32 * 10 + currentYearSecondDigit as u32;\n\n        // This way we have a smooth 100 years period according to a threshold year\n        // Taking the current year as threshold year (for birthdates for example)\n        // if the current year is 2023, then 24 will be interpreted as 1924\n        // while 22 will be interpreted as 2022\n        // A bit problematic for people over 100 years old\n        if year <= currentYear {\n            year += 2000;\n        } else {\n            year += 1900;\n        }\n\n        Self { day: day, month: month, year: year }\n    }\n\n    pub fn from_bytes_long_year(date: [u8; 8]) -> Self {\n        let firstYearDigit = get_number_from_utf8_code(date[0]);\n        let secondYearDigit = get_number_from_utf8_code(date[1]);\n        let thirdYearDigit = get_number_from_utf8_code(date[2]);\n        let fourthYearDigit = get_number_from_utf8_code(date[3]);\n\n        let year: u32 = firstYearDigit as u32 * 1000\n            + secondYearDigit as u32 * 100\n            + thirdYearDigit as u32 * 10\n            + fourthYearDigit as u32;\n\n        let firstMonthDigit = get_number_from_utf8_code(date[4]);\n        let secondMonthDigit = get_number_from_utf8_code(date[5]);\n\n        let month = firstMonthDigit * 10 + secondMonthDigit;\n\n        let firstDayDigit = get_number_from_utf8_code(date[6]);\n        let secondDayDigit = get_number_from_utf8_code(date[7]);\n\n        let day = firstDayDigit * 10 + secondDayDigit;\n\n        Self { day: day, month: month, year: year }\n    }\n\n    pub fn from_str_short_year(date: str<6>, threshold_year: str<2>) -> Self {\n        let date_bytes = date.as_bytes();\n        Date::from_bytes_short_year(date_bytes, threshold_year.as_bytes())\n    }\n\n    pub fn from_str_long_year(date: str<8>) -> Self {\n        let date_bytes = date.as_bytes();\n        Date::from_bytes_long_year(date_bytes)\n    }\n\n    pub fn get_duration_in_days(self: Self, other: Self, absolute: bool) -> i32 {\n        let totalDuration: i32 = self.get_duration_between_years(other) as i32\n            + self.get_duration_between_months(other) as i32\n            + (self.day as i32 - other.day as i32);\n\n        if (totalDuration < 0) & absolute {\n            -1 * totalDuration\n        }\n\n        totalDuration\n    }\n\n    pub fn gt(self: Self, other: Self) -> bool {\n        self.get_duration_in_days(other, false) > 0\n    }\n\n    pub fn lt(self: Self, other: Self) -> bool {\n        self.get_duration_in_days(other, false) < 0\n    }\n\n    pub fn eq(self: Self, other: Self) -> bool {\n        (self.day == other.day) & (self.month == other.month) & (self.year == other.year)\n    }\n\n    pub fn ne(self: Self, other: Self) -> bool {\n        !self.eq(other)\n    }\n\n    pub fn gte(self: Self, other: Self) -> bool {\n        self.get_duration_in_days(other, false) >= 0\n    }\n\n    pub fn lte(self: Self, other: Self) -> bool {\n        self.get_duration_in_days(other, false) <= 0\n    }\n\n    pub fn println(self: Self) {\n        let year = self.year;\n        let month = self.month;\n        let day = self.day;\n        // Let's write the date in the YYYY-MM-DD format\n        // since people don't agree on which format is best\n        // between MM/DD/YYYY and DD/MM/YYYY\n        if (month < 10) & (day < 10) {\n            println(f\"Date: {year}-0{month}-0{day}\");\n        } else if month < 10 {\n            println(f\"Date: {year}-0{month}-{day}\");\n        } else if day < 10 {\n            println(f\"Date: {year}-{month}-0{day}\");\n        } else {\n            println(f\"Date: {year}-{month}-{day}\");\n        }\n    }\n\n    pub fn to_bytes(self: Self) -> [u8; 8] {\n        let mut date: [u8; 8] = [0; 8];\n\n        let firstYearDigit = self.year / 1000;\n        let secondYearDigit = (self.year - firstYearDigit * 1000) / 100;\n        let thirdYearDigit = (self.year - firstYearDigit * 1000 - secondYearDigit * 100) / 10;\n        let fourthYearDigit =\n            self.year - firstYearDigit * 1000 - secondYearDigit * 100 - thirdYearDigit * 10;\n\n        date[0] = number_to_utf8_code(firstYearDigit as u8);\n        date[1] = number_to_utf8_code(secondYearDigit as u8);\n        date[2] = number_to_utf8_code(thirdYearDigit as u8);\n        date[3] = number_to_utf8_code(fourthYearDigit as u8);\n\n        let firstMonthDigit = self.month / 10;\n        let secondMonthDigit = self.month - firstMonthDigit * 10;\n\n        date[4] = number_to_utf8_code(firstMonthDigit as u8);\n        date[5] = number_to_utf8_code(secondMonthDigit as u8);\n\n        let firstDayDigit = self.day / 10;\n        let secondDayDigit = self.day - firstDayDigit * 10;\n\n        date[6] = number_to_utf8_code(firstDayDigit as u8);\n        date[7] = number_to_utf8_code(secondDayDigit as u8);\n\n        date\n    }\n\n    pub fn is_leap_year(self: Self) -> bool {\n        self.year % 4 == 0\n    }\n\n    pub fn get_days_in_month(self: Self, month: u8) -> u8 {\n        assert(month >= 1 & month <= 12);\n        if month == 2 {\n            if self.is_leap_year() {\n                29\n            } else {\n                28\n            }\n        } else {\n            if (month == 1)\n                | (month == 3)\n                | (month == 5)\n                | (month == 7)\n                | (month == 8)\n                | (month == 10)\n                | (month == 12) {\n                31\n            } else {\n                30\n            }\n        }\n    }\n\n    pub fn get_duration_between_months(self: Self, other: Self) -> i32 {\n        assert(self.month >= 1 & self.month <= 12);\n        assert(other.month >= 1 & other.month <= 12);\n        let mut duration: i32 = 0;\n        if (self.month < other.month) {\n            for month in 1..13 {\n                if month >= self.month & month < other.month {\n                    duration -= other.get_days_in_month(month) as i32;\n                }\n            }\n        } else {\n            for month in 1..13 {\n                if month >= other.month & month < self.month {\n                    duration += self.get_days_in_month(month) as i32;\n                }\n            }\n        }\n        duration\n    }\n\n    pub fn get_duration_between_years(self: Self, other: Self) -> i32 {\n        let mut duration: i32 = 0;\n        if (self.year < other.year) {\n            let previous_leap_year: u32 = other.year - (other.year % 4);\n            let mut leap_year_count: u32 = 0;\n            if self.year <= previous_leap_year {\n                leap_year_count = (previous_leap_year - self.year) / 4 + 1;\n            }\n            duration -= leap_year_count as i32 * 366;\n            duration -=\n                (other.year as i32 - self.year as i32 - leap_year_count as i32) as i32 * 365;\n        } else if (self.year > other.year) {\n            let next_leap_year: u32 = other.year + (4 - other.year % 4);\n            let mut leap_year_count: u32 = 0;\n            if self.year > next_leap_year {\n                // Fixes a weird bug where the line below triggers a fail constraint\n                // while self.year is greater than next_leap_year\n                assert_gt(self.year as Field, next_leap_year as Field);\n                leap_year_count = ((self.year - 1) - next_leap_year) / 4 + 1;\n            }\n            duration += leap_year_count as i32 * 366;\n            duration +=\n                (self.year as i32 - other.year as i32 - leap_year_count as i32) as i32 * 365;\n        }\n        duration\n    }\n\n    pub fn add_years(self: Self, years: u32) -> Self {\n        Self { day: self.day, month: self.month, year: self.year + years }\n    }\n\n    pub fn sub_years(self: Self, years: u32) -> Self {\n        Self { day: self.day, month: self.month, year: self.year - years }\n    }\n\n    pub fn add_months(self: Self, months: u32) -> Self {\n        let mut newMonth = self.month as u32 + months;\n        let mut newYear = self.year;\n        let yearToAdd = (newMonth - 1) / 12;\n        if newMonth > 12 {\n            newYear += yearToAdd as u32;\n            newMonth -= 12 * yearToAdd;\n        }\n        Self { day: self.day, month: newMonth as u8, year: newYear }\n    }\n\n    pub fn sub_months(self: Self, months: u32) -> Self {\n        let mut newMonth = self.month as i32 - months as i32;\n        let mut newYear = self.year;\n        if newMonth < 1 {\n            let yearToSub = ((newMonth as i32 - 12 as i32) * -1) / 12;\n            newYear -= yearToSub as u32;\n            newMonth += 12 * yearToSub;\n        }\n        Self { day: self.day, month: newMonth as u8, year: newYear }\n    }\n\n    pub fn add_days(self: Self, days: u32) -> Self {\n        let mut newDay = self.day as u32 + days;\n        let mut newMonth = self.month as u32;\n        let mut newYear = self.year;\n        let mut date = Self { day: newDay as u8, month: newMonth as u8, year: newYear };\n        if newDay > self.get_days_in_month(self.month) as u32 {\n            let max_months = (newDay / 30) + 1;\n            let bound = self.month + max_months as u8;\n            for _ in self.month..bound {\n                let days_in_month = date.get_days_in_month(newMonth as u8) as u32;\n                if newDay > days_in_month {\n                    newDay -= days_in_month;\n                    newMonth += 1;\n                    if newMonth > 12 {\n                        newYear += 1;\n                        newMonth = 1;\n                    }\n                    // We need to mutate the date object inside the loop\n                    // so we can use get_days_in_month properly\n                    date.day = newDay as u8;\n                    date.year = newYear;\n                    date.month = newMonth as u8;\n                }\n            }\n        }\n        date\n    }\n\n    // Performance could be improved\n    pub fn sub_days(self: Self, days: u32) -> Self {\n        let mut newDay = self.day as i32 - days as i32;\n        let mut newMonth = self.month as i32;\n        let mut newYear = self.year;\n        let mut date = Self { day: newDay as u8, month: newMonth as u8, year: newYear };\n        if newDay < 1 {\n            let max_months = (self.day as u32 + days) / 30 + 1;\n            let bound = self.month + max_months as u8;\n            for _ in self.month..bound {\n                let days_in_month = date.get_days_in_month(newMonth as u8) as i32;\n                if newDay < 1 {\n                    newDay += days_in_month;\n                    newMonth -= 1;\n                    if newMonth < 1 {\n                        newYear -= 1;\n                        newMonth = 12;\n                    }\n                    // We need to mutate the date object inside the loop\n                    // so we can use get_days_in_month properly\n                    date.day = newDay as u8;\n                    date.year = newYear;\n                    date.month = newMonth as u8;\n                }\n            }\n        }\n        date\n    }\n}\n\n#[test]\nfn test_date_init() {\n    let date = Date::new(2023, 12, 19);\n\n    assert(date.day == 19);\n    assert(date.month == 12);\n    assert(date.year == 2023);\n}\n\n#[test]\nfn test_date_from_bytes_short_year() {\n    let date = Date::from_bytes_short_year([50, 51, 49, 50, 49, 57], [50, 52]);\n\n    assert(date.day == 19);\n    assert(date.month == 12);\n    assert(date.year == 2023);\n}\n\n#[test]\nfn test_date_from_bytes_long_year() {\n    let date = Date::from_bytes_long_year([50, 48, 50, 51, 49, 50, 49, 57]);\n\n    assert(date.day == 19);\n    assert(date.month == 12);\n    assert(date.year == 2023);\n}\n\n#[test]\nfn test_date_from_str_short_year() {\n    let date = Date::from_str_short_year(\"231219\", \"24\");\n\n    assert(date.day == 19);\n    assert(date.month == 12);\n    assert(date.year == 2023);\n}\n\n#[test]\nfn test_date_from_str_long_year() {\n    let date = Date::from_str_long_year(\"20231219\");\n\n    assert(date.day == 19);\n    assert(date.month == 12);\n    assert(date.year == 2023);\n}\n\n#[test]\nfn test_date_to_bytes() {\n    let date = Date::new(2023, 12, 19);\n\n    let date_bytes = date.to_bytes();\n\n    assert(date_bytes[0] == 50);\n    assert(date_bytes[1] == 48);\n    assert(date_bytes[2] == 50);\n    assert(date_bytes[3] == 51);\n    assert(date_bytes[4] == 49);\n    assert(date_bytes[5] == 50);\n    assert(date_bytes[6] == 49);\n    assert(date_bytes[7] == 57);\n}\n\n#[test]\nfn test_date_is_leap_year() {\n    let date = Date::new(2023, 12, 19);\n\n    assert(date.is_leap_year() == false);\n\n    let date = Date::new(2024, 12, 19);\n\n    assert(date.is_leap_year() == true);\n}\n\n#[test]\nfn test_date_get_days_in_month() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(date.get_days_in_month(1) == 31);\n    assert(date.get_days_in_month(2) == 28);\n    assert(date.get_days_in_month(3) == 31);\n    assert(date.get_days_in_month(4) == 30);\n    assert(date.get_days_in_month(5) == 31);\n    assert(date.get_days_in_month(6) == 30);\n    assert(date.get_days_in_month(7) == 31);\n    assert(date.get_days_in_month(8) == 31);\n    assert(date.get_days_in_month(9) == 30);\n    assert(date.get_days_in_month(10) == 31);\n    assert(date.get_days_in_month(11) == 30);\n    assert(date.get_days_in_month(12) == 31);\n\n    let date = Date::new(2024, 1, 1);\n\n    assert(date.get_days_in_month(1) == 31);\n    assert(date.get_days_in_month(2) == 29);\n    assert(date.get_days_in_month(3) == 31);\n    assert(date.get_days_in_month(4) == 30);\n    assert(date.get_days_in_month(5) == 31);\n    assert(date.get_days_in_month(6) == 30);\n    assert(date.get_days_in_month(7) == 31);\n    assert(date.get_days_in_month(8) == 31);\n    assert(date.get_days_in_month(9) == 30);\n    assert(date.get_days_in_month(10) == 31);\n    assert(date.get_days_in_month(11) == 30);\n    assert(date.get_days_in_month(12) == 31);\n}\n\n#[test]\nfn test_date_get_duration_between_months() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(Date::new(2023, 1, 1).get_duration_between_months(date) == 0);\n    assert(Date::new(2023, 2, 1).get_duration_between_months(date) == 31);\n    assert(Date::new(2023, 3, 1).get_duration_between_months(date) == 59);\n    assert(Date::new(2023, 4, 1).get_duration_between_months(date) == 90);\n    assert(Date::new(2023, 5, 1).get_duration_between_months(date) == 120);\n    assert(Date::new(2023, 6, 1).get_duration_between_months(date) == 151);\n    assert(Date::new(2023, 7, 1).get_duration_between_months(date) == 181);\n    assert(Date::new(2023, 8, 1).get_duration_between_months(date) == 212);\n    assert(Date::new(2023, 9, 1).get_duration_between_months(date) == 243);\n    assert(Date::new(2023, 10, 1).get_duration_between_months(date) == 273);\n    assert(Date::new(2023, 11, 1).get_duration_between_months(date) == 304);\n    assert(Date::new(2023, 12, 1).get_duration_between_months(date) == 334);\n}\n\n#[test]\nfn test_date_get_duration_between_years() {\n    let date = Date::new(2023, 1, 1);\n\n    // Positive duration\n    assert(Date::new(2023, 1, 1).get_duration_between_years(date) == 0);\n    assert(Date::new(2024, 1, 1).get_duration_between_years(date) == 365);\n    assert(Date::new(2025, 1, 1).get_duration_between_years(date) == 731);\n    assert(Date::new(2026, 1, 1).get_duration_between_years(date) == 1096);\n    assert(Date::new(2027, 1, 1).get_duration_between_years(date) == 1461);\n    assert(Date::new(2028, 1, 1).get_duration_between_years(date) == 1826);\n    assert(Date::new(2029, 1, 1).get_duration_between_years(date) == 2192);\n    assert(Date::new(2030, 1, 1).get_duration_between_years(date) == 2557);\n    assert(Date::new(2031, 1, 1).get_duration_between_years(date) == 2922);\n    assert(Date::new(2032, 1, 1).get_duration_between_years(date) == 3287);\n    assert(Date::new(2033, 1, 1).get_duration_between_years(date) == 3653);\n    assert(Date::new(2034, 1, 1).get_duration_between_years(date) == 4018);\n\n    // Negative duration\n    assert(Date::new(2022, 1, 1).get_duration_between_years(date) == -365);\n    assert(Date::new(2021, 1, 1).get_duration_between_years(date) == -730);\n    assert(Date::new(2020, 1, 1).get_duration_between_years(date) == -1096);\n    assert(Date::new(2019, 1, 1).get_duration_between_years(date) == -1461);\n    assert(Date::new(2018, 1, 1).get_duration_between_years(date) == -1826);\n    assert(Date::new(2017, 1, 1).get_duration_between_years(date) == -2191);\n    assert(Date::new(2016, 1, 1).get_duration_between_years(date) == -2557);\n    assert(Date::new(2015, 1, 1).get_duration_between_years(date) == -2922);\n    assert(Date::new(2014, 1, 1).get_duration_between_years(date) == -3287);\n    assert(Date::new(2013, 1, 1).get_duration_between_years(date) == -3652);\n    assert(Date::new(2012, 1, 1).get_duration_between_years(date) == -4018);\n}\n\n#[test]\nfn test_date_get_duration_in_days() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(Date::new(2023, 1, 1).get_duration_in_days(date, false) == 0);\n    assert(Date::new(2023, 1, 15).get_duration_in_days(date, false) == 14);\n    assert(Date::new(2023, 2, 1).get_duration_in_days(date, false) == 31);\n    assert(Date::new(2023, 2, 15).get_duration_in_days(date, false) == 45);\n    assert(Date::new(2023, 3, 1).get_duration_in_days(date, false) == 59);\n    assert(Date::new(2023, 12, 31).get_duration_in_days(date, false) == 364);\n    assert(Date::new(2024, 1, 1).get_duration_in_days(date, false) == 365);\n    assert(Date::new(2024, 12, 31).get_duration_in_days(date, false) == 365 + 365);\n    assert(Date::new(2025, 1, 1).get_duration_in_days(date, false) == 365 + 366);\n}\n\n#[test]\nfn test_date_eq() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(date.eq(Date::new(2023, 1, 1)));\n    assert(!date.eq(Date::new(2023, 1, 2)));\n}\n\n#[test]\nfn test_date_ne() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(!date.ne(Date::new(2023, 1, 1)));\n    assert(date.ne(Date::new(2023, 1, 2)));\n}\n\n#[test]\nfn test_date_gt() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(!date.gt(Date::new(2023, 1, 1)));\n    assert(!date.gt(Date::new(2023, 1, 2)));\n    assert(date.gt(Date::new(2022, 12, 31)));\n}\n\n#[test]\nfn test_date_lt() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(!date.lt(Date::new(2023, 1, 1)));\n    assert(!date.lt(Date::new(2022, 12, 31)));\n    assert(date.lt(Date::new(2023, 1, 2)));\n}\n\n#[test]\nfn test_date_gte() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(date.gte(Date::new(2023, 1, 1)));\n    assert(!date.gte(Date::new(2023, 1, 2)));\n    assert(date.gte(Date::new(2022, 12, 31)));\n}\n\n#[test]\nfn test_date_lte() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(date.lte(Date::new(2023, 1, 1)));\n    assert(!date.lte(Date::new(2022, 12, 31)));\n    assert(date.lte(Date::new(2023, 1, 2)));\n}\n\n#[test]\nfn test_date_add_years() {\n    let date = Date::new(2023, 7, 14);\n\n    assert(date.add_years(0).eq(Date::new(2023, 7, 14)));\n    assert(date.add_years(1).eq(Date::new(2024, 7, 14)));\n    assert(date.add_years(2).eq(Date::new(2025, 7, 14)));\n    assert(date.add_years(3).eq(Date::new(2026, 7, 14)));\n    assert(date.add_years(4).eq(Date::new(2027, 7, 14)));\n    assert(date.add_years(5).eq(Date::new(2028, 7, 14)));\n}\n\n#[test]\nfn test_date_sub_years() {\n    let date = Date::new(2023, 7, 14);\n\n    assert(date.sub_years(0).eq(Date::new(2023, 7, 14)));\n    assert(date.sub_years(1).eq(Date::new(2022, 7, 14)));\n    assert(date.sub_years(2).eq(Date::new(2021, 7, 14)));\n    assert(date.sub_years(3).eq(Date::new(2020, 7, 14)));\n    assert(date.sub_years(4).eq(Date::new(2019, 7, 14)));\n    assert(date.sub_years(5).eq(Date::new(2018, 7, 14)));\n}\n\n#[test]\nfn test_date_add_months() {\n    let date = Date::new(2023, 7, 14);\n\n    assert(date.add_months(0).eq(Date::new(2023, 7, 14)));\n    assert(date.add_months(1).eq(Date::new(2023, 8, 14)));\n    assert(date.add_months(2).eq(Date::new(2023, 9, 14)));\n\n    assert(date.add_months(6).eq(Date::new(2024, 1, 14)));\n    assert(date.add_months(7).eq(Date::new(2024, 2, 14)));\n    assert(date.add_months(8).eq(Date::new(2024, 3, 14)));\n\n    assert(date.add_months(17).eq(Date::new(2024, 12, 14)));\n    assert(date.add_months(18).eq(Date::new(2025, 1, 14)));\n\n    assert(date.add_months(29).eq(Date::new(2025, 12, 14)));\n    assert(date.add_months(30).eq(Date::new(2026, 1, 14)));\n}\n\n#[test]\nfn test_date_sub_months() {\n    let date = Date::new(2023, 7, 14);\n\n    assert(date.sub_months(0).eq(Date::new(2023, 7, 14)));\n    assert(date.sub_months(1).eq(Date::new(2023, 6, 14)));\n    assert(date.sub_months(2).eq(Date::new(2023, 5, 14)));\n\n    assert(date.sub_months(6).eq(Date::new(2023, 1, 14)));\n    assert(date.sub_months(7).eq(Date::new(2022, 12, 14)));\n    assert(date.sub_months(8).eq(Date::new(2022, 11, 14)));\n\n    assert(date.sub_months(17).eq(Date::new(2022, 2, 14)));\n    assert(date.sub_months(18).eq(Date::new(2022, 1, 14)));\n    assert(date.sub_months(19).eq(Date::new(2021, 12, 14)));\n\n    assert(date.sub_months(30).eq(Date::new(2021, 1, 14)));\n    assert(date.sub_months(31).eq(Date::new(2020, 12, 14)));\n\n    assert(date.sub_months(41).eq(Date::new(2020, 2, 14)));\n    assert(date.sub_months(42).eq(Date::new(2020, 1, 14)));\n    assert(date.sub_months(43).eq(Date::new(2019, 12, 14)));\n}\n\n#[test]\nfn test_date_add_days() {\n    let date = Date::new(2023, 7, 14);\n\n    assert(date.add_days(0).eq(Date::new(2023, 7, 14)));\n    assert(date.add_days(1).eq(Date::new(2023, 7, 15)));\n    assert(date.add_days(2).eq(Date::new(2023, 7, 16)));\n\n    assert(date.add_days(17).eq(Date::new(2023, 7, 31)));\n    assert(date.add_days(18).eq(Date::new(2023, 8, 1)));\n    assert(date.add_days(19).eq(Date::new(2023, 8, 2)));\n\n    assert(date.add_days(31).eq(Date::new(2023, 8, 14)));\n    assert(date.add_days(32).eq(Date::new(2023, 8, 15)));\n    assert(date.add_days(33).eq(Date::new(2023, 8, 16)));\n\n    assert(date.add_days(365).eq(Date::new(2024, 7, 13)));\n    assert(date.add_days(366).eq(Date::new(2024, 7, 14)));\n    assert(date.add_days(367).eq(Date::new(2024, 7, 15)));\n\n    assert(date.add_days(365 + 365).eq(Date::new(2025, 7, 13)));\n    assert(date.add_days(365 + 366).eq(Date::new(2025, 7, 14)));\n    assert(date.add_days(365 + 367).eq(Date::new(2025, 7, 15)));\n\n    assert(date.add_days(365 + 366 + 364).eq(Date::new(2026, 7, 13)));\n    assert(date.add_days(365 + 366 + 365).eq(Date::new(2026, 7, 14)));\n    assert(date.add_days(365 + 366 + 366).eq(Date::new(2026, 7, 15)));\n\n    // After 4 regular years and 2 leap years\n    assert(date.add_days(365 * 4 + 366 * 2 - 1).eq(Date::new(2029, 7, 13)));\n    assert(date.add_days(365 * 4 + 366 * 2).eq(Date::new(2029, 7, 14)));\n    assert(date.add_days(365 * 4 + 366 * 2 + 1).eq(Date::new(2029, 7, 15)));\n}\n\n#[test]\nfn test_date_sub_days() {\n    let date = Date::new(2023, 7, 14);\n\n    assert(date.sub_days(0).eq(Date::new(2023, 7, 14)));\n    assert(date.sub_days(1).eq(Date::new(2023, 7, 13)));\n    assert(date.sub_days(2).eq(Date::new(2023, 7, 12)));\n\n    assert(date.sub_days(17).eq(Date::new(2023, 6, 28)));\n    assert(date.sub_days(18).eq(Date::new(2023, 6, 27)));\n    assert(date.sub_days(19).eq(Date::new(2023, 6, 26)));\n\n    assert(date.sub_days(31).eq(Date::new(2023, 6, 14)));\n    assert(date.sub_days(32).eq(Date::new(2023, 6, 13)));\n    assert(date.sub_days(33).eq(Date::new(2023, 6, 12)));\n\n    assert(date.sub_days(365).eq(Date::new(2022, 7, 14)));\n    assert(date.sub_days(366).eq(Date::new(2022, 7, 13)));\n    assert(date.sub_days(367).eq(Date::new(2022, 7, 12)));\n\n    assert(date.sub_days(365 + 365).eq(Date::new(2021, 7, 14)));\n    assert(date.sub_days(365 + 366).eq(Date::new(2021, 7, 13)));\n    assert(date.sub_days(365 + 367).eq(Date::new(2021, 7, 12)));\n\n    assert(date.sub_days(365 + 365 + 365).eq(Date::new(2020, 7, 14)));\n    assert(date.sub_days(365 + 365 + 366).eq(Date::new(2020, 7, 13)));\n    assert(date.sub_days(365 + 365 + 367).eq(Date::new(2020, 7, 12)));\n\n    // After 5 regular years and 1 leap year\n    assert(date.sub_days(365 * 5 + 366 - 1).eq(Date::new(2017, 7, 15)));\n    assert(date.sub_days(365 * 5 + 366).eq(Date::new(2017, 7, 14)));\n    assert(date.sub_days(365 * 5 + 366 + 1).eq(Date::new(2017, 7, 13)));\n\n    // After 6 regular years and 2 leap years\n    assert(date.sub_days(365 * 6 + 366 * 2 - 1).eq(Date::new(2015, 7, 15)));\n    assert(date.sub_days(365 * 6 + 366 * 2).eq(Date::new(2015, 7, 14)));\n    assert(date.sub_days(365 * 6 + 366 * 2 + 1).eq(Date::new(2015, 7, 13)));\n}\n\n#[test]\nfn test_date_age() {\n    let birthdate = Date::new(1995, 4, 13);\n\n    // Add 18 years to the birthdate\n    // to get the date when the person is 18 years old\n    let majority_date = birthdate.add_years(18);\n\n    // Make sure the majority date is correct\n    assert(majority_date.eq(Date::new(2013, 4, 13)));\n\n    // Compare the majority date to the current date\n    // to see if the person is 18 years old\n    assert(majority_date.lte(Date::new(2023, 12, 20)));\n}\n","path":"/Users/madztheo/nargo/github.com/madztheo/noir-date.git/0.4.3/src/lib.nr"}},"names":["main"],"brillig_names":["decompose_hint","lte_hint","directive_integer_quotient","directive_invert"]}