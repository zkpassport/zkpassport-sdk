{"noir_version":"1.0.0-beta.1+03b58fa2dfcc8acc8cf5198b1b23b55676fbdb02","hash":822175390910424952,"abi":{"parameters":[{"name":"comm_in","type":{"kind":"field"},"visibility":"public"},{"name":"salt","type":{"kind":"field"},"visibility":"private"},{"name":"private_nullifier","type":{"kind":"field"},"visibility":"private"},{"name":"dg1","type":{"kind":"array","length":95,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"country_list","type":{"kind":"array","length":200,"type":{"kind":"integer","sign":"unsigned","width":32}},"visibility":"public"},{"name":"service_scope","type":{"kind":"field"},"visibility":"public"},{"name":"service_subscope","type":{"kind":"field"},"visibility":"public"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"7Z3dTuNIEIXfJde56K6u/uNVVqtRgMwoUpSgEFZaId59bCY2Ec4EWYceTc2cG4Sh+qT4bHflEwI/L+7Xt0/fvmx2X/ePi5t/nhfb/d3quNnvuqPnhdT0+sXHh9WuP348rg7HxU32YblY7+67z2J8WS6+brbrxU2Sl+Wk1DufT7XeaXorTheKqwY5FVfV/FYcLxTnJGMXKcTz4n+XXefZbOfFbOf1N+5c3dh5lHedB+fMdu7Ndi6/tPMQ49B5yOl65yWGdCouUdOk82C2czXbeTTbeTLbeTbbeTHbebXauXdmO/dmOzc7Q73ZGerNzlBvdoZ6szPUm52h3uwM9WZnqJidoWJ2horZGSpmZ6iYnaFidoaK2RkqZmeomJ2hYnaGBrMzNJidocHsDA1mZ2gwO0OD2RkazM7QgM/QXIfOfZLzzl/zS+P8+on54tz7fHWN8+G9PeQy5KukSb40zof3yZiGWh+Ln+Rr4/zYOB/eGVIZ87OfXj+5cX75zHwpk/zaNj+6xvm+cb40zofv35LG/aGUOMnXxvnw/VvGYdrlT/a3mBrn50/Mr04n+aVxfm2bn1zjfPT+7Wb68P5KXAiTfGmcHxrn62fmx8l8TLFxfmqcnxvnl8b56P0r3g/7s3iZXD/54v3bbaunNSpvbznkkuyI1OH9s3S/175e7Lvf8Qw3e6ceHxQ7SaNz5Xi9OOfBz6r3H+w4vrjxHb+eFYeL+PJ4esSdjQf9gc8TH4JPiA/BF4gPwafEh+CLxIfgS8SH4MvEh+ArxIfgq8QH4Cu0DggfrQPCR+uA8NE6IHxKfAg+WgeEj9YB4aN1QPhoHRA+WgeCr9I6IHy0DggfrQPCR+uA8CnxIfhoHRA+WgeEj9YB4aN1QPhoHQA+dbQOCB+tA8JH64Dw0TogfEp8CD5aB4SP1gHho3VA+GgdED5aB4LP0zogfLQOCB+tA8JH64DwKfEh+GgdED5aB4SP1gHho3VA+GgdCD6hdUD4aB0QPloHhI/WAeFT4kPw0TogfLQOCB+tA8JH64Dw0ToQfIHWAeGjdUD4aB0QPloHhE+JD8FH64Dw0TogfLQOCB+tA8JH60DwKa0DwkfrgPDROiB8tA4InxIfgo/WAeGjdUD4aB0QPloHhI/WgeCLtA4IH60DwkfrgPDROiB8SnwIPloHhI/WAeGjdUD4aB0QPloHgi/ROiB8tA4IH60DwkfrgPAp8SH4aB0QPloHhI/WAeGjdUD4aB0IPj6bHMNH64Dw0TogfLQOCJ8SH4KP1gHho3VA+GgdED5aB4SP1oHg47PJMXy0DggfrQPCR+uA8CnxIfhoHRA+WgeEj9YB4aN1QPhoHQg+Ppscw0frgPDROiB8tA4InxIfgo/WAeGDrSOPP6Rk/aDY5xKGzouTPwBfJj4E30XrmNVMqj9p5jW//n2nJ/gy7lA1XT89QfypNtTw7uRE/NHdfyu87uD2sNluN9++bPd3q+Nmv3vsF7r+g1z+50Ve4/DKevbCqT8VcvmfVvg03ohZJ0vK/CV19pLLf5B/fYmfv0TmLwnzl+gHS4pMlpT5S+rsJcnNX+LnLXnpjv5bHTar2+26v1T7bz7t7oYrtzs8/v8wfGe4th8O+7v1/dNh3V/lbxd4T14kLiXErpXXR3FK0qWk2h/2jUkOS8mxe9Xulb8D","file_map":{"26":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"62":{"source":"use commitment::nullify;\nuse exclusion_check_country::check_country_exclusion;\n\nfn main(\n    comm_in: pub Field,\n    salt: Field,\n    private_nullifier: Field,\n    dg1: [u8; 95],\n    // There are roughly 200 countries in the world\n    // so we can safely pad it to 200\n    // The list must be sorted in ascending order\n    // For efficieny, no sorting is done in the circuit\n    // since the fact that the list is already sorted can checked\n    // by any verifier passing the public inputs to verify the proof\n    country_list: pub [u32; 200],\n    service_scope: pub Field,\n    service_subscope: pub Field,\n) -> pub Field {\n    // Check that nationality of the passport holder is not in the list of countries\n    check_country_exclusion(dg1, country_list);\n    let nullifier = nullify(\n        comm_in,\n        salt,\n        dg1,\n        private_nullifier,\n        service_scope,\n        service_subscope,\n    );\n    nullifier\n}\n","path":"/Users/madztheo/Documents/Wagmi/Studio/RnD/Docaproof/Circuits/zk_id_check_circuits/src/noir/bin/exclusion-check/country/src/main.nr"},"63":{"source":"use common::{calculate_scoped_nullifier, hash_salt_dg1_private_nullifier};\n\n/*\n############################################################\n# Circuit D\n############################################################\n# Generates a scoped nullifier that is scoped by service\n# Allows selective disclosure of dg1 via a reveal bitmask\n############################################################\n\n# Inputs/Outputs\n############################################################\ncomm_in             `assert comm_in == H(salt, dg1, private_nullifier)`\nsalt\ndg1\nprivate_nullifier\nservice_scope       `H(<domain_name>)`\nservice_subscope    `H(<purpose>)` (Service-specific subscope)\nscoped_nullifier    `H(private_nullifier, service_scope, service_subscope)`\n\n# Checks\n############################################################\n- Checks that dg1_reveal is the correct reveal of dg1 for the given dg1_mask\n- Constrains scoped_nullifier to be `H(private_nullifier, service_scope, service_subscope)`\n*/\npub fn nullify(\n    comm_in: Field,\n    salt: Field,\n    dg1: [u8; 95],\n    private_nullifier: Field,\n    service_scope: Field,\n    service_subscope: Field,\n) -> Field {\n    assert(comm_in == hash_salt_dg1_private_nullifier(salt, dg1, private_nullifier));\n    // println(f\"comm_in: {comm_in}\");\n    let scoped_nullifier =\n        calculate_scoped_nullifier(private_nullifier, service_scope, service_subscope);\n    // println(f\"scoped_nullifier: {scoped_nullifier}\");\n    scoped_nullifier\n}\n\n","path":"/Users/madztheo/Documents/Wagmi/Studio/RnD/Docaproof/Circuits/zk_id_check_circuits/src/noir/lib/commitment/scoped-nullifier/src/lib.nr"},"64":{"source":"//use std::hash::pedersen_hash;\nuse std::hash::poseidon2::Poseidon2;\nuse utils::PASSPORT_MRZ_COUNTRY_INDEX;\n\npub global CSC_CERT_TYPE: Field = 1;\npub global DSC_CERT_TYPE: Field = 2;\n\npub fn calculate_scoped_nullifier(\n    private_nullifier: Field,\n    service_scope: Field,\n    service_subscope: Field,\n) -> Field {\n    Poseidon2::hash([private_nullifier, service_scope, service_subscope], 3)\n}\n\npub fn calculate_certificate_registry_leaf<let N: u32>(\n    registry_id: Field,\n    cert_type: Field,\n    country: str<3>,\n    csc_pubkey: [u8; N],\n) -> Field {\n    let country_bytes: [u8; 3] = country.as_bytes();\n    let mut result: [Field; N + 5] = [0; N + 5];\n    result[0] = registry_id as Field;\n    result[1] = cert_type as Field;\n    result[2] = country_bytes[0] as Field;\n    result[3] = country_bytes[1] as Field;\n    result[4] = country_bytes[2] as Field;\n    for i in 0..N {\n        result[i + 5] = csc_pubkey[i] as Field;\n    }\n    Poseidon2::hash(result, N + 5)\n}\n\npub fn get_country_from_dg1(dg1: [u8; 95]) -> str<3> {\n    // There 5 padding bytes in the dg1 before the actual MRZ\n    let country_offset = 5 + PASSPORT_MRZ_COUNTRY_INDEX;\n    let mut country_bytes: [u8; 3] = [0; 3];\n    for i in 0..3 {\n        country_bytes[i] = dg1[country_offset + i];\n    }\n    country_bytes.as_str_unchecked()\n}\n\npub fn hash_salt_country_tbs<let TBS_MAX_SIZE: u32>(\n    salt: Field,\n    country: str<3>,\n    tbs: [u8; TBS_MAX_SIZE],\n) -> Field {\n    let country_bytes: [u8; 3] = country.as_bytes();\n    let mut result: [Field; TBS_MAX_SIZE + 4] = [0; TBS_MAX_SIZE + 4];\n    result[0] = salt as Field;\n    result[1] = country_bytes[0] as Field;\n    result[2] = country_bytes[1] as Field;\n    result[3] = country_bytes[2] as Field;\n    for i in 0..TBS_MAX_SIZE {\n        result[4 + i] = tbs[i] as Field;\n    }\n    Poseidon2::hash(result, TBS_MAX_SIZE + 4)\n}\n\npub fn hash_salt_dg1_private_nullifier<let N: u32>(\n    salt: Field,\n    dg1: [u8; N],\n    private_nullifier: Field,\n) -> Field {\n    let mut result: [Field; N + 2] = [0; N + 2];\n    result[0] = salt as Field;\n    for i in 0..N {\n        result[1 + i] = dg1[i] as Field;\n    }\n    result[1 + N] = private_nullifier;\n    Poseidon2::hash(result, N + 2)\n}\n\npub fn calculate_private_nullifier<let DG1: u32, let SIG: u32>(\n    dg1: [u8; DG1],\n    sod_sig: [u8; SIG],\n) -> Field {\n    let mut result: [Field; DG1 + SIG] = [0; DG1 + SIG];\n    for i in 0..DG1 {\n        result[i] = dg1[i] as Field;\n    }\n    for i in 0..SIG {\n        result[DG1 + i] = sod_sig[i] as Field;\n    }\n    Poseidon2::hash(result, DG1 + SIG)\n}\n\npub fn hash_salt_country_signed_attr_dg1_private_nullifier<let SA: u32>(\n    salt: Field,\n    country: str<3>,\n    signed_attr: [u8; SA],\n    signed_attr_size: Field,\n    dg1: [u8; 95],\n    private_nullifier: Field,\n) -> Field {\n    let country_bytes: [u8; 3] = country.as_bytes();\n    let mut result: [Field; SA + 101] = [0; SA + 101];\n    result[0] = salt as Field;\n    result[1] = country_bytes[0] as Field;\n    result[2] = country_bytes[1] as Field;\n    result[3] = country_bytes[2] as Field;\n    for i in 0..SA {\n        result[4 + i] = signed_attr[i] as Field;\n    }\n    result[4 + SA] = signed_attr_size;\n    for i in 0..95 {\n        result[4 + SA + 1 + i] = dg1[i] as Field;\n    }\n    result[4 + SA + 1 + 95] = private_nullifier;\n    Poseidon2::hash(result, SA + 101)\n}\n","path":"/Users/madztheo/Documents/Wagmi/Studio/RnD/Docaproof/Circuits/zk_id_check_circuits/src/noir/lib/commitment/common/src/lib.nr"},"65":{"source":"/**\n* The standards for passports and any other travel documents, electronic or not,\n* are defined in the ICAO (International Civil Aviation Organization) 9303 document available here:\n* https://www.icao.int/publications/pages/publication.aspx?docnum=9303\n*/\n\n/**\n* The structure of the MRZ is well defined and standardized by the ICAO\n* so the index will always be the same for every passport\n* c.f. ICAO 9303-4, Appendix B\n*/\n\n// The following constants define the indices of the information\n// we need to generate various proofs of identity from the MRZ\n// The structure of the MRZ is slightly different between passports\n// and ID cards so we need to define indices for both types\n\n// Index for the country of issuance of the passport\npub global PASSPORT_MRZ_COUNTRY_INDEX: u32 = 2;\n// Index for the three letter code of the country of citizenship\n// Note that the first three letter code (index 2) in the MRZ is the country of issuance\n// not citizenship. It is important to keep in mind for residence permits\n// where the issuing country differs from the citizenship country\npub global PASSPORT_MRZ_NATIONALITY_INDEX: u32 = 54;\n// Index for the gender of the passport holder (M, F or < if unspecified)\npub global PASSPORT_MRZ_GENDER_INDEX: u32 = 64;\n// Index for the date of expiry (YYMMDD)\npub global PASSPORT_MRZ_EXPIRY_DATE_INDEX: u32 = 65;\n// Index for the date of birth (YYMMDD) in TD1 (i.e. passport) MRZ\npub global PASSPORT_MRZ_BIRTHDATE_INDEX: u32 = 57;\n// Index for the document number in the MRZ\npub global PASSPORT_MRZ_DOCUMENT_NUMBER_INDEX: u32 = 44;\n// Index for the document type in the MRZ\npub global PASSPORT_MRZ_DOCUMENT_TYPE_INDEX: u32 = 0;\n// Index for the name of the passport holder\npub global PASSPORT_MRZ_NAME_INDEX: u32 = 5;\n// Length of the MRZ on a passport\npub global PASSPORT_MRZ_LENGTH: u32 = 88;\n\n// Index for the country of issuance of the ID card\npub global ID_CARD_MRZ_COUNTRY_INDEX: u32 = 2;\n// Note that the first three letter code (index 2) in the MRZ is the country of issuance\n// not citizenship. It is important to keep in mind for residence permits\n// where the issuing country differs from the citizenship country\npub global ID_CARD_MRZ_NATIONALITY_INDEX: u32 = 45;\n// Index for the gender of the passport holder (M, F or < if unspecified)\npub global ID_CARD_MRZ_GENDER_INDEX: u32 = 37;\n// Index for the date of expiry (YYMMDD)\npub global ID_CARD_MRZ_EXPIRY_DATE_INDEX: u32 = 38;\n// Index for the date of birth (YYMMDD) in TD3 (i.e. ID cards) MRZ\npub global ID_CARD_MRZ_BIRTHDATE_INDEX: u32 = 30;\n// Index for the document number in the MRZ\npub global ID_CARD_MRZ_DOCUMENT_NUMBER_INDEX: u32 = 5;\n// Index for the document type in the MRZ\npub global ID_CARD_MRZ_DOCUMENT_TYPE_INDEX: u32 = 0;\n// Index for the name of the passport holder\npub global ID_CARD_MRZ_NAME_INDEX: u32 = 60;\n// Length of the MRZ on an ID card\npub global ID_CARD_MRZ_LENGTH: u32 = 90;\n\n// ECDSA curves mapping\npub global ECDSA_CURVE_P256: u32 = 0;\npub global ECDSA_CURVE_P384: u32 = 1;\npub global ECDSA_CURVE_P521: u32 = 2;\npub global ECDSA_CURVE_BRAINPOOL_B256R1: u32 = 3;\npub global ECDSA_CURVE_BRAINPOOL_B256T1: u32 = 4;\npub global ECDSA_CURVE_BRAINPOOL_B384R1: u32 = 5;\npub global ECDSA_CURVE_BRAINPOOL_B384T1: u32 = 6;\npub global ECDSA_CURVE_BRAINPOOL_B512R1: u32 = 7;\npub global ECDSA_CURVE_BRAINPOOL_B512T1: u32 = 8;\n\npub struct IDData {\n    // Regroups the hashes of all the data groups plus some padding\n    // at the start and in between each data group hashes\n    pub e_content: [u8; 700],\n    pub e_content_size: u32,\n    // Where we can find e_content in the signed_attributes\n    // It varies from document to document according to the length\n    // of the padding at the start\n    pub dg1_offset_in_e_content: u32,\n    // Last 32 bytes: result of the hash of all the hashes of the data groups\n    // Rest of the bytes: information about the signature algorithm, date, etc.\n    pub signed_attributes: [u8; 200],\n    pub signed_attributes_size: u32,\n    // The DG1 contains the Machine Readable Zone (MRZ) of the document\n    // The two lines at the bottom of the passport data page\n    // or the three bottom lines on the rear of an ID card\n    // 95 bytes for passports, 93 bytes for ID cards\n    // Including 88 bytes of MRZ and 5 bytes of padding for passports\n    // and 90 bytes of MRZ and 5 bytes of padding for ID cards\n    pub dg1: [u8; 95],\n    // The signature over the data groups\n    pub sod_signature: [u8; 512],\n    pub sod_signature_size: u32,\n}\n\npub struct DSCData {\n    // The TBS certificate of the DSC\n    // TBS stands for To Be Signed\n    pub tbs_certificate: [u8; 1500],\n    pub tbs_certificate_size: u32,\n    // The public key of the DSC (up to 512 bytes to account for RSA-4096)\n    pub pubkey: [u8; 512],\n    // The actual size of the public key\n    pub pubkey_size: u32,\n    // The index of the public key in the TBS certificate\n    pub pubkey_index: u32,\n    // Data used to verify the signature\n    // Generated by the pre-compute function in Rust\n    // c.f. main.rs\n    pub pubkey_redc_param: [u8; 513],\n    // The signature over the TBS certificate\n    pub signature: [u8; 512],\n    pub signature_size: u32,\n    // The exponent of the public key\n    // Only useful for RSA, can be ignored for ECDSA\n    pub exponent: u32,\n}\n\npub struct CSCData {\n    // The public key of the CSC (up to 512 bytes to account for RSA-4096)\n    pub pubkey: [u8; 512],\n    // The actual size of the public key\n    pub pubkey_size: u32,\n    // Data used to verify the signature\n    // Generated by the pre-compute function in Rust\n    // c.f. main.rs\n    pub pubkey_redc_param: [u8; 513],\n    // Only useful for RSA, can be ignored for ECDSA\n    pub exponent: u32,\n}\n\npub struct DiscloseFlags {\n    pub issuing_country: bool,\n    pub nationality: bool,\n    pub document_type: bool,\n    pub document_number: bool,\n    pub date_of_expiry: bool,\n    pub date_of_birth: bool,\n    pub gender: bool,\n    pub name: bool,\n}\n\npub struct DisclosedData {\n    pub issuing_country: [u8; 3],\n    pub nationality: [u8; 3],\n    pub document_type: [u8; 2],\n    pub document_number: [u8; 9],\n    pub date_of_expiry: [u8; 6],\n    pub date_of_birth: [u8; 6],\n    pub name: [u8; 39],\n    pub gender: [u8; 1],\n}\n\npub fn get_array_slice<let N: u32, let M: u32>(arr: [u8; N], start: u32, end: u32) -> [u8; M] {\n    let mut slice = [0 as u8; M];\n    for i in start..end {\n        slice[i - start] = arr[i];\n    }\n    slice\n}\n\npub fn get_array_slice_constant<let N: u32, let M: u32>(arr: [u8; N]) -> [u8; M] {\n    let mut slice = [0 as u8; M];\n    for i in 0..M {\n        slice[i] = arr[i];\n    }\n    slice\n}\n\n// Reverse the bytes of an array so you can switch from\n// big endian to little endian order and vice versa\npub fn reverse_bytes_array<let N: u32>(arr: [u8; N]) -> [u8; N] {\n    let mut reversed_arr = [0 as u8; N];\n    for i in 0..N {\n        // Reverse\n        reversed_arr[i] = arr[N - 1 - i];\n    }\n    reversed_arr\n}\n\npub fn insert_into_array<let N: u32, let M: u32>(\n    mut arr: [u8; N],\n    sub_arr: [u8; M],\n    index: u32,\n) -> [u8; N] {\n    for i in index..index + M {\n        arr[i] = sub_arr[i - index];\n    }\n    arr\n}\n\npub fn dynamic_insert_into_array<let N: u32, let M: u32>(\n    mut arr: [u8; N],\n    sub_arr: [u8; M],\n    index: u32,\n    max_size: u32,\n) -> [u8; N] {\n    for i in index..index + max_size {\n        if i - index < M {\n            arr[i] = sub_arr[i - index];\n        }\n    }\n    arr\n}\n\npub fn is_id_card(dg1: [u8; 95]) -> bool {\n    // For passport, the last two bytes are 0\n    // since the real length is 93 for passports\n    // while it is 95 for ID cards\n    (dg1[93] != 0) & (dg1[94] != 0)\n}\n\npub fn from_byte_be_to_fields<let NBytes: u32, let N: u32>(x: [u8; NBytes]) -> [Field; N] {\n    let mut result = [0 as Field; N];\n\n    let mut limb: Field = 0;\n    let mut k = 0;\n    for _j in 0..(15 - (N * 15 - NBytes)) {\n        limb *= 256;\n        limb += x[k] as Field;\n        k += 1;\n    }\n    std::as_witness(limb);\n\n    result[N - 1] = limb;\n\n    for i in 1..N {\n        let mut limb: Field = 0;\n        for _j in 0..15 {\n            limb *= 256;\n            limb += x[k] as Field;\n            k += 1;\n        }\n        std::as_witness(limb);\n        result[N - i - 1] = limb;\n    }\n\n    result\n}\n\npub unconstrained fn __from_byte_be_to_fields<let NBytes: u32, let N: u32>(\n    x: [u8; NBytes],\n) -> [Field; N] {\n    from_byte_be_to_fields(x)\n}\n\npub fn get_mrz_from_dg1(dg1: [u8; 95]) -> [u8; 90] {\n    let mut mrz = [0 as u8; 90];\n    for i in 0..90 {\n        mrz[i] = dg1[i + 5];\n    }\n    mrz\n}\n\npub fn split_array<let N: u32>(array: [u8; N * 2]) -> ([u8; N], [u8; N]) {\n    let mut array_x = [0 as u8; N];\n    let mut array_y = [0 as u8; N];\n    for i in 0..N {\n        array_x[i] = array[i];\n        array_y[i] = array[i + N];\n    }\n    (array_x, array_y)\n}\n\npub fn concat_array<let N: u32>(array_x: [u8; N], array_y: [u8; N]) -> [u8; N * 2] {\n    let mut array = [0 as u8; N * 2];\n    for i in 0..N {\n        array[i] = array_x[i];\n        array[i + N] = array_y[i];\n    }\n    array\n}\n\npub fn check_zero_padding<let N: u32, T>(padded_array: [T; N], len: u32)\nwhere\n    T: Eq,\n    T: Default,\n{\n    for i in 0..N {\n        if i >= len {\n            assert_eq(padded_array[i], T::default());\n        }\n    }\n}\n\npub fn get_nationality_from_mrz(dg1: [u8; 95]) -> [u8; 3] {\n    let mrz = get_mrz_from_dg1(dg1);\n\n    let mut country_bytes: [u8; 3] = [0; 3];\n\n    if is_id_card(dg1) {\n        country_bytes = get_array_slice(\n            mrz,\n            ID_CARD_MRZ_NATIONALITY_INDEX,\n            ID_CARD_MRZ_NATIONALITY_INDEX + 3,\n        );\n    } else {\n        country_bytes = get_array_slice(\n            mrz,\n            PASSPORT_MRZ_NATIONALITY_INDEX,\n            PASSPORT_MRZ_NATIONALITY_INDEX + 3,\n        );\n    }\n\n    country_bytes\n}\n","path":"/Users/madztheo/Documents/Wagmi/Studio/RnD/Docaproof/Circuits/zk_id_check_circuits/src/noir/lib/utils/src/lib.nr"},"66":{"source":"use utils::get_nationality_from_mrz;\n\nunconstrained fn get_closest_index<let N: u32>(sorted_list: [u32; N], value: u32) -> u32 {\n    for i in 0..N {\n        if sorted_list[i] > value {\n            i\n        }\n    }\n    0\n}\n\n/// Check if the nationality from the MRZ is not in the country list\n/// The list of countries is assumed to be sorted in ascending order\n/// So it must come either from a public input that can be independently checked\n/// or from a previous in-circuit check that the list is sorted\n///\n/// # Arguments\n///\n/// * `dg1` - The DG1 of the passport or ID card\n/// * `country_list` - The sorted list of countries to check against, must be formatted as a list of u32\n/// which are the Alpha-3 codes of the countries with each letter ASCII code put together using a weighted sum.\n/// e.g. for \"FRA\", the sum is 70 * 2^16 (0x10000) + 82 * 2^8 (0x100) + 65 = 4587520 + 20992 + 65 = 4608577\npub fn check_country_exclusion<let N: u32>(dg1: [u8; 95], country_list: [u32; N]) {\n    let nationality_bytes = get_nationality_from_mrz(dg1);\n    let nationality_sum: u32 = nationality_bytes[0] as u32 * 0x10000\n        + nationality_bytes[1] as u32 * 0x100\n        + nationality_bytes[2] as u32;\n\n    // Since the list is assumed to be sorted in ascending order, we can get the index to check against\n    // from an unconstrained function\n    let closest_index = unsafe { get_closest_index(country_list, nationality_sum) };\n    // Assert that either the index is the first element of the list or the previous element is less than the nationality sum\n    if closest_index == 0 {\n        // Assert that the country at the index is greater than the nationality sum\n        assert(country_list[closest_index] > nationality_sum);\n    }\n    // Cannot be done in a single if statement otherwise the second check will fail if closest_index is 0\n    else if country_list[closest_index - 1] < nationality_sum {\n        // Assert that the country at the index is greater than the nationality sum\n        assert(country_list[closest_index] > nationality_sum);\n    } else {\n        // Otherwise it should fail\n        assert(false);\n    }\n    // If those two checks pass, then the nationality is not in the country list\n}\n","path":"/Users/madztheo/Documents/Wagmi/Studio/RnD/Docaproof/Circuits/zk_id_check_circuits/src/noir/lib/exclusion-check/country/src/lib.nr"}},"names":["main"],"brillig_names":["get_closest_index","directive_invert","directive_integer_quotient"]}